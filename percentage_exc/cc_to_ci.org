* Cluster decomposition

#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
program cc_to_ci
  implicit none

  BEGIN_DOC
  ! To compute the ci coeffcients from the CCSD/CCSD(T) amplitudes
  END_DOC

  integer :: nO,nV
  double precision,allocatable :: t1(:,:),t2(:,:,:,:)

  read_wf = .True.
  touch read_wf

  if (trim(io_amplitudes) /= 'Read') then
    stop 'Please set io_amplitudes to "Write" and run a ccsd calculation'
  endif

  print*, 'If the calculation stops just after this message, it means that the ccsd'
  print*, 'calculation have been done with spatial orbitals.'
  print*, 'Against that, reset io_amplitudes to "Write" and run:'
  print*, 'qp run ccsd_spin_orb'
  
  nO = cc_nOab
  nV = cc_nVab

  allocate(t1(nO,nV),t2(nO,nO,nV,nV))

  call read_t1(nO,nV,t1)
  call read_t2(nO,nV,t2)
  
  call smart_xc(nO,nV,t1,t2)
  
end
#+end_src

** Prog
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine smart_xc(nO,nV,t1_cc,t2_cc)

  implicit none

  integer, intent(in) :: nO,nV
  double precision, intent(in) :: t1_cc(nO,nV), t2_cc(nO,nO,nV,nV)

  integer :: sze_t1, sze_t2, sze_t3
  integer :: sze_t11, sze_t12, sze_t13, sze_t22, sze_t23, sze_t33
  integer :: sze_t111, sze_t112, sze_t113, sze_t122, sze_t123
  integer :: sze_t222, sze_t1111
  
  double precision, allocatable :: t1(:),t2(:),t3(:)
  double precision, allocatable :: t11(:),t12(:),t13(:),t22(:),t23(:),t33(:)
  double precision, allocatable :: t111(:),t112(:),t113(:),t122(:),t123(:),t222(:)
  double precision, allocatable :: t1111(:)
  
  integer, allocatable :: t1_idx(:,:), t2_idx(:,:), t3_idx(:,:) 
  integer, allocatable :: t11_idx(:,:), t12_idx(:,:), t13_idx(:,:)
  integer, allocatable :: t22_idx(:,:), t23_idx(:,:), t33_idx(:,:)
  integer, allocatable :: t111_idx(:,:), t112_idx(:,:), t113_idx(:,:)
  integer, allocatable :: t122_idx(:,:), t222_idx(:,:), t123_idx(:,:)
  integer, allocatable :: t1111_idx(:,:)
  
  integer :: sze_c1, sze_c2, sze_c3, sze_c4, sze_c5, sze_c6
  integer :: new_sze_c2, new_sze_c3, new_sze_c4, new_sze_c5,new_sze_c6
  
  integer, allocatable :: c1_idx(:,:), c2_idx(:,:), c3_idx(:,:), c4_idx(:,:)
  integer, allocatable :: c5_idx(:,:), c6_idx(:,:)
  double precision, allocatable  :: c1(:), c2(:), c3(:), c4(:), c5(:), c6(:)
  
  integer(bit_kind), allocatable :: c1_det(:,:,:), c2_det(:,:,:), c5_det(:,:,:)
  integer(bit_kind), allocatable :: c3_det(:,:,:), c4_det(:,:,:), c6_det(:,:,:)
  double precision, allocatable  :: c1_coef(:), c2_coef(:), c3_coef(:), c4_coef(:)
  double precision, allocatable  :: c5_coef(:) , c6_coef(:)
  
  integer :: sze_cc
  integer(bit_kind), allocatable :: psi_det_cc(:,:,:)
  double precision, allocatable  :: psi_coef_cc(:)
  
  double precision, allocatable  :: f_o(:), f_v(:), f_oo(:,:), f_vv(:,:)
  double precision, allocatable  :: v_ooov(:,:,:,:), v_vvvo(:,:,:,:)
  
  double precision           :: phase,norm,energy, s2_val
  double precision           :: thresh, thresh_t1
  integer(bit_kind)          :: det(N_int,2)
  integer                    :: degree
  integer                    :: i,j,k,l,a,b,c,d,idx
  logical                    :: all_t1
  double precision, external :: f_norm

  all_t1 = .True.

  ! Thresh
  thresh = thresh_extract_c

  if (all_t1) then
    thresh_t1 = 1d-16
  else
    thresh_t1 = thresh
  endif

  ! t1
  call contrib_t1_nb(nO,nV,thresh_t1,t1_cc,sze_t1)
  allocate(t1(sze_t1),t1_idx(2,sze_t1))
  call contrib_t1(nO,nV,thresh_t1,t1_cc,sze_t1,t1,t1_idx)
  write(*,'(A6,I10,1pE12.4)') 't1   ', sze_t1   , f_norm(t1   ,sze_t1   )
  
  ! t2
  call contrib_t2_nb(nO,nV,thresh,t2_cc,sze_t2)
  allocate(t2(sze_t2),t2_idx(4,sze_t2))
  call contrib_t2(nO,nV,thresh,t2_cc,sze_t2,t2,t2_idx)
  write(*,'(A6,I10,1pE12.4)') 't2   ', sze_t2   , f_norm(t2   ,sze_t2   )

  ! T3 from (T)
  ! Only for canonical orbitals !!!
  if (use_par_t) then
    allocate(f_oo(nO,nO),f_vv(nV,nV),f_o(nO),f_v(nV))
    allocate(v_ooov(nO,nO,nO,nV),v_vvvo(nV,nV,nV,nO))
    
    ! Fock elements
    call gen_f_spin(psi_det(1,1,cc_ref), cc_nO_m,cc_nO_m, cc_nO_S,cc_nO_S, cc_list_occ_spin,cc_list_occ_spin, nO,nO, f_oo)
    call gen_f_spin(psi_det(1,1,cc_ref), cc_nV_m,cc_nV_m, cc_nV_S,cc_nV_S, cc_list_vir_spin,cc_list_vir_spin, nV,nV, f_vv)

    ! Diag elements
    do i = 1, nO
      f_o(i) = f_oo(i,i)
    enddo
    do i = 1, nV
      f_v(i) = f_vv(i,i)
    enddo

    ! Load int for (T)
    call gen_v_spin(cc_nO_m,cc_nO_m,cc_nO_m,cc_nV_m, &
         cc_nO_S,cc_nO_S,cc_nO_S,cc_nV_S, &
         cc_list_occ_spin,cc_list_occ_spin,cc_list_occ_spin,cc_list_vir_spin, &
         nO,nO,nO,nV, v_ooov)
    
    call gen_v_spin(cc_nV_m,cc_nV_m,cc_nV_m,cc_nO_m, &
         cc_nV_S,cc_nV_S,cc_nV_S,cc_nO_S, &
         cc_list_vir_spin,cc_list_vir_spin,cc_list_vir_spin,cc_list_occ_spin, &
         nV,nV,nV,nO, v_vvvo)

    ! t3
    call contrib_t3_nb(nO,nV,thresh,t1_cc,t2_cc,f_o,f_v, &
    v_ooov,v_vvvo,sze_t3)
    allocate(t3(sze_t3), t3_idx(6,sze_t3))
    call contrib_t3(nO,nV,thresh,t1_cc,t2_cc,f_o,f_v, &
    v_ooov,v_vvvo,sze_t3,t3,t3_idx)

  else
    sze_t3 = 1
    allocate(t3(sze_t3), t3_idx(6,sze_t3))
    sze_t3 = 0
  endif
  write(*,'(A6,I10,1pE12.4)') 't3   ', sze_t3   , f_norm(t3   ,sze_t3   )

  ! t11
  call contrib_t11_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11)
  allocate(t11(sze_t11),t11_idx(4,sze_t11))
  call contrib_t11(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx)
  write(*,'(A6,I10,1pE12.4)') 't11  ', sze_t11  , f_norm(t11  ,sze_t11  )
        
  ! t12
  call contrib_t12_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx,sze_t12)
  allocate(t12(sze_t12),t12_idx(6,sze_t12))
  call contrib_t12(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx, &
       sze_t12,t12,t12_idx)
  write(*,'(A6,I10,1pE12.4)') 't12  ', sze_t12  , f_norm(t12  ,sze_t12  )
  
  ! t13
  call contrib_t13_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,&
     sze_t13)
  allocate(t13(sze_t13),t13_idx(8,sze_t13))
  call contrib_t13(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,&
     sze_t13,t13,t13_idx)
  write(*,'(A6,I10,1pE12.4)') 't13  ', sze_t13  , f_norm(t13  ,sze_t13  )
        
  ! t22
  call contrib_t22_nb(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22)
  allocate(t22(sze_t22),t22_idx(8,sze_t22))
  call contrib_t22(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx)
  write(*,'(A6,I10,1pE12.4)') 't22  ', sze_t22  , f_norm(t22  ,sze_t22  )

  ! t23
  call contrib_t23_nb(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t3,t3,t3_idx,&
     sze_t23)
  allocate(t23(sze_t23),t23_idx(10,sze_t23))
  call contrib_t23(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t3,t3,t3_idx,&
     sze_t23,t23,t23_idx)
  write(*,'(A6,I10,1pE12.4)') 't23  ', sze_t23  , f_norm(t23  ,sze_t23  )

  ! t33
  call contrib_t33_nb(nO,nV,thresh,sze_t3,t3,t3_idx,sze_t33)
  allocate(t33(sze_t33),t33_idx(12,sze_t33))
  call contrib_t33(nO,nV,thresh,sze_t3,t3,t3_idx,sze_t33,t33,t33_idx)
  write(*,'(A6,I10,1pE12.4)') 't33  ', sze_t33  , f_norm(t33  ,sze_t33  )

  ! t111
  call contrib_t111_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx,sze_t111)
  allocate(t111(sze_t111),t111_idx(6,sze_t111))
  call contrib_t111(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx, &
       sze_t111,t111,t111_idx)
  write(*,'(A6,I10,1pE12.4)') 't111 ', sze_t111 , f_norm(t111 ,sze_t111 )

  ! t112
  call contrib_t112_nb(nO,nV,thresh,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx,&
     sze_t112)
  allocate(t112(sze_t112),t112_idx(8,sze_t112))
  call contrib_t112(nO,nV,thresh,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx,&
     sze_t112,t112,t112_idx)
  write(*,'(A6,I10,1pE12.4)') 't112 ', sze_t112 , f_norm(t112 ,sze_t112 )

  ! t113
  call contrib_t113_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t13,t13,t13_idx,&
     sze_t113)
  allocate(t113(sze_t113),t113_idx(10,sze_t113))
  call contrib_t113(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t13,t13,t13_idx,&
     sze_t113,t113,t113_idx)
  write(*,'(A6,I10,1pE12.4)') 't113 ', sze_t113 , f_norm(t113 ,sze_t113 )

  ! t122
  call contrib_t122_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t22,t22,t22_idx,&
     sze_t122)
  allocate(t122(sze_t122),t122_idx(10,sze_t122))
  call contrib_t122(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t22,t22,t22_idx,&
     sze_t122,t122,t122_idx)
  write(*,'(A6,I10,1pE12.4)') 't122 ', sze_t122 , f_norm(t122 ,sze_t122 )
  
  ! t123
  call contrib_t123_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t23,t23,t23_idx,&
     sze_t123)
  allocate(t123(sze_t123),t123_idx(12,sze_t123))
  call contrib_t123(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t23,t23,t23_idx,&
     sze_t123,t123,t123_idx)
  write(*,'(A6,I10,1pE12.4)') 't123 ', sze_t123 , f_norm(t123 ,sze_t123 )

  ! t222
  call contrib_t222_nb(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx, &
     sze_t222)
  allocate(t222(sze_t222),t222_idx(12,sze_t222))
  call contrib_t222(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx, &
     sze_t222,t222,t222_idx)
  write(*,'(A6,I10,1pE12.4)') 't222 ', sze_t222 , f_norm(t222 ,sze_t222 )

  ! t1111
  call contrib_t1111_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx, &
     sze_t1111)
  allocate(t1111(sze_t1111),t1111_idx(8,sze_t1111))
  call contrib_t1111(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx, &
     sze_t1111,t1111,t1111_idx)
  write(*,'(A6,I10,1pE12.4)') 't1111', sze_t1111, f_norm(t1111,sze_t1111)

  ! Recursive sort after the reordering
  call recursive_sort_idx(t2,t2_idx,sze_t2,4,1)
  call recursive_sort_idx(t11,t11_idx,sze_t11,4,1)
  call recursive_sort_idx(t12,t12_idx,sze_t12,6,1)
  call recursive_sort_idx(t13,t13_idx,sze_t13,8,1)
  call recursive_sort_idx(t22,t22_idx,sze_t22,8,1)
  call recursive_sort_idx(t23,t23_idx,sze_t23,10,1)
  call recursive_sort_idx(t33,t33_idx,sze_t33,12,1)
  call recursive_sort_idx(t111,t111_idx,sze_t111,6,1)
  call recursive_sort_idx(t112,t112_idx,sze_t112,8,1)
  call recursive_sort_idx(t113,t113_idx,sze_t113,10,1)
  call recursive_sort_idx(t122,t122_idx,sze_t122,10,1)
  call recursive_sort_idx(t123,t123_idx,sze_t123,12,1)
  call recursive_sort_idx(t222,t222_idx,sze_t222,12,1)
  call recursive_sort_idx(t1111,t1111_idx,sze_t1111,8,1)

  ! Remove the duplicate and accumulate
  call remove_duplicate_idx(t2,t2_idx,sze_t2,4)
  call remove_duplicate_idx(t11,t11_idx,sze_t11,4)
  call remove_duplicate_idx(t12,t12_idx,sze_t12,6)
  call remove_duplicate_idx(t13,t13_idx,sze_t13,8)
  call remove_duplicate_idx(t22,t22_idx,sze_t22,8)
  call remove_duplicate_idx(t23,t23_idx,sze_t23,10)
  call remove_duplicate_idx(t33,t33_idx,sze_t33,12)
  call remove_duplicate_idx(t111,t111_idx,sze_t111,6)
  call remove_duplicate_idx(t112,t112_idx,sze_t112,8)
  call remove_duplicate_idx(t113,t113_idx,sze_t113,10)
  call remove_duplicate_idx(t122,t122_idx,sze_t122,10)
  call remove_duplicate_idx(t123,t123_idx,sze_t123,12)
  call remove_duplicate_idx(t222,t222_idx,sze_t222,12)
  call remove_duplicate_idx(t1111,t1111_idx,sze_t1111,8)
  
  print*,''
  print*,'After removing the duplicates:'
  write(*,'(A6,A10,A12)')     '     ', '  N'    , 'Norm' 
  write(*,'(A6,I10,1pE12.4)') 't1   ', sze_t1   , f_norm(t1   ,sze_t1   )
  write(*,'(A6,I10,1pE12.4)') 't2   ', sze_t2   , f_norm(t2   ,sze_t2   )
  write(*,'(A6,I10,1pE12.4)') 't3   ', sze_t3   , f_norm(t3   ,sze_t3   )
  write(*,'(A6,I10,1pE12.4)') 't11  ', sze_t11  , f_norm(t11  ,sze_t11  )
  write(*,'(A6,I10,1pE12.4)') 't12  ', sze_t12  , f_norm(t12  ,sze_t12  )
  write(*,'(A6,I10,1pE12.4)') 't13  ', sze_t13  , f_norm(t13  ,sze_t13  )
  write(*,'(A6,I10,1pE12.4)') 't22  ', sze_t22  , f_norm(t22  ,sze_t22  )
  write(*,'(A6,I10,1pE12.4)') 't23  ', sze_t23  , f_norm(t23  ,sze_t23  )
  write(*,'(A6,I10,1pE12.4)') 't33  ', sze_t33  , f_norm(t33  ,sze_t33  )
  write(*,'(A6,I10,1pE12.4)') 't111 ', sze_t111 , f_norm(t111 ,sze_t111 )
  write(*,'(A6,I10,1pE12.4)') 't112 ', sze_t112 , f_norm(t112 ,sze_t112 )
  write(*,'(A6,I10,1pE12.4)') 't113 ', sze_t113 , f_norm(t113 ,sze_t113 )
  write(*,'(A6,I10,1pE12.4)') 't122 ', sze_t122 , f_norm(t122 ,sze_t122 )
  write(*,'(A6,I10,1pE12.4)') 't123 ', sze_t123 , f_norm(t123 ,sze_t123 )
  write(*,'(A6,I10,1pE12.4)') 't222 ', sze_t222 , f_norm(t222 ,sze_t222 )
  write(*,'(A6,I10,1pE12.4)') 't1111', sze_t1111, f_norm(t1111,sze_t1111)
  
  ! Gather lists with the same number of indexes
  sze_c1 = sze_t1
  sze_c2 = sze_t11 + sze_t2
  sze_c3 = sze_t111 + sze_t12 + sze_t3
  sze_c4 = sze_t1111 + sze_t112 + sze_t22 + sze_t13
  sze_c5 = sze_t23 + sze_t122 + sze_t113
  sze_c6 = sze_t222 + sze_t33 + sze_t123

  allocate(c1_idx(2,sze_c1), c2_idx(4,sze_c2))
  allocate(c3_idx(6,sze_c3))
  allocate(c4_idx(8,sze_c4))
  allocate(c5_idx(10,sze_c5))
  allocate(c6_idx(12,sze_c6))
  allocate(c1(sze_c1), c2(sze_c2))
  allocate(c3(sze_c3))
  allocate(c4(sze_c4))
  allocate(c5(sze_c5))
  allocate(c6(sze_c6))

  ! C1
  ! t1
  do i = 1, sze_t1
    c1(i) = t1(i)
    c1_idx(:,i) = t1_idx(:,i)
  enddo

  ! C2
  ! t2
  do i = 1, sze_t2
    c2(i) = t2(i)
    c2_idx(:,i) = t2_idx(:,i)
  enddo
  k = sze_t2
  ! t11
  do i = 1, sze_t11
    c2(k+i) = t11(i)
    c2_idx(:,k+i) = t11_idx(:,i)
  enddo

  ! C3
  ! t12
  do i = 1, sze_t12
    c3(i) = t12(i)
    c3_idx(:,i) = t12_idx(:,i)
  enddo
  k = sze_t12
  ! t111
  do i = 1, sze_t111
    c3(k+i) = t111(i)
    c3_idx(:,k+i) = t111_idx(:,i)
  enddo
  k = k + sze_t111
  ! t3
  do i = 1, sze_t3
    c3(k+i) = t3(i)
    c3_idx(:,k+i) = t3_idx(:,i)
  enddo 

  ! C4
  ! t22
  do i = 1, sze_t22
    c4(i) = t22(i)
    c4_idx(:,i) = t22_idx(:,i)
  enddo
  k = sze_t22
  ! t112
  do i = 1, sze_t112
    c4(k+i) = t112(i)
    c4_idx(:,k+i) = t112_idx(:,i)
  enddo
  k = k + sze_t112
  ! t1111
  do i = 1, sze_t1111
    c4(k+i) = t1111(i)
    c4_idx(:,k+i) = t1111_idx(:,i)
  enddo
  k = k + sze_t1111
  ! t13
  do i = 1, sze_t13
    c4(k+i) = t13(i)
    c4_idx(:,k+i) = t13_idx(:,i)
  enddo

  ! C5
  ! t23
  do i = 1, sze_t23
    c5(i) = t23(i)
    c5_idx(:,i) = t23_idx(:,i)
  enddo
  k = sze_t23
  ! t122
  do i = 1, sze_t122
    c5(k+i) = t122(i)
    c5_idx(:,k+i) = t122_idx(:,i)
  enddo
  k = k + sze_t122
  ! t113
  do i = 1, sze_t113
    c5(k+i) = t113(i)
    c5_idx(:,k+i) = t113_idx(:,i)
  enddo

  ! C6
  ! t222
  do i = 1, sze_t222
    c6(i) = t222(i)
    c6_idx(:,i) = t222_idx(:,i)
  enddo
  k = sze_t222
  ! t33
  do i = 1, sze_t33
    c6(k+i) = t33(i)
    c6_idx(:,k+i) = t33_idx(:,i)
  enddo
  k = k + sze_t33
  ! t123
  do i = 1, sze_t123
    c6(k+i) = t123(i)
    c6_idx(:,k+i) = t123_idx(:,i)
  enddo
  
  ! Sort
  call recursive_sort_idx(c2,c2_idx,sze_c2,4,1)
  call recursive_sort_idx(c3,c3_idx,sze_c3,6,1)
  call recursive_sort_idx(c4,c4_idx,sze_c4,8,1)
  call recursive_sort_idx(c5,c5_idx,sze_c5,10,1)
  call recursive_sort_idx(c6,c6_idx,sze_c6,12,1)
  
  ! Remove the duplicate and accumulate
  call remove_duplicate_idx(c2,c2_idx,sze_c2,4)
  call remove_duplicate_idx(c3,c3_idx,sze_c3,6)
  call remove_duplicate_idx(c4,c4_idx,sze_c4,8)
  call remove_duplicate_idx(c5,c5_idx,sze_c5,10)
  call remove_duplicate_idx(c6,c6_idx,sze_c6,12)

  print*,''
  write(*,'(A6,I10,1pE12.4)') 'C1   ', sze_c1, f_norm(c1,sze_c1)
  write(*,'(A6,I10,1pE12.4)') 'C2   ', sze_c2, f_norm(c2,sze_c2)
  write(*,'(A6,I10,1pE12.4)') 'C3   ', sze_c3, f_norm(c3,sze_c3)
  write(*,'(A6,I10,1pE12.4)') 'C4   ', sze_c4, f_norm(c4,sze_c4)
  write(*,'(A6,I10,1pE12.4)') 'C5   ', sze_c5, f_norm(c5,sze_c5)
  write(*,'(A6,I10,1pE12.4)') 'C6   ', sze_c6, f_norm(c6,sze_c6)

  ! Build the determinants
  allocate(c1_det(N_int,2,sze_c1),c1_coef(sze_c1))
  allocate(c2_det(N_int,2,sze_c2),c2_coef(sze_c2))
  allocate(c3_det(N_int,2,sze_c3),c3_coef(sze_c3))
  allocate(c4_det(N_int,2,sze_c4),c4_coef(sze_c4))
  allocate(c5_det(N_int,2,sze_c5),c5_coef(sze_c5))
  allocate(c6_det(N_int,2,sze_c6),c6_coef(sze_c6))

  call build_det_t(c1,c1_idx,sze_c1,2,c1_det,c1_coef)
  call build_det_t(c2,c2_idx,sze_c2,4,c2_det,c2_coef)
  call build_det_t(c3,c3_idx,sze_c3,6,c3_det,c3_coef)
  call build_det_t(c4,c4_idx,sze_c4,8,c4_det,c4_coef)
  call build_det_t(c5,c5_idx,sze_c5,10,c5_det,c5_coef)
  call build_det_t(c6,c6_idx,sze_c6,12,c6_det,c6_coef)

  sze_cc = 1 + sze_c1 + sze_c2 + sze_c3 + sze_c4 + sze_c5 + sze_c6

  allocate(psi_det_cc(N_int,2,sze_cc),psi_coef_cc(sze_cc))

  ! Ref
  psi_coef_cc(1) = 1d0
  psi_det_cc(:,:,1) = psi_det(:,:,cc_ref)

  ! C1
  k = 1
  do i = 1, sze_c1
    psi_coef_cc(k+i) = c1_coef(i)
    psi_det_cc(:,:,k+i) = c1_det(:,:,i)
  enddo

  ! C2
  k = k + sze_c1
  do i = 1, sze_c2
    psi_coef_cc(k+i) = c2_coef(i)
    psi_det_cc(:,:,k+i) = c2_det(:,:,i)
  enddo

  ! C3
  k = k + sze_c2
  do i = 1, sze_c3
    psi_coef_cc(k+i) = c3_coef(i)
    psi_det_cc(:,:,k+i) = c3_det(:,:,i)
  enddo
  
  ! C4
  k = k + sze_c3
  do i = 1, sze_c4
    psi_coef_cc(k+i) = c4_coef(i)
    psi_det_cc(:,:,k+i) = c4_det(:,:,i)
  enddo

  ! C5
  k = k + sze_c4
  do i = 1, sze_c5
    psi_coef_cc(k+i) = c5_coef(i)
    psi_det_cc(:,:,k+i) = c5_det(:,:,i)
  enddo

  ! C6
  k = k + sze_c5
  do i = 1, sze_c6
    psi_coef_cc(k+i) = c6_coef(i)
    psi_det_cc(:,:,k+i) = c6_det(:,:,i)
  enddo

  write(*,'(A6,I10,1pE12.4)') ' Psi  ', sze_cc, f_norm(psi_coef_cc, sze_cc)

  ! Phase
  norm = 1d0
  det(:,:) = psi_det_cc(:,:,1)
  do i = 2, sze_cc
    !call print_det(psi_det_cc(1,1,i),N_int)
    call get_phase_general(det,psi_det_cc(1,1,i),phase,degree,N_int)
    psi_coef_cc(i) = psi_coef_cc(i) * phase
    norm = norm + psi_coef_cc(i)**2
  enddo

  ! E
  call i_H_psi(psi_det_cc(1,1,1),psi_det_cc,psi_coef_cc,N_int,sze_cc,sze_cc,1,energy)
  print*,''
  print*,'<0|H|Psi> =',energy+nuclear_repulsion

  ! Normalization
  norm = 1d0/dsqrt(norm)
  do i = 1, sze_cc
    psi_coef_cc(i) = psi_coef_cc(i) * norm
  enddo
  
  ! Sort by ci coef
  call sort_by_coef_det(psi_coef_cc,psi_det_cc,sze_cc,N_int)

  ! Overlap
  !call overlap_wf_safe(sze_cc,psi_det_cc,psi_coef_cc)
  call overlap_fast(psi_det,psi_coef,N_states,N_det,psi_det_cc,psi_coef_cc,1,sze_cc)

  ! Save wf
  call fill_H_apply_buffer_no_selection(sze_cc,psi_det_cc,N_int,0)
  call copy_H_apply_buffer_to_wf
  N_det = sze_cc
  psi_coef(:,1) = 0d0
  psi_det(:,:,:) = 0
  psi_coef(1:N_det,1) = psi_coef_cc
  psi_det(:,:,1:N_det) = psi_det_cc
  !call save_wf_cc(psi_det_cc,psi_coef_cc,sze_cc)
  TOUCH psi_det psi_coef N_det
  call save_wavefunction()

  if (.True.) then
    print*,''
    print*,'<Psi|H|Psi>/<Psi|Psi>   =',psi_energy(1)+nuclear_repulsion
    print*,'<Psi|S^2|Psi>/<Psi|Psi> =',psi_s2(1)
    print*,''
  endif

  deallocate(psi_det_cc,psi_coef_cc)
  
  !### Fill the square ###
  if (.not. fill_square) return

  double precision :: thresh_sf
  
  integer :: sze_t2_f, sze_t3_f, sze_t11_f, sze_t12_f
  integer :: sze_t13_f, sze_t22_f, sze_t33_f, sze_t23_f
  integer :: sze_t111_f, sze_t112_f, sze_t113_f
  integer :: sze_t122_f, sze_t123_f 
  integer :: sze_t222_f, sze_t1111_f
  
  double precision, allocatable :: t2_f(:), t3_f(:), t11_f(:), t12_f(:)
  double precision, allocatable :: t13_f(:), t22_f(:), t23_f(:), t33_f(:)
  double precision, allocatable :: t111_f(:), t112_f(:), t113_f(:)
  double precision, allocatable :: t122_f(:), t123_f(:), t222_f(:)
  double precision, allocatable :: t1111_f(:)
  
  integer, allocatable :: t2_idx_f(:,:), t3_idx_f(:,:), t11_idx_f(:,:)
  integer, allocatable :: t12_idx_f(:,:), t13_idx_f(:,:), t22_idx_f(:,:)
  integer, allocatable :: t23_idx_f(:,:), t33_idx_f(:,:), t111_idx_f(:,:)
  integer, allocatable :: t112_idx_f(:,:), t113_idx_f(:,:), t122_idx_f(:,:)
  integer, allocatable :: t123_idx_f(:,:), t222_idx_f(:,:), t1111_idx_f(:,:)

  thresh_sf = 1d-16

  ! T2 
  call contrib_t2_full_nb(nO,nV,thresh,thresh_sf,t2_cc,sze_t2_f)
  allocate(t2_f(sze_t2_f),t2_idx_f(4,sze_t2_f))
  call contrib_t2_full(nO,nV,thresh,thresh_sf,t2_cc,sze_t2_f,t2_f,t2_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't2   ', sze_t2_f   , f_norm(t2_f   ,sze_t2_f   )

  ! T3
  if (use_par_t) then
    call contrib_t3_full_nb(nO,nV,thresh,thresh_sf,t1_cc,t2_cc,f_o,f_v, &
    v_ooov,v_vvvo,sze_t3_f)
    allocate(t3_f(sze_t3_f),t3_idx_f(6,sze_t3_f))
    call contrib_t3_full(nO,nV,thresh,thresh_sf,t1_cc,t2_cc,f_o,f_v, &
    v_ooov,v_vvvo,sze_t3_f,t3_f,t3_idx_f)
  else
    sze_t3_f = 0
    allocate(t3_f(sze_t3_f),t3_idx_f(6,sze_t3_f))
  endif
  write(*,'(A6,I10,1pE12.4)') 't3   ', sze_t3_f   , f_norm(t3_f   ,sze_t3_f   )

  ! T11
  call contrib_t11_full_nb(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t11_f)
  allocate(t11_f(sze_t11_f),t11_idx_f(4,sze_t11_f))
  call contrib_t11_full(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t11_f,t11_f,t11_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't11  ', sze_t11_f  , f_norm(t11_f  ,sze_t11_f  )

  ! T12
  call contrib_t12_full_nb(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx,&
     sze_t12_f)
  allocate(t12_f(sze_t12_f),t12_idx_f(6,sze_t12_f))
  call contrib_t12_full(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx,&
     sze_t12_f,t12_f,t12_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't12  ', sze_t12_f  , f_norm(t12_f  ,sze_t12_f  )

  ! T13
  call contrib_t13_full_nb(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,&
     sze_t13_f)
  allocate(t13_f(sze_t13_f),t13_idx_f(8,sze_t13_f))
  call contrib_t13_full(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,&
     sze_t13_f,t13_f,t13_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't13  ', sze_t13_f  , f_norm(t13_f  ,sze_t13_f  )

  ! T22
  call contrib_t22_full_nb(nO,nV,thresh,thresh_sf,sze_t2,t2,t2_idx,sze_t22_f)
  allocate(t22_idx_f(8,sze_t22_f),t22_f(sze_t22_f))
  call contrib_t22_full(nO,nV,thresh,thresh_sf,sze_t2,t2,t2_idx,sze_t22_f,t22_f,t22_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't22  ', sze_t22_f  , f_norm(t22_f  ,sze_t22_f  )

  ! T23
  call contrib_t23_full_nb(nO,nV,thresh,thresh_sf,sze_t2,t2,t2_idx,sze_t3,t3,t3_idx,&
     sze_t23_f)
  allocate(t23_f(sze_t23_f),t23_idx_f(10,sze_t23_f))
  call contrib_t23_full(nO,nV,thresh,thresh_sf,sze_t2,t2,t2_idx,sze_t3,t3,t3_idx,&
     sze_t23_f,t23_f,t23_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't23  ', sze_t23_f  , f_norm(t23_f  ,sze_t23_f  )
  
  ! T33
  call contrib_t33_full_nb(nO,nV,thresh,thresh_sf,sze_t3,t3,t3_idx,&
     sze_t33_f)
  allocate(t33_f(sze_t33_f),t33_idx_f(12,sze_t33_f))
  call contrib_t33_full(nO,nV,thresh,thresh_sf,sze_t3,t3,t3_idx,&
     sze_t33_f,t33_f,t33_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't33  ', sze_t33_f  , f_norm(t33_f  ,sze_t33_f  )
  
  ! T111
  call contrib_t111_full_nb(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx, &
     sze_t111_f)
  allocate(t111_f(sze_t111_f),t111_idx_f(6,sze_t111_f))
  call contrib_t111_full(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx, &
     sze_t111_f,t111_f,t111_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't111 ', sze_t111_f , f_norm(t111_f ,sze_t111_f )

  ! T112
  call contrib_t112_full_nb(nO,nV,thresh,thresh_sf,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx,&
     sze_t112_f)
  allocate(t112_f(sze_t112_f),t112_idx_f(8,sze_t112_f))
  call contrib_t112_full(nO,nV,thresh,thresh_sf,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx,&
     sze_t112_f,t112_f,t112_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't112 ', sze_t112_f , f_norm(t112_f ,sze_t112_f )

  ! T113
  call contrib_t113_full_nb(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t13,t13,t13_idx,&
     sze_t113_f)
  allocate(t113_f(sze_t113_f),t113_idx_f(10,sze_t113_f))
  call contrib_t113_full(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t13,t13,t13_idx,&
     sze_t113_f,t113_f,t113_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't113 ', sze_t113_f , f_norm(t113_f ,sze_t113_f )

  ! T122
  call contrib_t122_full_nb(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t22,t22,t22_idx,&
     sze_t122_f)
  allocate(t122_f(sze_t122_f),t122_idx_f(10,sze_t122_f))
  call contrib_t122_full(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t22,t22,t22_idx,&
     sze_t122_f,t122_f,t122_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't122 ', sze_t122_f , f_norm(t122_f ,sze_t122_f )

  ! T123
  call contrib_t123_full_nb(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t23,t23,t23_idx,&
     sze_t123_f)
  allocate(t123_f(sze_t123_f),t123_idx_f(12,sze_t123_f))
  call contrib_t123_full(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t23,t23,t23_idx,&
     sze_t123_f,t123_f,t123_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't123 ', sze_t123_f , f_norm(t123_f ,sze_t123_f )

  ! T222
  call contrib_t222_full_nb(nO,nV,thresh,thresh_sf,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx, &
     sze_t222_f)
  allocate(t222_f(sze_t222_f),t222_idx_f(12,sze_t222_f))
  call contrib_t222_full(nO,nV,thresh,thresh_sf,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx, &
     sze_t222_f,t222_f,t222_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't222 ', sze_t222_f , f_norm(t222_f ,sze_t222_f )
  
  ! T1111
  call contrib_t1111_full_nb(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx, &
     sze_t1111_f)
  allocate(t1111_f(sze_t1111_f),t1111_idx_f(8,sze_t1111_f))
  call contrib_t1111_full(nO,nV,thresh,thresh_sf,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx, &
     sze_t1111_f,t1111_f,t1111_idx_f)
  write(*,'(A6,I10,1pE12.4)') 't1111', sze_t1111_f, f_norm(t1111_f,sze_t1111_f)

  deallocate(t1,t1_idx)
  deallocate(t2,t2_idx)
  deallocate(t3,t3_idx)
  deallocate(t11,t11_idx)
  deallocate(t12,t12_idx)
  deallocate(t13,t13_idx)
  deallocate(t22,t22_idx)
  deallocate(t23,t23_idx)
  deallocate(t33,t33_idx)
  deallocate(t111,t111_idx)
  deallocate(t112,t112_idx)
  deallocate(t113,t113_idx)
  deallocate(t122,t122_idx)
  deallocate(t123,t123_idx)
  deallocate(t222,t222_idx)
  deallocate(t1111,t1111_idx)
  
  ! Sort
  call recursive_sort_idx(t2_f,t2_idx_f,sze_t2_f,4,1)
  call recursive_sort_idx(t3_f,t3_idx_f,sze_t3_f,6,1)
  call recursive_sort_idx(t11_f,t11_idx_f,sze_t11_f,4,1)
  call recursive_sort_idx(t12_f,t12_idx_f,sze_t12_f,6,1)
  call recursive_sort_idx(t13_f,t13_idx_f,sze_t13_f,8,1)
  call recursive_sort_idx(t22_f,t22_idx_f,sze_t22_f,8,1)
  call recursive_sort_idx(t23_f,t23_idx_f,sze_t23_f,10,1)
  call recursive_sort_idx(t33_f,t33_idx_f,sze_t33_f,12,1)
  call recursive_sort_idx(t111_f,t111_idx_f,sze_t111_f,6,1)
  call recursive_sort_idx(t112_f,t112_idx_f,sze_t112_f,8,1)
  call recursive_sort_idx(t113_f,t113_idx_f,sze_t113_f,10,1)
  call recursive_sort_idx(t122_f,t122_idx_f,sze_t122_f,10,1)
  call recursive_sort_idx(t123_f,t123_idx_f,sze_t123_f,12,1)
  call recursive_sort_idx(t222_f,t222_idx_f,sze_t222_f,12,1)
  call recursive_sort_idx(t1111_f,t1111_idx_f,sze_t1111_f,8,1)
  
  ! Remove the duplicate and accumulate
  call remove_duplicate_idx(t2_f,t2_idx_f,sze_t2_f,4)
  call remove_duplicate_idx(t3_f,t3_idx_f,sze_t3_f,6)
  call remove_duplicate_idx(t11_f,t11_idx_f,sze_t11_f,4)
  call remove_duplicate_idx(t12_f,t12_idx_f,sze_t12_f,6)
  call remove_duplicate_idx(t13_f,t13_idx_f,sze_t13_f,8)
  call remove_duplicate_idx(t22_f,t22_idx_f,sze_t22_f,8)
  call remove_duplicate_idx(t23_f,t23_idx_f,sze_t23_f,10)
  call remove_duplicate_idx(t33_f,t33_idx_f,sze_t33_f,12)
  call remove_duplicate_idx(t111_f,t111_idx_f,sze_t111_f,6)
  call remove_duplicate_idx(t112_f,t112_idx_f,sze_t112_f,8)
  call remove_duplicate_idx(t113_f,t113_idx_f,sze_t113_f,10)
  call remove_duplicate_idx(t122_f,t122_idx_f,sze_t122_f,10)
  call remove_duplicate_idx(t123_f,t123_idx_f,sze_t123_f,12)
  call remove_duplicate_idx(t222_f,t222_idx_f,sze_t222_f,12)
  call remove_duplicate_idx(t1111_f,t1111_idx_f,sze_t1111_f,8)
  
  print*,''
  print*,'After removing the duplicates:'
  write(*,'(A6,A10,A12)')     '     ', '  N'    , 'Norm' 
  write(*,'(A6,I10,1pE12.4)') 't2   ', sze_t2_f   , f_norm(t2_f   ,sze_t2_f   )
  write(*,'(A6,I10,1pE12.4)') 't3   ', sze_t3_f   , f_norm(t3_f   ,sze_t3_f   )
  write(*,'(A6,I10,1pE12.4)') 't11  ', sze_t11_f  , f_norm(t11_f  ,sze_t11_f  )
  write(*,'(A6,I10,1pE12.4)') 't12  ', sze_t12_f  , f_norm(t12_f  ,sze_t12_f  )
  write(*,'(A6,I10,1pE12.4)') 't13  ', sze_t13_f  , f_norm(t13_f  ,sze_t13_f  )
  write(*,'(A6,I10,1pE12.4)') 't22  ', sze_t22_f  , f_norm(t22_f  ,sze_t22_f  )
  write(*,'(A6,I10,1pE12.4)') 't23  ', sze_t23_f  , f_norm(t23_f  ,sze_t23_f  )
  write(*,'(A6,I10,1pE12.4)') 't33  ', sze_t33_f  , f_norm(t33_f  ,sze_t33_f  )
  write(*,'(A6,I10,1pE12.4)') 't111 ', sze_t111_f , f_norm(t111_f ,sze_t111_f )
  write(*,'(A6,I10,1pE12.4)') 't112 ', sze_t112_f , f_norm(t112_f ,sze_t112_f )
  write(*,'(A6,I10,1pE12.4)') 't113 ', sze_t113_f , f_norm(t113_f ,sze_t113_f )
  write(*,'(A6,I10,1pE12.4)') 't122 ', sze_t122_f , f_norm(t122_f ,sze_t122_f )
  write(*,'(A6,I10,1pE12.4)') 't122 ', sze_t123_f , f_norm(t123_f ,sze_t123_f )
  write(*,'(A6,I10,1pE12.4)') 't222 ', sze_t222_f , f_norm(t222_f ,sze_t222_f )
  write(*,'(A6,I10,1pE12.4)') 't1111', sze_t1111_f, f_norm(t1111_f,sze_t1111_f)
  
  double precision, allocatable :: tmp_c2(:), tmp_c3(:), tmp_c4(:)
  double precision, allocatable :: tmp_c5(:), tmp_c6(:)
  
  integer, allocatable :: tmp_c2_idx(:,:), tmp_c3_idx(:,:), tmp_c4_idx(:,:)
  integer, allocatable :: tmp_c5_idx(:,:),tmp_c6_idx(:,:)
  
  ! C2
  new_sze_c2 = sze_c2 + sze_t2_f + sze_t11_f
  allocate(tmp_c2(new_sze_c2),tmp_c2_idx(4,new_sze_c2))

  do i = 1, sze_c2
    tmp_c2(i) = c2(i)
    tmp_c2_idx(:,i) = c2_idx(:,i)
  enddo
  ! t2
  k = sze_c2
  do i = 1, sze_t2_f
    tmp_c2(k+i) = t2_f(i)
    tmp_c2_idx(:,k+i) = t2_idx_f(:,i)
  enddo
  k = k + sze_t2_f
  ! t11
  do i = 1, sze_t11_f
    tmp_c2(k+i) = t11_f(i)
    tmp_c2_idx(:,k+i) = t11_idx_f(:,i)
  enddo
  
  sze_c2 = new_sze_c2

  deallocate(c2,c2_idx)
  allocate(c2(sze_c2),c2_idx(4,sze_c2))
  
  c2 = tmp_c2
  c2_idx = tmp_c2_idx

  deallocate(tmp_c2,tmp_c2_idx)

  ! C3
  new_sze_c3 = sze_c3 + sze_t12_f + sze_t111_f + sze_t3_f
  allocate(tmp_c3(new_sze_c3),tmp_c3_idx(6,new_sze_c3))

  do i = 1, sze_c3
    tmp_c3(i) = c3(i)
    tmp_c3_idx(:,i) = c3_idx(:,i)
  enddo
  k = sze_c3
  ! t12
  do i = 1, sze_t12_f
    tmp_c3(k+i) = t12_f(i)
    tmp_c3_idx(:,k+i) = t12_idx_f(:,i)
  enddo
  k = k + sze_t12_f
  ! t111
  do i = 1, sze_t111_f
    tmp_c3(k+i) = t111_f(i)
    tmp_c3_idx(:,k+i) = t111_idx_f(:,i)
  enddo
  k = k + sze_t111_f
  ! t3
  do i = 1, sze_t3_f
    tmp_c3(k+i) = t3_f(i)
    tmp_c3_idx(:,k+i) = t3_idx_f(:,i)
  enddo

  sze_c3 = new_sze_c3

  deallocate(c3,c3_idx)
  allocate(c3(sze_c3),c3_idx(6,sze_c3))
  
  c3 = tmp_c3
  c3_idx = tmp_c3_idx

  deallocate(tmp_c3,tmp_c3_idx)

  ! C4
  new_sze_c4 = sze_c4 + sze_t22_f + sze_t13_f + sze_t112_f + sze_t1111_f
  allocate(tmp_c4(new_sze_c4),tmp_c4_idx(8,new_sze_c4))
  
  do i = 1, sze_c4
    tmp_c4(i) = c4(i)
    tmp_c4_idx(:,i) = c4_idx(:,i)
  enddo
  k = sze_c4
  ! t22
  do i = 1, sze_t22_f
    tmp_c4(k+i) = t22_f(i)
    tmp_c4_idx(:,k+i) = t22_idx_f(:,i)
  enddo
  k = k + sze_t22_f
  ! t13
  do i = 1, sze_t13_f
    tmp_c4(k+i) = t13_f(i)
    tmp_c4_idx(:,k+i) = t13_idx_f(:,i)
  enddo
  k = k + sze_t13_f
  ! t112
  do i = 1, sze_t112_f
    tmp_c4(k+i) = t112_f(i)
    tmp_c4_idx(:,k+i) = t112_idx_f(:,i)
  enddo
  k = k + sze_t112_f
  ! t1111
  do i = 1, sze_t1111_f
    tmp_c4(k+i) = t1111_f(i)
    tmp_c4_idx(:,k+i) = t1111_idx_f(:,i)
  enddo

  sze_c4 = new_sze_c4

  deallocate(c4,c4_idx)
  allocate(c4(sze_c4),c4_idx(8,sze_c4))
  
  c4 = tmp_c4
  c4_idx = tmp_c4_idx

  deallocate(tmp_c4,tmp_c4_idx)

  ! C5
  new_sze_c5 = sze_c5 + sze_t23_f + sze_t122_f + sze_t113_f

  allocate(tmp_c5(new_sze_c5),tmp_c5_idx(10,new_sze_c5))

  do i = 1, sze_c5
    tmp_c5(i) = c5(i)
    tmp_c5_idx(:,i) = c5_idx(:,i)
  enddo
  k = sze_c5
  ! t23
  do i = 1, sze_t23_f
    tmp_c5(k+i) = t23_f(i)
    tmp_c5_idx(:,k+i) = t23_idx_f(:,i)
  enddo
  k = k + sze_t23_f
  ! t122
  do i = 1, sze_t122_f
    tmp_c5(k+i) = t122_f(i)
    tmp_c5_idx(:,k+i) = t122_idx_f(:,i)
  enddo
  k = k + sze_t122_f
  ! t113
  do i = 1, sze_t113_f
    tmp_c5(k+i) =  t113_f(i)
    tmp_c5_idx(:,k+i) = t113_idx_f(:,i)
  enddo

  sze_c5 = new_sze_c5

  deallocate(c5,c5_idx)
  allocate(c5(sze_c5),c5_idx(10,sze_c5))

  c5 = tmp_c5
  c5_idx = tmp_c5_idx

  deallocate(tmp_c5,tmp_c5_idx)
    
  ! C6
  new_sze_c6 = sze_c6 + sze_t222_f + sze_t33_f + sze_t123_f

  allocate(tmp_c6(new_sze_c6),tmp_c6_idx(12,new_sze_c6))

  do i = 1, sze_c6
    tmp_c6(i) = c6(i)
    tmp_c6_idx(:,i) = c6_idx(:,i)
  enddo
  k = sze_c6
  ! t222
  do i = 1, sze_t222_f
    tmp_c6(k+i) = t222_f(i)
    tmp_c6_idx(:,k+i) = t222_idx_f(:,i)
  enddo
  k = k + sze_t222_f
  ! t33
  do i = 1, sze_t33_f
    tmp_c6(k+i) = t33_f(i)
    tmp_c6_idx(:,k+i) = t33_idx_f(:,i)
  enddo
  k = k + sze_t33_f
  ! t123
  do i = 1, sze_t123_f
    tmp_c6(k+i) = t123_f(i)
    tmp_c6_idx(:,k+i) = t123_idx_f(:,i)
  enddo

  sze_c6 = new_sze_c6

  deallocate(c6,c6_idx)
  allocate(c6(sze_c6),c6_idx(12,sze_c6))

  do i = 1, sze_c6
    c6(i) = tmp_c6(i)
    c6_idx(:,i) = tmp_c6_idx(:,i)
  enddo

  deallocate(tmp_c6,tmp_c6_idx)

  deallocate(t2_f,t2_idx_f)
  deallocate(t3_f,t3_idx_f)
  deallocate(t11_f,t11_idx_f)
  deallocate(t12_f,t12_idx_f)
  deallocate(t13_f,t13_idx_f)
  deallocate(t22_f,t22_idx_f)
  deallocate(t23_f,t23_idx_f)
  deallocate(t33_f,t33_idx_f)
  deallocate(t111_f,t111_idx_f)
  deallocate(t112_f,t112_idx_f)
  deallocate(t113_f,t113_idx_f)
  deallocate(t122_f,t122_idx_f)
  deallocate(t123_f,t123_idx_f)
  deallocate(t222_f,t222_idx_f)
  deallocate(t1111_f,t1111_idx_f)
  
  call recursive_sort_idx(c2,c2_idx,sze_c2,4,1)
  call recursive_sort_idx(c3,c3_idx,sze_c3,6,1)
  call recursive_sort_idx(c4,c4_idx,sze_c4,8,1)
  call recursive_sort_idx(c5,c5_idx,sze_c5,10,1)
  call recursive_sort_idx(c6,c6_idx,sze_c6,12,1)

  call remove_duplicate_idx(c2,c2_idx,sze_c2,4)
  call remove_duplicate_idx(c3,c3_idx,sze_c3,6)
  call remove_duplicate_idx(c4,c4_idx,sze_c4,8)
  call remove_duplicate_idx(c5,c5_idx,sze_c5,10)
  call remove_duplicate_idx(c6,c6_idx,sze_c6,12)
  
  print*,''
  write(*,'(A6,I10,1pE12.4)') 'C1   ', sze_c1, f_norm(c1,sze_c1)
  write(*,'(A6,I10,1pE12.4)') 'C2   ', sze_c2, f_norm(c2,sze_c2)
  write(*,'(A6,I10,1pE12.4)') 'C3   ', sze_c3, f_norm(c3,sze_c3)
  write(*,'(A6,I10,1pE12.4)') 'C4   ', sze_c4, f_norm(c4,sze_c4)
  write(*,'(A6,I10,1pE12.4)') 'C5   ', sze_c5, f_norm(c5,sze_c5)
  write(*,'(A6,I10,1pE12.4)') 'C6   ', sze_c6, f_norm(c6,sze_c6)

  deallocate(c2_det,c2_coef)
  deallocate(c3_det,c3_coef)
  deallocate(c4_det,c4_coef)
  deallocate(c5_det,c5_coef)
  deallocate(c6_det,c6_coef)
  
  allocate(c2_det(N_int,2,sze_c2),c2_coef(sze_c2))
  allocate(c3_det(N_int,2,sze_c3),c3_coef(sze_c3))
  allocate(c4_det(N_int,2,sze_c4),c4_coef(sze_c4))
  allocate(c5_det(N_int,2,sze_c5),c5_coef(sze_c5))
  allocate(c6_det(N_int,2,sze_c6),c6_coef(sze_c6))
  
  call build_det_t(c2,c2_idx,sze_c2,4,c2_det,c2_coef)
  call build_det_t(c3,c3_idx,sze_c3,6,c3_det,c3_coef)
  call build_det_t(c4,c4_idx,sze_c4,8,c4_det,c4_coef)
  call build_det_t(c5,c5_idx,sze_c5,10,c5_det,c5_coef)
  call build_det_t(c6,c6_idx,sze_c6,12,c6_det,c6_coef)

  deallocate(c1,c1_idx)
  deallocate(c2,c2_idx)
  deallocate(c3,c3_idx)
  deallocate(c4,c4_idx)
  deallocate(c5,c5_idx)
  deallocate(c6,c6_idx)

  sze_cc = 1 + sze_c1 + sze_c2 + sze_c3 + sze_c4 + sze_c5 + sze_c6

  allocate(psi_det_cc(N_int,2,sze_cc),psi_coef_cc(sze_cc))

  ! Ref
  psi_coef_cc(1) = 1d0
  psi_det_cc(:,:,1) = psi_det(:,:,cc_ref)

  ! C1
  k = 1
  do i = 1, sze_c1
    psi_coef_cc(k+i) = c1_coef(i)
    psi_det_cc(:,:,k+i) = c1_det(:,:,i)
  enddo

  ! C2
  k = k + sze_c1
  do i = 1, sze_c2
    psi_coef_cc(k+i) = c2_coef(i)
    psi_det_cc(:,:,k+i) = c2_det(:,:,i)
  enddo

  ! C3
  k = k + sze_c2
  do i = 1, sze_c3
    psi_coef_cc(k+i) = c3_coef(i)
    psi_det_cc(:,:,k+i) = c3_det(:,:,i)
  enddo
  
  ! C4
  k = k + sze_c3
  do i = 1, sze_c4
    psi_coef_cc(k+i) = c4_coef(i)
    psi_det_cc(:,:,k+i) = c4_det(:,:,i)
  enddo

  ! C5
  k = k + sze_c4
  do i = 1, sze_c5
    psi_coef_cc(k+i) = c5_coef(i)
    psi_det_cc(:,:,k+i) = c5_det(:,:,i)
  enddo

  ! C6
  k = k + sze_c5
  do i = 1, sze_c6
    psi_coef_cc(k+i) = c6_coef(i)
    psi_det_cc(:,:,k+i) = c6_det(:,:,i)
  enddo
  
  deallocate(c2_det,c2_coef)
  deallocate(c3_det,c3_coef)
  deallocate(c4_det,c4_coef)
  deallocate(c5_det,c5_coef)
  deallocate(c6_det,c6_coef)

  write(*,'(A6,I10,1pE12.4)') ' Psi  ', sze_cc, f_norm(psi_coef_cc, sze_cc)

  ! Phase
  norm = 1d0
  det(:,:) = psi_det_cc(:,:,1)
  do i = 2, sze_cc
    call get_phase_general(det,psi_det_cc(1,1,i),phase,degree,N_int)
    psi_coef_cc(i) = psi_coef_cc(i) * phase
    norm = norm + psi_coef_cc(i)**2
  enddo

  ! E
  call i_H_psi(psi_det_cc(1,1,1),psi_det_cc,psi_coef_cc,N_int,sze_cc,sze_cc,1,energy)
  print*,''
  print*,'<0|H|Psi> =',energy+nuclear_repulsion

  ! Normalization
  norm = 1d0/dsqrt(norm)
  do i = 1, sze_cc
    psi_coef_cc(i) = psi_coef_cc(i) * norm
  enddo
  
  ! Sort by ci coef
  call sort_by_coef_det(psi_coef_cc,psi_det_cc,sze_cc,N_int)

  ! Overlap
  !call overlap_wf_safe(sze_cc,psi_det_cc,psi_coef_cc)
  !call overlap_fast(psi_det,psi_coef,N_states,N_det,psi_det_cc,psi_coef_cc,1,sze_cc)

  ! Save wf
  call fill_H_apply_buffer_no_selection(sze_cc,psi_det_cc,N_int,0)
  call copy_H_apply_buffer_to_wf
  N_det = sze_cc
  psi_coef(:,1) = 0d0
  psi_det(:,:,:) = 0
  psi_coef(1:N_det,1) = psi_coef_cc
  psi_det(:,:,1:N_det) = psi_det_cc
  !call save_wf_cc(psi_det_cc,psi_coef_cc,sze_cc)
  TOUCH psi_det psi_coef N_det
  call save_wavefunction()

  if (.True.) then
    print*,''
    print*,'<Psi|H|Psi>/<Psi|Psi>   =',psi_energy(1)+nuclear_repulsion
    print*,'<Psi|S^2|Psi>/<Psi|Psi> =',psi_s2(1)
    print*,''
  endif
  
  deallocate(psi_det_cc,psi_coef_cc)
  
end
#+end_src

** Reorder t_idx
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine reorder_t_idx(t,t_idx,sze_t,n_idx)
 
  implicit none

  BEGIN_DOC
  ! Order the indexes of each t
  END_DOC

  integer, intent(in) :: sze_t, n_idx
  integer, intent(inout) :: t_idx(n_idx,sze_t)
  double precision, intent(inout) :: t(sze_t)
  
  integer :: i,j,k,o,s
  integer, allocatable :: tmp_t_idx(:,:), p_f(:), idx(:), p_i(:), iorder(:)
  double precision, allocatable :: tmp_t(:)
  double precision :: sign
  integer :: dist, n_cross, n_pairs

  do i = 1, sze_t
    sign = 1d0
    call reorder_t_idx_rec(t_idx(1,i),n_idx/2,sign,1)
    call reorder_t_idx_rec(t_idx(n_idx/2+1,i),n_idx/2,sign,1)
    t(i) = t(i) * sign
  enddo

  return
  
  allocate(tmp_t(sze_t), tmp_t_idx(n_idx,sze_t),idx(n_idx/2))
  allocate(iorder(n_idx/2))
  
  do i = 1, sze_t
    ! Sort of the idx
    dist = 0
    n_cross = 0
    ! Loop over occ and vir spin orbitals
    do o = 1, 2
      if (o == 2) then
         s = n_idx/2
      else
         s = 0
      endif
         
      do j = 1, n_idx/2
        idx(j) = t_idx(s+j,i)
        iorder(j) = j
      enddo
      call isort(idx,iorder,n_idx/2)

      ! "Distance"
      n_pairs = 0
      do j = 1, n_idx/2
        dist = dist + abs(iorder(j) - j)
        if (abs(iorder(j) - j) /= 0) then
          n_pairs = n_pairs + 1
        endif
      enddo
      
      do j = 1, n_idx/2
        tmp_t_idx(s+j,i) = idx(j)
      enddo
    enddo
    ! Final sign
    !print*,'1',t_idx(:,i)
    !print*,'2',tmp_t_idx(:,i)
    sign = dble((-1)**(dist/2))
    !print*,dist,sign
    tmp_t(i) = t(i) * sign
  enddo

  ! Apply changes
  do i = 1, sze_t
    t(i) = tmp_t(i)
    t_idx(:,i) = tmp_t_idx(:,i)
    !print*,i,t_idx(:,i)
  enddo
    
  deallocate(tmp_t,tmp_t_idx,idx)
  
end

recursive subroutine reorder_t_idx_rec(t_idx,nb_idx,sign,idx)

  implicit none

  integer, intent(in) :: nb_idx,idx
  integer, intent(inout) :: t_idx(nb_idx)
  double precision, intent(inout) :: sign
  integer :: tmp,i

  if (idx < nb_idx) then
    if (t_idx(idx) > t_idx(idx+1)) then
      tmp = t_idx(idx)
      t_idx(idx) = t_idx(idx+1)
      t_idx(idx+1) = tmp
      sign = - sign
      if (idx > 1) then
        i = idx - 1
      else
        i = idx + 1
      endif
    else
      i = idx + 1
    endif
    call reorder_t_idx_rec(t_idx,nb_idx,sign,i)
  else
    return
  endif
 
end
#+end_src

** Build det
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine build_det_t(t,t_idx,sze_t,n_idx,psi_det_t,psi_coef_t)

  implicit none

  integer, intent(in) :: sze_t, n_idx, t_idx(n_idx,sze_t)
  double precision, intent(in) :: t(sze_t)

  integer(bit_kind), intent(out) :: psi_det_t(N_int,2,sze_t)
  double precision, intent(out) :: psi_coef_t(sze_t)

  integer :: i,j,k
  integer :: s,h,p
  logical :: ok
  integer(bit_kind) :: det(N_int,2),res(N_int,2)  
  
  do i = 1, sze_t
    det(:,:) = psi_det(:,:,cc_ref)
    !print*,t_idx(:,i)
    
    ! Holes
    do j = 1, n_idx/2
      h = t_idx(j,i)
      if (h > cc_nOa) then
        h = h - cc_nOa
        s = 2
      else
        s = 1
      endif
      if (h > cc_nOab .or. h <= 0) then
         print*,i,h
         print*,t_idx(:,i)
         call abort
      endif
      h = cc_list_occ_spin(h,s)
      !call print_det(det,N_int)
      call apply_hole(det,s,h,res,ok,N_int)
      if (.not. ok) then
        print*,'big problem h'
        print*,t_idx(:,i)
        print*,t_idx(j,i),s,h
        call abort
      endif
      det = res
    enddo

    ! Particles
    do j = n_idx/2+1, n_idx
      p = t_idx(j,i)
      if (p > cc_nVa) then
        p = p - cc_nVa
        s = 2
      else
        s = 1
      endif
      p = cc_list_vir_spin(p,s)
      !p = p + cc_nO_S(s)
      !p = p + n_core_orb
      call apply_particle(det,s,p,res,ok,N_int)
      if (.not. ok) then
        print*,'big problem p'
        print*,t_idx(:,i)
        print*,t_idx(j,i),s,p
        call abort
      endif
      det = res
    enddo
    psi_det_t(:,:,i) = det(:,:)
    psi_coef_t(i) = t(i)
    !call print_det(det,N_int)
    !print*,psi_coef_t(i),psi_det_t(1,1,i),psi_det_t(1,2,i)
  enddo

end
#+end_src

** Det way
*** Sort det
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
!subroutine sort_det(psi_det_t,psi_coef_t,sze)
!
!  implicit none
!
!  integer, intent(in) :: sze
!  integer(bit_kind), intent(inout) :: psi_det_t(N_int,2,sze)
!  double precision, intent(inout) :: psi_coef_t(sze)
!
!  integer(bit_kind), allocatable :: tmp_psi_det(:,:,:), tmp_psi_det_a(:,:), tmp_det_b(:,:)
!  double precision, allocatable :: tmp_psi_coef(:), tmp_coef(:)
!  integer, allocatable :: iorder(:), border(:), n_da(:)
!  integer(bit_kind) :: da(1)
!
!  integer :: i,j,k,l,o, n_da_unique, degree
!  
!  if (N_int /= 1) then
!    print*,'N_int /= 1, abort'
!    call abort
!  endif
!
!  allocate(tmp_psi_coef(sze),tmp_psi_det(1,2,sze))
!  
!  allocate(iorder(sze),tmp_psi_det_a(N_int,sze))
!
!  do i = 1, sze
!    tmp_psi_det_a(1,i) = psi_det_t(1,1,i)
!    iorder(i) = i
!  enddo
!
!  call i8sort(tmp_psi_det_a,iorder,sze)
!
!  do i = 1, sze
!    tmp_psi_coef(i) = psi_coef_t(iorder(i))
!    tmp_psi_det(1,1,i) = psi_det_t(1,1,iorder(i))
!    tmp_psi_det(1,2,i) = psi_det_t(1,2,iorder(i))
!  enddo
!  do i = 1, sze
!    psi_coef_t(i) = tmp_psi_coef(i)    
!    psi_det_t(1,1,i) = tmp_psi_det(1,1,i)
!    psi_det_t(1,2,i) = tmp_psi_det(1,2,i)
!  enddo
!  tmp_psi_det = 0
!  tmp_psi_coef = 0d0
!
!  allocate(n_da(sze))
!  n_da = 0
!  n_da_unique = 1
!  n_da(1) = 1 
!  da = tmp_psi_det_a(1,1)
!  do i = 2, sze
!    call get_excitation_degree_spin(tmp_psi_det_a(1,i),da,degree,N_int)
!    if (degree /= 0) then
!      da = tmp_psi_det_a(1,i)
!      n_da_unique = n_da_unique + 1
!      n_da(n_da_unique) = n_da(n_da_unique) + 1
!    else
!      n_da(n_da_unique) = n_da(n_da_unique) + 1
!    endif
!  enddo
!
!  k = 1
!  l = 1
!  do i = 1, n_da_unique
!    allocate(tmp_det_b(1,n_da(i)),border(n_da(i)),tmp_coef(n_da(i)))
!    do j = 1, n_da(i)
!      tmp_det_b(1,j) = psi_det_t(1,2,k)
!      !print*, tmp_det_b(1,j)
!      tmp_coef(j) = psi_coef_t(k)
!      border(j) = j
!      k = k + 1
!    enddo
!
!    call i8sort(tmp_det_b,border,n_da(i))
!    !print*,'b',tmp_det_b
!    !print*,''
!
!    ! no need of tmp arrays
!    do j = 1, n_da(i)
!      psi_det_t(1,2,l) = tmp_det_b(1,j)
!      psi_coef_t(l) = tmp_coef(border(j))
!      l = l + 1
!    enddo
!    deallocate(tmp_det_b,border,tmp_coef)
!  enddo
!
!  ! Check
!  !print*,''
!  !do i = 1, sze
!  !  print*,psi_coef_t(i),psi_det_t(1,1,i),psi_det_t(1,2,i)
!  !  !call print_det(psi_det_t(1,1,i),N_int)
!  !enddo
!  
!end
#+end_src

*** Remove duplicate det
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine remove_duplicate_det(psi_det_t,psi_coef_t,sze_t)

  implicit none

  integer, intent(inout) :: sze_t
  integer(bit_kind) , intent(inout) :: psi_det_t(N_int,2,sze_t)
  double precision, intent(inout) :: psi_coef_t(sze_t)

  integer(bit_kind), allocatable :: tmp_det(:,:,:)
  double precision, allocatable :: tmp_coef(:)
  integer(bit_kind) :: det(N_int,2)

  integer :: i,j,k,l,idx,new_sze_t
  logical :: is_eq

  allocate(tmp_det(N_int,2,sze_t),tmp_coef(sze_t))

  idx = 1
  tmp_det(:,:,idx) = psi_det_t(:,:,1)
  tmp_coef(idx) = psi_coef_t(1)
  do i = 2, sze_t
    is_eq = .True.
    do j = 1, 2
      do k = 1, N_int
        if (tmp_det(k,j,idx) /= psi_det_t(k,j,i)) then
           is_eq = .False.
        endif
      enddo
    enddo
    if (is_eq) then
       tmp_coef(idx) = tmp_coef(idx) + psi_coef_t(i)
    else
       idx = idx + 1
       tmp_coef(idx) = psi_coef_t(i)
       tmp_det(:,:,idx) = psi_det_t(:,:,i)
    endif
  enddo

  new_sze_t = idx

  do i = 1, new_sze_t
    psi_coef_t(i) = tmp_coef(i)
    psi_det_t(:,:,i) = tmp_det(:,:,i)
  enddo
  do i = new_sze_t+1, sze_t
    psi_coef_t(i) = 0d0
    psi_det_t(:,:,i) = 0
  enddo

  sze_t = new_sze_t
  
end
#+end_src

** idx way
*** Recursive sort t_idx
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
recursive subroutine recursive_sort_idx(t,t_idx,sze,n_idx,idx)

  implicit none

  integer, intent(in) :: sze,n_idx,idx
  integer, intent(inout) :: t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer :: i,j,k,l,val,nb_u
  integer, allocatable :: tmp(:),tmp_idx(:,:),iorder(:),nu(:),pu(:)
  double precision, allocatable :: tmp_t(:)

  if (sze == 0) return

  if (idx < n_idx) then

    ! Sort
    call multiple_idx_sort(t,t_idx,sze,n_idx,idx)

    allocate(pu(sze),nu(sze))
    ! Unique, nb and position
    call search_unique_idx(t_idx,sze,n_idx,idx,nb_u,nu,pu)

    do i = 1, nb_u
      call recursive_sort_idx(t(pu(i)),t_idx(1,pu(i)),nu(i),n_idx,idx+1)
    enddo
    deallocate(pu,nu)

  else

    ! Sort
    call multiple_idx_sort(t,t_idx,sze,n_idx,idx)

  endif

end
#+end_src

*** sort
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine multiple_idx_sort(t,t_idx,sze,n_idx,idx)

  implicit none

  integer, intent(in) :: sze,n_idx,idx
  integer, intent(inout) :: t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer :: i,j,k,l,val
  integer, allocatable :: tmp(:),tmp_idx(:,:),iorder(:)
  double precision, allocatable :: tmp_t(:)

  ! Sort
  allocate(tmp(sze),tmp_idx(n_idx,sze),tmp_t(sze),iorder(sze))

  do i = 1, sze
    tmp(i) = t_idx(idx,i)
    tmp_idx(:,i) = t_idx(:,i)
    tmp_t(i) = t(i)
    iorder(i) = i
  enddo

  call isort(tmp,iorder,sze)

  do i = 1, sze
    t_idx(:,i) = tmp_idx(:,iorder(i))
    t(i) = tmp_t(iorder(i))
  enddo
  
  deallocate(tmp,tmp_idx,tmp_t,iorder)
end
#+end_src

*** Unique
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine search_unique_idx(t_idx,sze,n_idx,idx,nb_u,nu,pu)

  implicit none

  integer, intent(in) :: sze,n_idx,idx
  integer, intent(in) :: t_idx(n_idx,sze)

  integer, intent(out) :: nb_u, nu(sze), pu(sze)

  integer :: i,j,k,l,val
  double precision, allocatable :: tmp_t(:)
  
  ! Unique, nb and position
  k = 1
  pu = 0 ! starting position
  nu = 0 ! nb
  pu(1) = 1
  nu(1) = 1
  val = t_idx(idx,1) 
  do i = 2, sze
    if (val /= t_idx(idx,i)) then
      k = k + 1
      pu(k) = i
      nu(k) = nu(k) + 1
      val = t_idx(idx,i)
    else
      nu(k) = nu(k) + 1
    endif
  enddo

  nb_u = k

end
#+end_src

*** Remove duplicate
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine remove_duplicate_idx(t,t_idx,sze,n_idx)

  implicit none

  integer, intent(in) :: n_idx
  integer, intent(inout) :: sze,t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer :: new_sze
  integer :: i,j,k,l
  integer, allocatable :: idx(:), tmp_idx(:,:)
  double precision, allocatable :: tmp_coef(:)
  logical :: is_eq

  new_sze = 0
  if (sze == 0) return
  
  allocate(idx(n_idx),tmp_idx(n_idx,sze),tmp_coef(sze))

  ! Init
  tmp_idx = 0
  tmp_coef = 0d0

  k = 1
  idx(:) = t_idx(:,1)
  tmp_idx(:,1) = idx(:)
  tmp_coef(1) = t(1)
  
  do i = 2, sze

    !print*,''
    !print*,idx(:)
    !print*,t_idx(:,i)
    ! Same indexes ?
    is_eq = .True.
    do j = 1, n_idx
      if (idx(j) /= t_idx(j,i)) then
        is_eq = .False.
        exit
      endif
    enddo
    !print*,is_eq
    
    ! Accumulate the duplicates
    if (is_eq) then
      tmp_coef(k) = tmp_coef(k) + t(i)
    else
      k = k + 1
      tmp_coef(k) = t(i)
      idx(:) = t_idx(:,i)
      tmp_idx(:,k) = idx(:)
    endif
    
  enddo

  new_sze = k

  ! Copy
  do i = 1, new_sze
    t(i) = tmp_coef(i)
    t_idx(:,i) = tmp_idx(:,i)
  enddo

  ! Nullify the remaining elements
  do i = new_sze+1, sze
    t(i) = 0d0
    t_idx(:,i) = 0
  enddo

  sze = new_sze

  deallocate(idx,tmp_idx,tmp_coef)

end
#+end_src

** Sort by coef
*** idx
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine sort_by_coef_idx(t,t_idx,sze,n_idx)

  implicit none

  integer, intent(in) :: sze,n_idx
  integer, intent(inout) :: t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer :: i,j,k,l,val
  integer, allocatable :: tmp_idx(:,:),iorder(:)
  double precision, allocatable :: tmp_t(:), tmp(:)

  if (sze == 0) return
  
  ! Sort
  allocate(tmp(sze),tmp_idx(n_idx,sze),tmp_t(sze),iorder(sze))

  do i = 1, sze
    tmp(i) = -dabs(t(i))
    tmp_idx(:,i) = t_idx(:,i)
    tmp_t(i) = t(i)
    iorder(i) = i
  enddo

  call dsort(tmp,iorder,sze)

  do i = 1, sze
    !print*,tmp(i)
    t_idx(:,i) = tmp_idx(:,iorder(i))
    t(i) = tmp_t(iorder(i))
  enddo
  
  deallocate(tmp,tmp_idx,tmp_t,iorder)
end
#+end_src

*** det
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine sort_by_coef_det(psi_coef_t,psi_det_t,sze,Nint)

  use bitmasks
  
  implicit none

  integer, intent(in) :: sze,Nint
  integer(bit_kind), intent(inout) :: psi_det_t(Nint,2,sze)
  double precision, intent(inout) :: psi_coef_t(sze)

  integer :: i,j,k,l,val
  integer(bit_kind), allocatable :: tmp_det(:,:,:)
  integer, allocatable :: iorder(:)
  double precision, allocatable :: tmp_coef(:), tmp(:)

  ! Sort
  allocate(tmp(sze),tmp_det(Nint,2,sze),tmp_coef(sze),iorder(sze))

  do i = 1, sze
    tmp(i) = -dabs(psi_coef_t(i))
    tmp_det(:,:,i) = psi_det_t(:,:,i)
    tmp_coef(i) = psi_coef_t(i)
    iorder(i) = i
  enddo

  call dsort(tmp,iorder,sze)

  do i = 1, sze
    !print*,tmp(i)
    psi_det_t(:,:,i) = tmp_det(:,:,iorder(i))
    psi_coef_t(i) = tmp_coef(iorder(i))
  enddo
  
  deallocate(tmp,tmp_det,tmp_coef,iorder)
end
#+end_src

** Norm
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
double precision function f_norm(v,sze)

  implicit none

  integer, intent(in) :: sze
  double precision, intent(in) :: v(sze)
  integer :: i

  f_norm = 0d0
  
  do i = 1, sze
    f_norm = f_norm + v(i)**2
  enddo

  f_norm = dsqrt(f_norm)

end
#+end_src


** T1
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t1_nb(nO,nV,thresh,t1_cc,sze_t1)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV
  double precision, intent(in)    :: thresh, t1_cc(nO,nV)

  ! out
  integer, intent(out)          :: sze_t1

  integer :: i,a,idx

  ! t1
  idx = 0
  do a = 1, nV
    do i = 1, nO
      if (dabs(t1_cc(i,a)) >= thresh) then
        if (i > cc_nOa .and. a <= cc_nVa) cycle
        if (i <= cc_nOa .and. a > cc_nVa) cycle
        idx = idx + 1
      endif
    enddo
  enddo

  sze_t1 = idx

end

subroutine contrib_t1(nO,nV,thresh,t1_cc,sze_t1,t1,t1_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1
  double precision, intent(in)    :: thresh,t1_cc(nO,nV)

  ! out
  double precision, intent(out)   :: t1(sze_t1)
  integer, intent(out)            :: t1_idx(2,sze_t1)
  
  integer :: i,a,idx
  double precision :: thresh_t1
  
  idx = 1
  do a = 1, nV
    do i = 1, nO
      if (dabs(t1_cc(i,a)) >= thresh) then
        if (i > cc_nOa .and. a <= cc_nVa) cycle
        if (i <= cc_nOa .and. a > cc_nVa) cycle
        t1(idx) = t1_cc(i,a)
        t1_idx(1,idx) = i
        t1_idx(2,idx) = a
        idx = idx + 1
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t1,t1_idx,sze_t1,2)

end  
#+end_src

** T2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t2_nb(nO,nV,thresh,t2_cc,sze_t2)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV
  double precision, intent(in)    :: thresh, t2_cc(nO,nO,nV,nV)

  ! out
  integer, intent(out)          :: sze_t2

  integer :: i,j,a,b,idx
  
  idx = 0
  do b = 1, nV
    do a = b+1, nV
      do j = 1, nO
        do i = j+1, nO
          if (dabs(t2_cc(i,j,a,b)) >= thresh) then
            if (i <= cc_nOa .and. j <= cc_nOa .and. (a > cc_nVa .or. b > cc_nVa)) cycle
            if (i > cc_nOa .and. j > cc_nOa .and. (a <= cc_nVa .or. b <= cc_nVa)) cycle
            if (a > cc_nVa .and. b > cc_nVa .and. (i <= cc_nOa .or. j <= cc_nOa)) cycle
            if (a <= cc_nVa .and. b <= cc_nVa .and. (i > cc_nOa .or. j > cc_nOa)) cycle
            idx = idx + 1
          endif
        enddo
      enddo
    enddo
  enddo

  sze_t2 = idx

end

subroutine contrib_t2(nO,nV,thresh,t2_cc,sze_t2,t2,t2_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2
  double precision, intent(in)    :: thresh,t2_cc(nO,nO,nV,nV)

  ! out
  double precision, intent(out)   :: t2(sze_t2)
  integer, intent(out)            :: t2_idx(4,sze_t2)
  
  integer :: i,j,a,b,idx
  double precision :: tmp
  
  idx = 1
  do b = 1, nV
    do a = b+1, nV
      do j = 1, nO
        do i = j+1, nO
          tmp = t2_cc(i,j,a,b)
          if (dabs(tmp) >= thresh) then
             
            if (i <= cc_nOa .and. j <= cc_nOa .and. (a > cc_nVa .or. b > cc_nVa)) cycle
            if (i > cc_nOa .and. j > cc_nOa .and. (a <= cc_nVa .or. b <= cc_nVa)) cycle
            if (a > cc_nVa .and. b > cc_nVa .and. (i <= cc_nOa .or. j <= cc_nOa)) cycle
            if (a <= cc_nVa .and. b <= cc_nVa .and. (i > cc_nOa .or. j > cc_nOa)) cycle
            t2(idx) = tmp
            t2_idx(1,idx) = i
            t2_idx(2,idx) = j
            t2_idx(3,idx) = a
            t2_idx(4,idx) = b
            idx = idx + 1
          endif
        enddo
      enddo
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t2,t2_idx,sze_t2,4)
  
  ! Reorder the index of each t
  call reorder_t_idx(t2,t2_idx,sze_t2,4)

end  
#+end_src

** T2 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t2_full_nb(nO,nV,thresh1,thresh2,t2_cc,sze_t2)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV
  double precision, intent(in)    :: thresh1, thresh2, t2_cc(nO,nO,nV,nV)

  ! out
  integer, intent(out)            :: sze_t2

  integer :: i,j,a,b,idx,tmp_idx(4)
  integer(bit_kind) :: det(N_int,2)
  double precision :: coef(1), tmp, acc
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  acc = 0d0
  idx = 0
  do b = 1, nV
    do a = b+1, nV
      do j = 1, nO
        do i = j+1, nO
          tmp = t2_cc(i,j,a,b)
          if (dabs(tmp) >= thresh1) cycle
          if (dabs(tmp) >= thresh2) then
            if (i <= cc_nOa .and. j <= cc_nOa .and. (a > cc_nVa .or. b > cc_nVa)) cycle
            if (i > cc_nOa .and. j > cc_nOa .and. (a <= cc_nVa .or. b <= cc_nVa)) cycle
            if (a > cc_nVa .and. b > cc_nVa .and. (i <= cc_nOa .or. j <= cc_nOa)) cycle
            if (a <= cc_nVa .and. b <= cc_nVa .and. (i > cc_nOa .or. j > cc_nOa)) cycle
            tmp_idx(1) = i
            tmp_idx(2) = j
            tmp_idx(3) = a
            tmp_idx(4) = b
            ! idx -> det
            call build_det_t((/0d0/),tmp_idx,1,4,det,coef)
            ! is in alpha C beta ?
            if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
            if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
            acc = acc + tmp**2
            idx = idx + 1
          endif
        enddo
      enddo
    enddo
  enddo

  sze_t2 = idx

end

subroutine contrib_t2_full(nO,nV,thresh1,thresh2,t2_cc,sze_t2,t2,t2_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2
  double precision, intent(in)    :: thresh1,thresh2,t2_cc(nO,nO,nV,nV)

  ! out
  double precision, intent(out)   :: t2(sze_t2)
  integer, intent(out)            :: t2_idx(4,sze_t2)
  
  integer :: i,j,a,b,idx,tmp_idx(4)
  integer(bit_kind) :: det(N_int,2)
  double precision :: coef(1), tmp
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique
  
  idx = 1
  do b = 1, nV
    do a = b+1, nV
      do j = 1, nO
        do i = j+1, nO
          tmp = t2_cc(i,j,a,b)
          if (dabs(tmp) >= thresh1) cycle
          if (dabs(tmp) >= thresh2) then
            if (i <= cc_nOa .and. j <= cc_nOa .and. (a > cc_nVa .or. b > cc_nVa)) cycle
            if (i > cc_nOa .and. j > cc_nOa .and. (a <= cc_nVa .or. b <= cc_nVa)) cycle
            if (a > cc_nVa .and. b > cc_nVa .and. (i <= cc_nOa .or. j <= cc_nOa)) cycle
            if (a <= cc_nVa .and. b <= cc_nVa .and. (i > cc_nOa .or. j > cc_nOa)) cycle
            tmp_idx(1) = i
            tmp_idx(2) = j
            tmp_idx(3) = a
            tmp_idx(4) = b
            ! idx -> det
            call build_det_t((/0d0/),tmp_idx,1,4,det,coef)
            ! is in alpha C beta ?
            if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
            if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
            t2(idx) = tmp
            t2_idx(:,idx) = tmp_idx(:)
            idx = idx + 1
          endif
        enddo
      enddo
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t2,t2_idx,sze_t2,4)
  
  ! Reorder the index of each t
  call reorder_t_idx(t2,t2_idx,sze_t2,4)

end  
#+end_src

** T3 from (T)
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t3_nb(nO,nV,thresh,t1_cc,t2_cc,f_o,f_v, &
  v_ooov,v_vvvo,sze_t3)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV
  double precision, intent(in) :: thresh, t1_cc(nO,nV), t2_cc(nO,nO,nV,nV)
  double precision, intent(in) :: f_o(nO), f_v(nV)
  double precision, intent(in) :: v_ooov(nO,nO,nO,nV), v_vvvo(nV,nV,nV,nO)

  ! out
  integer, intent(out)         :: sze_t3

  integer                      :: i,j,k,m,a,b,c,e,idx
  double precision             :: delta, delta_abc, acc


  ! T3 from (T)
  ! Only for canonical orbitals !!!
  ! Check
  do i = 1, N_int
    if (psi_det(i,1,cc_ref) /= hf_bitmask(i,1) .or. &
        psi_det(i,2,cc_ref) /= hf_bitmask(i,2)) then
      print*,'T3 only available for HF reference with canonical orbitals'
      print*,'Reference used:'
      call print_det(psi_det(1,1,cc_ref))
      call abort
    endif
  enddo
  
  do j = 1, mo_num
    do i = 1, mo_num
      if (i == j) cycle
      if (dabs(fock_matrix_mo(i,j)) > 1e-4) then
        print*,'T3 only available for HF reference with canonical orbitals'
        print*,'Non-zero off-diagonal elements detected:'
        print*,i,j,fock_matrix_mo(i,j)
        call abort
      endif
    enddo
  enddo
  
  idx = 0
  do c = 1, nV-2
    do b = c+1, nV-1
      do a = b+1, nV
        delta_abc = f_v(a) + f_v(b) + f_v(c)
        do k = 1, nO-2
          do j = k+1, nO-1
            do i = j+1, nO
              acc = 0d0
              delta = f_o(i) + f_o(j) + f_o(k) - delta_abc
              do e = 1, nV
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                acc = acc &
                  + t2_cc(j,k,a,e) * v_vvvo(b,c,e,i) &
                  - t2_cc(i,k,a,e) * v_vvvo(b,c,e,j) & ! - P(ij)
                  - t2_cc(j,i,a,e) * v_vvvo(b,c,e,k) & ! - P(ik)
                  - t2_cc(j,k,b,e) * v_vvvo(a,c,e,i) & ! - P(ab)
                  - t2_cc(j,k,c,e) * v_vvvo(b,a,e,i) & ! - P(ac)
                  + t2_cc(i,k,b,e) * v_vvvo(a,c,e,j) & ! + P(ij) P(ab)
                  + t2_cc(i,k,c,e) * v_vvvo(b,a,e,j) & ! + P(ij) P(ac)
                  + t2_cc(j,i,b,e) * v_vvvo(a,c,e,k) & ! + P(ik) P(ab)
                  + t2_cc(j,i,c,e) * v_vvvo(b,a,e,k)   ! + P(ik) P(ac)
              enddo
              do m = 1, nO
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                acc = acc &
                  + t2_cc(m,i,b,c) * v_ooov(j,k,m,a) &
                  - t2_cc(m,j,b,c) * v_ooov(i,k,m,a) & ! - P(ij)
                  - t2_cc(m,k,b,c) * v_ooov(j,i,m,a) & ! - P(ik)
                  - t2_cc(m,i,a,c) * v_ooov(j,k,m,b) & ! - P(ab)
                  - t2_cc(m,i,b,a) * v_ooov(j,k,m,c) & ! - P(ac)
                  + t2_cc(m,j,a,c) * v_ooov(i,k,m,b) & ! + P(ij) P(ab)
                  + t2_cc(m,j,b,a) * v_ooov(i,k,m,c) & ! + P(ij) P(ac)
                  + t2_cc(m,k,a,c) * v_ooov(j,i,m,b) & ! + P(ik) P(ab)
                  + t2_cc(m,k,b,a) * v_ooov(j,i,m,c)   ! + P(ik) P(ac)
              enddo
              !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) * (1d0 / delta)
              acc = acc / delta
              if (dabs(acc) >= thresh) then
                idx = idx + 1
              endif
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo

  sze_t3 = idx
  
end

subroutine contrib_t3(nO,nV,thresh,t1_cc,t2_cc,f_o,f_v, &
  v_ooov,v_vvvo,sze_t3,t3,t3_idx)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t3
  double precision, intent(in) :: thresh,t1_cc(nO,nV),t2_cc(nO,nO,nV,nV)
  double precision, intent(in) :: f_o(nO), f_v(nV)
  double precision, intent(in) :: v_ooov(nO,nO,nO,nV), v_vvvo(nV,nV,nV,nO)

  ! out
  double precision, intent(out)   :: t3(sze_t3)
  integer, intent(out)            :: t3_idx(6,sze_t3)
  
  integer                      :: i,j,k,m,a,b,c,e,idx
  double precision             :: delta, delta_abc, acc

  idx = 1
  do c = 1, nV-2
    do b = c+1, nV-1
      do a = b+1, nV
        delta_abc = f_v(a) + f_v(b) + f_v(c)
        do k = 1, nO-2
          do j = k+1, nO-1
            do i = j+1, nO
              acc = 0d0
              delta = f_o(i) + f_o(j) + f_o(k) - delta_abc
              do e = 1, nV
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                acc = acc &
                  + t2_cc(j,k,a,e) * v_vvvo(b,c,e,i) &
                  - t2_cc(i,k,a,e) * v_vvvo(b,c,e,j) & ! - P(ij)
                  - t2_cc(j,i,a,e) * v_vvvo(b,c,e,k) & ! - P(ik)
                  - t2_cc(j,k,b,e) * v_vvvo(a,c,e,i) & ! - P(ab)
                  - t2_cc(j,k,c,e) * v_vvvo(b,a,e,i) & ! - P(ac)
                  + t2_cc(i,k,b,e) * v_vvvo(a,c,e,j) & ! + P(ij) P(ab)
                  + t2_cc(i,k,c,e) * v_vvvo(b,a,e,j) & ! + P(ij) P(ac)
                  + t2_cc(j,i,b,e) * v_vvvo(a,c,e,k) & ! + P(ik) P(ab)
                  + t2_cc(j,i,c,e) * v_vvvo(b,a,e,k)   ! + P(ik) P(ac)
              enddo
              do m = 1, nO
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                acc = acc &
                  + t2_cc(m,i,b,c) * v_ooov(j,k,m,a) &
                  - t2_cc(m,j,b,c) * v_ooov(i,k,m,a) & ! - P(ij)
                  - t2_cc(m,k,b,c) * v_ooov(j,i,m,a) & ! - P(ik)
                  - t2_cc(m,i,a,c) * v_ooov(j,k,m,b) & ! - P(ab)
                  - t2_cc(m,i,b,a) * v_ooov(j,k,m,c) & ! - P(ac)
                  + t2_cc(m,j,a,c) * v_ooov(i,k,m,b) & ! + P(ij) P(ab)
                  + t2_cc(m,j,b,a) * v_ooov(i,k,m,c) & ! + P(ij) P(ac)
                  + t2_cc(m,k,a,c) * v_ooov(j,i,m,b) & ! + P(ik) P(ab)
                  + t2_cc(m,k,b,a) * v_ooov(j,i,m,c)   ! + P(ik) P(ac)
              enddo
              !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) * (1d0 / delta)
              acc = acc / delta
              if (dabs(acc) >= thresh) then
                t3(idx) = acc
                t3_idx(1,idx) = i
                t3_idx(2,idx) = j
                t3_idx(3,idx) = k
                t3_idx(4,idx) = a
                t3_idx(5,idx) = b
                t3_idx(6,idx) = c
                idx = idx + 1
              endif
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t3,t3_idx,sze_t3,6)

  ! Reorder the index of each t
  call reorder_t_idx(t3,t3_idx,sze_t3,6)

end  
#+end_src

** T3 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t3_full_nb(nO,nV,thresh1,thresh2,t1_cc,t2_cc,f_o,f_v, &
  v_ooov,v_vvvo,sze_t3)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV
  double precision, intent(in) :: thresh1,thresh2, t1_cc(nO,nV), t2_cc(nO,nO,nV,nV)
  double precision, intent(in) :: f_o(nO), f_v(nV)
  double precision, intent(in) :: v_ooov(nO,nO,nO,nV), v_vvvo(nV,nV,nV,nO)

  ! out
  integer, intent(out)         :: sze_t3

  integer                      :: i,j,k,m,a,b,c,e,idx,tmp_idx(6)
  double precision             :: delta, delta_abc
  integer(bit_kind) :: det(N_int,2)
  double precision :: coef(1), tmp, norm
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  norm = 0d0
  idx = 0
  do c = 1, nV-2
    do b = c+1, nV-1
      do a = b+1, nV
        delta_abc = f_v(a) + f_v(b) + f_v(c)
        do k = 1, nO-2
          do j = k+1, nO-1
            do i = j+1, nO
              tmp = 0d0
              delta = f_o(i) + f_o(j) + f_o(k) - delta_abc
              do e = 1, nV
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                tmp = tmp &
                  + t2_cc(j,k,a,e) * v_vvvo(b,c,e,i) &
                  - t2_cc(i,k,a,e) * v_vvvo(b,c,e,j) & ! - P(ij)
                  - t2_cc(j,i,a,e) * v_vvvo(b,c,e,k) & ! - P(ik)
                  - t2_cc(j,k,b,e) * v_vvvo(a,c,e,i) & ! - P(ab)
                  - t2_cc(j,k,c,e) * v_vvvo(b,a,e,i) & ! - P(ac)
                  + t2_cc(i,k,b,e) * v_vvvo(a,c,e,j) & ! + P(ij) P(ab)
                  + t2_cc(i,k,c,e) * v_vvvo(b,a,e,j) & ! + P(ij) P(ac)
                  + t2_cc(j,i,b,e) * v_vvvo(a,c,e,k) & ! + P(ik) P(ab)
                  + t2_cc(j,i,c,e) * v_vvvo(b,a,e,k)   ! + P(ik) P(ac)
              enddo
              do m = 1, nO
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                tmp = tmp &
                  + t2_cc(m,i,b,c) * v_ooov(j,k,m,a) &
                  - t2_cc(m,j,b,c) * v_ooov(i,k,m,a) & ! - P(ij)
                  - t2_cc(m,k,b,c) * v_ooov(j,i,m,a) & ! - P(ik)
                  - t2_cc(m,i,a,c) * v_ooov(j,k,m,b) & ! - P(ab)
                  - t2_cc(m,i,b,a) * v_ooov(j,k,m,c) & ! - P(ac)
                  + t2_cc(m,j,a,c) * v_ooov(i,k,m,b) & ! + P(ij) P(ab)
                  + t2_cc(m,j,b,a) * v_ooov(i,k,m,c) & ! + P(ij) P(ac)
                  + t2_cc(m,k,a,c) * v_ooov(j,i,m,b) & ! + P(ik) P(ab)
                  + t2_cc(m,k,b,a) * v_ooov(j,i,m,c)   ! + P(ik) P(ac)
              enddo
              !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) * (1d0 / delta)
              tmp = tmp / delta
              if (dabs(tmp) >= thresh1) cycle
              if (dabs(tmp) >= thresh2) then
                ! Indexes
                tmp_idx(1) = i
                tmp_idx(2) = j
                tmp_idx(3) = k
                tmp_idx(4) = a
                tmp_idx(5) = b
                tmp_idx(6) = c
                ! idx -> det
                call build_det_t((/0d0/),tmp_idx,1,6,det,coef)
                ! is in alpha C beta ?
                if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
                if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
                norm = norm + tmp**2
                idx = idx + 1
              endif
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo

  sze_t3 = idx

end

subroutine contrib_t3_full(nO,nV,thresh1,thresh2,t1_cc,t2_cc,f_o,f_v, &
  v_ooov,v_vvvo,sze_t3,t3,t3_idx)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t3
  double precision, intent(in) :: thresh1,thresh2,t1_cc(nO,nV),t2_cc(nO,nO,nV,nV)
  double precision, intent(in) :: f_o(nO), f_v(nV)
  double precision, intent(in) :: v_ooov(nO,nO,nO,nV), v_vvvo(nV,nV,nV,nO)

  ! out
  double precision, intent(out)   :: t3(sze_t3)
  integer, intent(out)            :: t3_idx(6,sze_t3)
  
  integer                      :: i,j,k,m,a,b,c,e,idx,tmp_idx(6)
  double precision             :: delta, delta_abc
  integer(bit_kind) :: det(N_int,2)
  double precision :: coef(1), tmp, norm
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  do c = 1, nV-2
    do b = c+1, nV-1
      do a = b+1, nV
        delta_abc = f_v(a) + f_v(b) + f_v(c)
        do k = 1, nO-2
          do j = k+1, nO-1
            do i = j+1, nO
              tmp = 0d0
              delta = f_o(i) + f_o(j) + f_o(k) - delta_abc
              do e = 1, nV
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                tmp = tmp &
                  + t2_cc(j,k,a,e) * v_vvvo(b,c,e,i) &
                  - t2_cc(i,k,a,e) * v_vvvo(b,c,e,j) & ! - P(ij)
                  - t2_cc(j,i,a,e) * v_vvvo(b,c,e,k) & ! - P(ik)
                  - t2_cc(j,k,b,e) * v_vvvo(a,c,e,i) & ! - P(ab)
                  - t2_cc(j,k,c,e) * v_vvvo(b,a,e,i) & ! - P(ac)
                  + t2_cc(i,k,b,e) * v_vvvo(a,c,e,j) & ! + P(ij) P(ab)
                  + t2_cc(i,k,c,e) * v_vvvo(b,a,e,j) & ! + P(ij) P(ac)
                  + t2_cc(j,i,b,e) * v_vvvo(a,c,e,k) & ! + P(ik) P(ab)
                  + t2_cc(j,i,c,e) * v_vvvo(b,a,e,k)   ! + P(ik) P(ac)
              enddo
              do m = 1, nO
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                tmp = tmp &
                  + t2_cc(m,i,b,c) * v_ooov(j,k,m,a) &
                  - t2_cc(m,j,b,c) * v_ooov(i,k,m,a) & ! - P(ij)
                  - t2_cc(m,k,b,c) * v_ooov(j,i,m,a) & ! - P(ik)
                  - t2_cc(m,i,a,c) * v_ooov(j,k,m,b) & ! - P(ab)
                  - t2_cc(m,i,b,a) * v_ooov(j,k,m,c) & ! - P(ac)
                  + t2_cc(m,j,a,c) * v_ooov(i,k,m,b) & ! + P(ij) P(ab)
                  + t2_cc(m,j,b,a) * v_ooov(i,k,m,c) & ! + P(ij) P(ac)
                  + t2_cc(m,k,a,c) * v_ooov(j,i,m,b) & ! + P(ik) P(ab)
                  + t2_cc(m,k,b,a) * v_ooov(j,i,m,c)   ! + P(ik) P(ac)
              enddo
              !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) * (1d0 / delta)
              tmp = tmp / delta
              if (dabs(tmp) >= thresh1) cycle
              if (dabs(tmp) >= thresh2) then
                ! Indexes
                tmp_idx(1) = i
                tmp_idx(2) = j
                tmp_idx(3) = k
                tmp_idx(4) = a
                tmp_idx(5) = b
                tmp_idx(6) = c
                ! idx -> det
                call build_det_t((/0d0/),tmp_idx,1,6,det,coef)
                ! is in alpha C beta ?
                if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
                if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
                t3(idx) = tmp
                t3_idx(:,idx) = tmp_idx(:)
                idx = idx + 1
              endif
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t3,t3_idx,sze_t3,6)

  ! Reorder the index of each t
  call reorder_t_idx(t3,t3_idx,sze_t3,6)

end  
#+end_src

** T1^2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t11_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1
  double precision, intent(in)    :: thresh,t1(sze_t1)
  integer, intent(in)             :: t1_idx(2,sze_t1)

  ! out
  integer, intent(out)          :: sze_t11

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t1-1
    do j = i+1, sze_t1
      if (dabs(t1(i) * t1(j)) >= thresh) then
        ! The resulting coeff can't contain 2 times the same spin orbital index
        if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(2,i) == t1_idx(2,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t11 = idx

end

subroutine contrib_t11(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t11
  double precision, intent(in)    :: thresh,t1(sze_t1)
  integer, intent(in)             :: t1_idx(2,sze_t1)

  ! out
  double precision, intent(out)   :: t11(sze_t11)
  integer, intent(out)            :: t11_idx(4,sze_t11)
  
  integer :: i,j,idx
  
  idx = 1
  do i = 1, sze_t1-1
    do j = i+1, sze_t1
      if (dabs(t1(i) * t1(j)) >= thresh) then
        if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(2,i) == t1_idx(2,j)) cycle
        t11(idx) = t1(i) * t1(j)
        t11_idx(1,idx) = t1_idx(1,i)
        t11_idx(3,idx) = t1_idx(2,i)
        t11_idx(2,idx) = t1_idx(1,j)
        t11_idx(4,idx) = t1_idx(2,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t11,t11_idx,sze_t11,4)

  ! Reorder the index of each t
  call reorder_t_idx(t11,t11_idx,sze_t11,4)

end  
#+end_src

** T1^2 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t11_full_nb(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t11)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1
  double precision, intent(in)    :: thresh1,thresh2,t1(sze_t1)
  integer, intent(in)             :: t1_idx(2,sze_t1)

  ! out
  integer, intent(out)          :: sze_t11

  integer :: i,j,idx,tmp_idx(4)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  acc = 0d0
  idx = 0
  do i = 1, sze_t1-1
    do j = i+1, sze_t1
      tmp = t1(i) * t1(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        ! The resulting coeff can't contain 2 times the same spin orbital index
        if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(2,i) == t1_idx(2,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(3) = t1_idx(2,i)
        tmp_idx(2) = t1_idx(1,j)
        tmp_idx(4) = t1_idx(2,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,4,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        ! Norm
        acc = acc + tmp**2
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t11 = idx

end

subroutine contrib_t11_full(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t11
  double precision, intent(in)    :: thresh1,thresh2,t1(sze_t1)
  integer, intent(in)             :: t1_idx(2,sze_t1)

  ! out
  double precision, intent(out)   :: t11(sze_t11)
  integer, intent(out)            :: t11_idx(4,sze_t11)
  
  integer :: i,j,idx,tmp_idx(4)
  double precision :: tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  do i = 1, sze_t1-1
    do j = i+1, sze_t1
      tmp = t1(i) * t1(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(2,i) == t1_idx(2,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(3) = t1_idx(2,i)
        tmp_idx(2) = t1_idx(1,j)
        tmp_idx(4) = t1_idx(2,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,4,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t11(idx) = tmp
        t11_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t11,t11_idx,sze_t11,4)

  ! Reorder the index of each t
  call reorder_t_idx(t11,t11_idx,sze_t11,4)

end  
#+end_src

** T1 T2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t12_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx,sze_t12)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t2
  double precision, intent(in) :: thresh,t1(sze_t1),t2(sze_t2)
  integer, intent(in)          :: t1_idx(2,sze_t1),t2_idx(4,sze_t2)

  ! out
  integer, intent(out)         :: sze_t12

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t2
      if (dabs(t1(i) * t2(j)) >= thresh) then
        if (t1_idx(1,i) == t2_idx(1,j) .or. t1_idx(1,i) == t2_idx(2,j) .or. &
            t1_idx(2,i) == t2_idx(3,j) .or. t1_idx(2,i) == t2_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t12 = idx
        
end

subroutine contrib_t12(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx,&
     sze_t12,t12,t12_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t2,sze_t12
  double precision, intent(in)    :: thresh,t1(sze_t1),t2(sze_t2)
  integer, intent(in)             :: t1_idx(2,sze_t1),t2_idx(4,sze_t2)

  ! out
  double precision, intent(out)   :: t12(sze_t12)
  integer, intent(out)            :: t12_idx(6,sze_t12)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t2
      if (dabs(t1(i) * t2(j)) >= thresh) then
        if (t1_idx(1,i) == t2_idx(1,j) .or. t1_idx(1,i) == t2_idx(2,j) .or. &
            t1_idx(2,i) == t2_idx(3,j) .or. t1_idx(2,i) == t2_idx(4,j)) cycle
        t12(idx) = t1(i) * t2(j)
        t12_idx(1,idx) = t1_idx(1,i)
        t12_idx(4,idx) = t1_idx(2,i)
        t12_idx(2,idx) = t2_idx(1,j)
        t12_idx(3,idx) = t2_idx(2,j)
        t12_idx(5,idx) = t2_idx(3,j)
        t12_idx(6,idx) = t2_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo 

  ! Sort
  call sort_by_coef_idx(t12,t12_idx,sze_t12,6)

  ! Reorder the index of each t
  call reorder_t_idx(t12,t12_idx,sze_t12,6)

end  
#+end_src

** T1 T2 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t12_full_nb(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx,sze_t12)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t2
  double precision, intent(in) :: thresh1,thresh2,t1(sze_t1),t2(sze_t2)
  integer, intent(in)          :: t1_idx(2,sze_t1),t2_idx(4,sze_t2)

  ! out
  integer, intent(out)         :: sze_t12

  integer :: i,j,idx,tmp_idx(6)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  acc = 0d0
  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t2
      tmp = t1(i) * t2(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) == t2_idx(1,j) .or. t1_idx(1,i) == t2_idx(2,j) .or. &
            t1_idx(2,i) == t2_idx(3,j) .or. t1_idx(2,i) == t2_idx(4,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(4) = t1_idx(2,i)
        tmp_idx(2) = t2_idx(1,j)
        tmp_idx(3) = t2_idx(2,j)
        tmp_idx(5) = t2_idx(3,j)
        tmp_idx(6) = t2_idx(4,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,6,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        acc = acc + tmp**2
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t12 = idx

end

subroutine contrib_t12_full(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx,&
     sze_t12,t12,t12_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t2,sze_t12
  double precision, intent(in)    :: thresh1,thresh2,t1(sze_t1),t2(sze_t2)
  integer, intent(in)             :: t1_idx(2,sze_t1),t2_idx(4,sze_t2)

  ! out
  double precision, intent(out)   :: t12(sze_t12)
  integer, intent(out)            :: t12_idx(6,sze_t12)
  
  integer :: i,j,idx,tmp_idx(6)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t2
      tmp = t1(i) * t2(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) == t2_idx(1,j) .or. t1_idx(1,i) == t2_idx(2,j) .or. &
            t1_idx(2,i) == t2_idx(3,j) .or. t1_idx(2,i) == t2_idx(4,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(4) = t1_idx(2,i)
        tmp_idx(2) = t2_idx(1,j)
        tmp_idx(3) = t2_idx(2,j)
        tmp_idx(5) = t2_idx(3,j)
        tmp_idx(6) = t2_idx(4,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,6,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t12(idx) = tmp
        t12_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t12,t12_idx,sze_t12,6)

  ! Reorder the index of each t
  call reorder_t_idx(t12,t12_idx,sze_t12,6)

end  
#+end_src

** T1 T2^2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t122_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t22,t22,t22_idx,sze_t122)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t22
  double precision, intent(in) :: thresh,t1(sze_t1),t22(sze_t22)
  integer, intent(in)          :: t1_idx(2,sze_t1),t22_idx(8,sze_t22)

  ! out
  integer, intent(out)         :: sze_t122

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t22
      if (dabs(t1(i) * t22(j)) >= thresh) then
        if (t1_idx(1,i) == t22_idx(1,j) .or. t1_idx(1,i) == t22_idx(2,j) .or. &
            t1_idx(1,i) == t22_idx(3,j) .or. t1_idx(1,i) == t22_idx(4,j) .or. &
            t1_idx(2,i) == t22_idx(5,j) .or. t1_idx(2,i) == t22_idx(6,j) .or. &
            t1_idx(2,i) == t22_idx(7,j) .or. t1_idx(2,i) == t22_idx(8,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t122 = idx
        
end

subroutine contrib_t122(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t22,t22,t22_idx,&
     sze_t122,t122,t122_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t22,sze_t122
  double precision, intent(in)    :: thresh,t1(sze_t1),t22(sze_t22)
  integer, intent(in)             :: t1_idx(2,sze_t1),t22_idx(8,sze_t22)

  ! out
  double precision, intent(out)   :: t122(sze_t122)
  integer, intent(out)            :: t122_idx(10,sze_t122)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t22
      if (dabs(t1(i) * t22(j)) >= thresh) then
        if (t1_idx(1,i) == t22_idx(1,j) .or. t1_idx(1,i) == t22_idx(2,j) .or. &
            t1_idx(1,i) == t22_idx(3,j) .or. t1_idx(1,i) == t22_idx(4,j) .or. &
            t1_idx(2,i) == t22_idx(5,j) .or. t1_idx(2,i) == t22_idx(6,j) .or. &
            t1_idx(2,i) == t22_idx(7,j) .or. t1_idx(2,i) == t22_idx(8,j)) cycle
        t122(idx) = t1(i) * t22(j)
        t122_idx(1,idx) = t1_idx(1,i)
        t122_idx(6,idx) = t1_idx(2,i)
        t122_idx(2,idx) = t22_idx(1,j)
        t122_idx(3,idx) = t22_idx(2,j)
        t122_idx(4,idx) = t22_idx(3,j)
        t122_idx(5,idx) = t22_idx(4,j)
        t122_idx(7,idx) = t22_idx(5,j)
        t122_idx(8,idx) = t22_idx(6,j)
        t122_idx(9,idx) = t22_idx(7,j)
        t122_idx(10,idx) = t22_idx(8,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t122,t122_idx,sze_t122,10)
  
  ! Reorder the index of each t
  call reorder_t_idx(t122,t122_idx,sze_t122,10)

end  
#+end_src

** T1 T2^2 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t122_full_nb(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t22,t22,t22_idx,sze_t122)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t22
  double precision, intent(in) :: thresh1,thresh2,t1(sze_t1),t22(sze_t22)
  integer, intent(in)          :: t1_idx(2,sze_t1),t22_idx(8,sze_t22)

  ! out
  integer, intent(out)         :: sze_t122

  integer :: i,j,idx,tmp_idx(10)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t22
      tmp = t1(i) * t22(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) == t22_idx(1,j) .or. t1_idx(1,i) == t22_idx(2,j) .or. &
            t1_idx(1,i) == t22_idx(3,j) .or. t1_idx(1,i) == t22_idx(4,j) .or. &
            t1_idx(2,i) == t22_idx(5,j) .or. t1_idx(2,i) == t22_idx(6,j) .or. &
            t1_idx(2,i) == t22_idx(7,j) .or. t1_idx(2,i) == t22_idx(8,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(6) = t1_idx(2,i)
        tmp_idx(2) = t22_idx(1,j)
        tmp_idx(3) = t22_idx(2,j)
        tmp_idx(4) = t22_idx(3,j)
        tmp_idx(5) = t22_idx(4,j)
        tmp_idx(7) = t22_idx(5,j)
        tmp_idx(8) = t22_idx(6,j)
        tmp_idx(9) = t22_idx(7,j)
        tmp_idx(10) = t22_idx(8,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,10,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t122 = idx
        
end

subroutine contrib_t122_full(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t22,t22,t22_idx,&
     sze_t122,t122,t122_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t22,sze_t122
  double precision, intent(in)    :: thresh1,thresh2,t1(sze_t1),t22(sze_t22)
  integer, intent(in)             :: t1_idx(2,sze_t1),t22_idx(8,sze_t22)

  ! out
  double precision, intent(out)   :: t122(sze_t122)
  integer, intent(out)            :: t122_idx(10,sze_t122)
  
  integer :: i,j,idx,tmp_idx(10)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t22
      tmp = t1(i) * t22(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) == t22_idx(1,j) .or. t1_idx(1,i) == t22_idx(2,j) .or. &
            t1_idx(1,i) == t22_idx(3,j) .or. t1_idx(1,i) == t22_idx(4,j) .or. &
            t1_idx(2,i) == t22_idx(5,j) .or. t1_idx(2,i) == t22_idx(6,j) .or. &
            t1_idx(2,i) == t22_idx(7,j) .or. t1_idx(2,i) == t22_idx(8,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(6) = t1_idx(2,i)
        tmp_idx(2) = t22_idx(1,j)
        tmp_idx(3) = t22_idx(2,j)
        tmp_idx(4) = t22_idx(3,j)
        tmp_idx(5) = t22_idx(4,j)
        tmp_idx(7) = t22_idx(5,j)
        tmp_idx(8) = t22_idx(6,j)
        tmp_idx(9) = t22_idx(7,j)
        tmp_idx(10) = t22_idx(8,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,10,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t122(idx) = tmp
        t122_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t122,t122_idx,sze_t122,10)
  
  ! Reorder the index of each t
  call reorder_t_idx(t122,t122_idx,sze_t122,10)

end  
#+end_src

** T1 T3
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t13_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,sze_t13)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t3
  double precision, intent(in) :: thresh,t1(sze_t1),t3(sze_t3)
  integer, intent(in)          :: t1_idx(2,sze_t1),t3_idx(6,sze_t3)

  ! out
  integer, intent(out)         :: sze_t13

  integer :: i,j,idx

  ! t13
  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t3
      if (dabs(t1(i) * t3(j)) >= thresh) then
        if (t1_idx(1,i) == t3_idx(1,j) .or. t1_idx(1,i) == t3_idx(2,j) .or. &
            t1_idx(1,i) == t3_idx(3,j) .or. &
            t1_idx(2,i) == t3_idx(4,j) .or. t1_idx(2,i) == t3_idx(5,j) .or. &
            t1_idx(2,i) == t3_idx(6,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t13 = idx
        
end

subroutine contrib_t13(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,&
     sze_t13,t13,t13_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t3,sze_t13
  double precision, intent(in)    :: thresh,t1(sze_t1),t3(sze_t3)
  integer, intent(in)             :: t1_idx(2,sze_t1),t3_idx(6,sze_t3)

  ! out
  double precision, intent(out)   :: t13(sze_t13)
  integer, intent(out)            :: t13_idx(8,sze_t13)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t3
      if (dabs(t1(i) * t3(j)) >= thresh) then
        if (t1_idx(1,i) == t3_idx(1,j) .or. t1_idx(1,i) == t3_idx(2,j) .or. &
            t1_idx(1,i) == t3_idx(3,j) .or. &
            t1_idx(2,i) == t3_idx(4,j) .or. t1_idx(2,i) == t3_idx(5,j) .or. &
            t1_idx(2,i) == t3_idx(6,j)) cycle
        t13(idx) = t1(i) * t3(j)
        t13_idx(1,idx) = t1_idx(1,i)
        t13_idx(5,idx) = t1_idx(2,i)
        t13_idx(2,idx) = t3_idx(1,j)
        t13_idx(3,idx) = t3_idx(2,j)
        t13_idx(4,idx) = t3_idx(3,j)
        t13_idx(6,idx) = t3_idx(4,j)
        t13_idx(7,idx) = t3_idx(5,j)
        t13_idx(8,idx) = t3_idx(6,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t13,t13_idx,sze_t13,8)
  
  ! Reorder the index of each t
  call reorder_t_idx(t13,t13_idx,sze_t13,8)    
end  
#+end_src

** T1 T3 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t13_full_nb(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,sze_t13)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t3
  double precision, intent(in) :: thresh1,thresh2,t1(sze_t1),t3(sze_t3)
  integer, intent(in)          :: t1_idx(2,sze_t1),t3_idx(6,sze_t3)

  ! out
  integer, intent(out)         :: sze_t13

  integer :: i,j,idx,tmp_idx(8)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  acc = 0d0
  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t3
      tmp = t1(i) * t3(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) == t3_idx(1,j) .or. t1_idx(1,i) == t3_idx(2,j) .or. &
            t1_idx(1,i) == t3_idx(3,j) .or. &
            t1_idx(2,i) == t3_idx(4,j) .or. t1_idx(2,i) == t3_idx(5,j) .or. &
            t1_idx(2,i) == t3_idx(6,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(5) = t1_idx(2,i)
        tmp_idx(2) = t3_idx(1,j)
        tmp_idx(3) = t3_idx(2,j)
        tmp_idx(4) = t3_idx(3,j)
        tmp_idx(6) = t3_idx(4,j)
        tmp_idx(7) = t3_idx(5,j)
        tmp_idx(8) = t3_idx(6,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,8,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        acc = acc + tmp**2
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t13 = idx

end

subroutine contrib_t13_full(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,&
     sze_t13,t13,t13_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t3,sze_t13
  double precision, intent(in)    :: thresh1,thresh2,t1(sze_t1),t3(sze_t3)
  integer, intent(in)             :: t1_idx(2,sze_t1),t3_idx(6,sze_t3)

  ! out
  double precision, intent(out)   :: t13(sze_t13)
  integer, intent(out)            :: t13_idx(8,sze_t13)
  
  integer :: i,j,idx,tmp_idx(8)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t3
      tmp = t1(i) * t3(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) == t3_idx(1,j) .or. t1_idx(1,i) == t3_idx(2,j) .or. &
            t1_idx(1,i) == t3_idx(3,j) .or. &
            t1_idx(2,i) == t3_idx(4,j) .or. t1_idx(2,i) == t3_idx(5,j) .or. &
            t1_idx(2,i) == t3_idx(6,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(5) = t1_idx(2,i)
        tmp_idx(2) = t3_idx(1,j)
        tmp_idx(3) = t3_idx(2,j)
        tmp_idx(4) = t3_idx(3,j)
        tmp_idx(6) = t3_idx(4,j)
        tmp_idx(7) = t3_idx(5,j)
        tmp_idx(8) = t3_idx(6,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,8,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t13(idx) = tmp
        t13_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t13,t13_idx,sze_t13,8)
  
  ! Reorder the index of each t
  call reorder_t_idx(t13,t13_idx,sze_t13,8)    
end  
#+end_src

** T1^2 T3
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t113_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t13,t13,t13_idx,sze_t113)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t13
  double precision, intent(in) :: thresh,t1(sze_t1),t13(sze_t13)
  integer, intent(in)          :: t1_idx(2,sze_t1),t13_idx(8,sze_t13)

  ! out
  integer, intent(out)         :: sze_t113

  integer :: i,j,idx

  ! t13
  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t13
      if (dabs(t1(i) * t13(j)) >= thresh) then
        if (t1_idx(1,i) == t13_idx(1,j) .or. t1_idx(1,i) == t13_idx(2,j) .or. &
            t1_idx(1,i) == t13_idx(3,j) .or. t1_idx(1,i) == t13_idx(4,j) .or. &
            t1_idx(2,i) == t13_idx(5,j) .or. t1_idx(2,i) == t13_idx(6,j) .or. &
            t1_idx(2,i) == t13_idx(7,j) .or. t1_idx(2,i) == t13_idx(8,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t113 = idx
        
end

subroutine contrib_t113(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t13,t13,t13_idx,&
     sze_t113,t113,t113_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t13,sze_t113
  double precision, intent(in)    :: thresh,t1(sze_t1),t13(sze_t13)
  integer, intent(in)             :: t1_idx(2,sze_t1),t13_idx(8,sze_t13)

  ! out
  double precision, intent(out)   :: t113(sze_t113)
  integer, intent(out)            :: t113_idx(10,sze_t113)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t13
      if (dabs(t1(i) * t13(j)) >= thresh) then
        if (t1_idx(1,i) == t13_idx(1,j) .or. t1_idx(1,i) == t13_idx(2,j) .or. &
            t1_idx(1,i) == t13_idx(3,j) .or. t1_idx(1,i) == t13_idx(4,j) .or. &
            t1_idx(2,i) == t13_idx(5,j) .or. t1_idx(2,i) == t13_idx(6,j) .or. &
            t1_idx(2,i) == t13_idx(7,j) .or. t1_idx(2,i) == t13_idx(8,j)) cycle
        t113(idx) = t1(i) * t13(j)
        t113_idx(1,idx) = t1_idx(1,i)
        t113_idx(6,idx) = t1_idx(2,i)
        t113_idx(2,idx) = t13_idx(1,j)
        t113_idx(3,idx) = t13_idx(2,j)
        t113_idx(4,idx) = t13_idx(3,j)
        t113_idx(5,idx) = t13_idx(4,j)
        t113_idx(7,idx) = t13_idx(5,j)
        t113_idx(8,idx) = t13_idx(6,j)
        t113_idx(9,idx) = t13_idx(7,j)
        t113_idx(10,idx) = t13_idx(8,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t113,t113_idx,sze_t113,10)
  
  ! Reorder the index of each t
  call reorder_t_idx(t113,t113_idx,sze_t113,10)
  
end  
#+end_src

** T1^2 T3 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t113_full_nb(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t13,t13,t13_idx,sze_t113)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t13
  double precision, intent(in) :: thresh1,thresh2,t1(sze_t1),t13(sze_t13)
  integer, intent(in)          :: t1_idx(2,sze_t1),t13_idx(8,sze_t13)

  ! out
  integer, intent(out)         :: sze_t113

  integer :: i,j,idx,tmp_idx(10)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t13
      tmp = t1(i) * t13(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) == t13_idx(1,j) .or. t1_idx(1,i) == t13_idx(2,j) .or. &
            t1_idx(1,i) == t13_idx(3,j) .or. t1_idx(1,i) == t13_idx(4,j) .or. &
            t1_idx(2,i) == t13_idx(5,j) .or. t1_idx(2,i) == t13_idx(6,j) .or. &
            t1_idx(2,i) == t13_idx(7,j) .or. t1_idx(2,i) == t13_idx(8,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(6) = t1_idx(2,i)
        tmp_idx(2) = t13_idx(1,j)
        tmp_idx(3) = t13_idx(2,j)
        tmp_idx(4) = t13_idx(3,j)
        tmp_idx(5) = t13_idx(4,j)
        tmp_idx(7) = t13_idx(5,j)
        tmp_idx(8) = t13_idx(6,j)
        tmp_idx(9) = t13_idx(7,j)
        tmp_idx(10) = t13_idx(8,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,10,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t113 = idx
        
end

subroutine contrib_t113_full(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t13,t13,t13_idx,&
     sze_t113,t113,t113_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t13,sze_t113
  double precision, intent(in)    :: thresh1,thresh2,t1(sze_t1),t13(sze_t13)
  integer, intent(in)             :: t1_idx(2,sze_t1),t13_idx(8,sze_t13)

  ! out
  double precision, intent(out)   :: t113(sze_t113)
  integer, intent(out)            :: t113_idx(10,sze_t113)
  
  integer :: i,j,idx,tmp_idx(10)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t13
      tmp = t1(i) * t13(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) == t13_idx(1,j) .or. t1_idx(1,i) == t13_idx(2,j) .or. &
            t1_idx(1,i) == t13_idx(3,j) .or. t1_idx(1,i) == t13_idx(4,j) .or. &
            t1_idx(2,i) == t13_idx(5,j) .or. t1_idx(2,i) == t13_idx(6,j) .or. &
            t1_idx(2,i) == t13_idx(7,j) .or. t1_idx(2,i) == t13_idx(8,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(6) = t1_idx(2,i)
        tmp_idx(2) = t13_idx(1,j)
        tmp_idx(3) = t13_idx(2,j)
        tmp_idx(4) = t13_idx(3,j)
        tmp_idx(5) = t13_idx(4,j)
        tmp_idx(7) = t13_idx(5,j)
        tmp_idx(8) = t13_idx(6,j)
        tmp_idx(9) = t13_idx(7,j)
        tmp_idx(10) = t13_idx(8,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,10,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t113(idx) = tmp
        t113_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t113,t113_idx,sze_t113,10)
  
  ! Reorder the index of each t
  call reorder_t_idx(t113,t113_idx,sze_t113,10)
  
end  
#+end_src

** T2 T3
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t23_nb(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t3,t3,t3_idx,sze_t23)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t2,sze_t3
  double precision, intent(in) :: thresh,t2(sze_t2),t3(sze_t3)
  integer, intent(in)          :: t2_idx(4,sze_t2),t3_idx(6,sze_t3)

  ! out
  integer, intent(out)         :: sze_t23

  integer :: i,j,idx

  ! t13
  idx = 0
  do i = 1, sze_t2
    do j = 1, sze_t3
      if (dabs(t2(i) * t3(j)) >= thresh) then
        if (t2_idx(1,i) == t3_idx(1,j) .or. t2_idx(1,i) == t3_idx(2,j) .or. &
            t2_idx(1,i) == t3_idx(3,j) .or. &
            t2_idx(2,i) == t3_idx(1,j) .or. t2_idx(2,i) == t3_idx(2,j) .or. &
            t2_idx(2,i) == t3_idx(3,j) .or. &
            t2_idx(3,i) == t3_idx(4,j) .or. t2_idx(3,i) == t3_idx(5,j) .or. &
            t2_idx(3,i) == t3_idx(6,j) .or. &
            t2_idx(4,i) == t3_idx(4,j) .or. t2_idx(4,i) == t3_idx(5,j) .or. &
            t2_idx(4,i) == t3_idx(6,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t23 = idx
        
end

subroutine contrib_t23(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t3,t3,t3_idx,&
     sze_t23,t23,t23_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2,sze_t3,sze_t23
  double precision, intent(in)    :: thresh,t2(sze_t2),t3(sze_t3)
  integer, intent(in)             :: t2_idx(4,sze_t2),t3_idx(6,sze_t3)

  ! out
  double precision, intent(out)   :: t23(sze_t23)
  integer, intent(out)            :: t23_idx(10,sze_t23)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t2
    do j = 1, sze_t3
      if (dabs(t2(i) * t3(j)) >= thresh) then
        if (t2_idx(1,i) == t3_idx(1,j) .or. t2_idx(1,i) == t3_idx(2,j) .or. &
            t2_idx(1,i) == t3_idx(3,j) .or. &
            t2_idx(2,i) == t3_idx(1,j) .or. t2_idx(2,i) == t3_idx(2,j) .or. &
            t2_idx(2,i) == t3_idx(3,j) .or. &
            t2_idx(3,i) == t3_idx(4,j) .or. t2_idx(3,i) == t3_idx(5,j) .or. &
            t2_idx(3,i) == t3_idx(6,j) .or. &
            t2_idx(4,i) == t3_idx(4,j) .or. t2_idx(4,i) == t3_idx(5,j) .or. &
            t2_idx(4,i) == t3_idx(6,j)) cycle
        t23(idx) = t2(i) * t3(j)
        t23_idx(1,idx) = t2_idx(1,i)
        t23_idx(2,idx) = t2_idx(2,i)
        t23_idx(6,idx) = t2_idx(3,i)
        t23_idx(7,idx) = t2_idx(4,i)
        t23_idx(3,idx) = t3_idx(1,j)
        t23_idx(4,idx) = t3_idx(2,j)
        t23_idx(5,idx) = t3_idx(3,j)
        t23_idx(8,idx) = t3_idx(4,j)
        t23_idx(9,idx) = t3_idx(5,j)
        t23_idx(10,idx) = t3_idx(6,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t23,t23_idx,sze_t23,10)
  
  ! Reorder the index of each t
  call reorder_t_idx(t23,t23_idx,sze_t23,10)

end
#+end_src

** T2 T3 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t23_full_nb(nO,nV,thresh1,thresh2,sze_t2,t2,t2_idx,sze_t3,t3,t3_idx,sze_t23)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t2,sze_t3
  double precision, intent(in) :: thresh1,thresh2,t2(sze_t2),t3(sze_t3)
  integer, intent(in)          :: t2_idx(4,sze_t2),t3_idx(6,sze_t3)

  ! out
  integer, intent(out)         :: sze_t23

  integer :: i,j,idx,tmp_idx(10)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  ! t13
  idx = 0
  do i = 1, sze_t2
    do j = 1, sze_t3
      tmp = t2(i) * t3(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t2_idx(1,i) == t3_idx(1,j) .or. t2_idx(1,i) == t3_idx(2,j) .or. &
            t2_idx(1,i) == t3_idx(3,j) .or. &
            t2_idx(2,i) == t3_idx(1,j) .or. t2_idx(2,i) == t3_idx(2,j) .or. &
            t2_idx(2,i) == t3_idx(3,j) .or. &
            t2_idx(3,i) == t3_idx(4,j) .or. t2_idx(3,i) == t3_idx(5,j) .or. &
            t2_idx(3,i) == t3_idx(6,j) .or. &
            t2_idx(4,i) == t3_idx(4,j) .or. t2_idx(4,i) == t3_idx(5,j) .or. &
            t2_idx(4,i) == t3_idx(6,j)) cycle
        ! Indexes
        tmp_idx(1) = t2_idx(1,i)
        tmp_idx(2) = t2_idx(2,i)
        tmp_idx(6) = t2_idx(3,i)
        tmp_idx(7) = t2_idx(4,i)
        tmp_idx(3) = t3_idx(1,j)
        tmp_idx(4) = t3_idx(2,j)
        tmp_idx(5) = t3_idx(3,j)
        tmp_idx(8) = t3_idx(4,j)
        tmp_idx(9) = t3_idx(5,j)
        tmp_idx(10) = t3_idx(6,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,10,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t23 = idx
        
end

subroutine contrib_t23_full(nO,nV,thresh1,thresh2,sze_t2,t2,t2_idx,sze_t3,t3,t3_idx,&
     sze_t23,t23,t23_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2,sze_t3,sze_t23
  double precision, intent(in)    :: thresh1,thresh2,t2(sze_t2),t3(sze_t3)
  integer, intent(in)             :: t2_idx(4,sze_t2),t3_idx(6,sze_t3)

  ! out
  double precision, intent(out)   :: t23(sze_t23)
  integer, intent(out)            :: t23_idx(10,sze_t23)
  
  integer :: i,j,idx,tmp_idx(10)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  do i = 1, sze_t2
    do j = 1, sze_t3
      tmp = t2(i) * t3(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t2_idx(1,i) == t3_idx(1,j) .or. t2_idx(1,i) == t3_idx(2,j) .or. &
            t2_idx(1,i) == t3_idx(3,j) .or. &
            t2_idx(2,i) == t3_idx(1,j) .or. t2_idx(2,i) == t3_idx(2,j) .or. &
            t2_idx(2,i) == t3_idx(3,j) .or. &
            t2_idx(3,i) == t3_idx(4,j) .or. t2_idx(3,i) == t3_idx(5,j) .or. &
            t2_idx(3,i) == t3_idx(6,j) .or. &
            t2_idx(4,i) == t3_idx(4,j) .or. t2_idx(4,i) == t3_idx(5,j) .or. &
            t2_idx(4,i) == t3_idx(6,j)) cycle
        ! Indexes
        tmp_idx(1) = t2_idx(1,i)
        tmp_idx(2) = t2_idx(2,i)
        tmp_idx(6) = t2_idx(3,i)
        tmp_idx(7) = t2_idx(4,i)
        tmp_idx(3) = t3_idx(1,j)
        tmp_idx(4) = t3_idx(2,j)
        tmp_idx(5) = t3_idx(3,j)
        tmp_idx(8) = t3_idx(4,j)
        tmp_idx(9) = t3_idx(5,j)
        tmp_idx(10) = t3_idx(6,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,10,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t23(idx) = tmp
        t23_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t23,t23_idx,sze_t23,10)
  
  ! Reorder the index of each t
  call reorder_t_idx(t23,t23_idx,sze_t23,10)

end
#+end_src

** T1 T2 T3
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t123_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t23,t23,t23_idx,sze_t123)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t23
  double precision, intent(in) :: thresh,t1(sze_t1),t23(sze_t23)
  integer, intent(in)          :: t1_idx(2,sze_t1),t23_idx(10,sze_t23)

  ! out
  integer, intent(out)         :: sze_t123

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t23
      if (dabs(t1(i) * t23(j)) >= thresh) then
        if (t1_idx(1,i) == t23_idx(1,j) .or. t1_idx(1,i) == t23_idx(2,j) .or. &
            t1_idx(1,i) == t23_idx(3,j) .or. t1_idx(1,i) == t23_idx(4,j) .or. &
            t1_idx(1,i) == t23_idx(5,j) .or. &
            t1_idx(2,i) == t23_idx(6,j) .or. t1_idx(2,i) == t23_idx(7,j) .or. &
            t1_idx(2,i) == t23_idx(8,j) .or. t1_idx(2,i) == t23_idx(9,j) .or. &
            t1_idx(2,i) == t23_idx(10,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t123 = idx
        
end

subroutine contrib_t123(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t23,t23,t23_idx,&
     sze_t123,t123,t123_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t23,sze_t123
  double precision, intent(in)    :: thresh,t1(sze_t1),t23(sze_t23)
  integer, intent(in)             :: t1_idx(2,sze_t1),t23_idx(10,sze_t23)

  ! out
  double precision, intent(out)   :: t123(sze_t123)
  integer, intent(out)            :: t123_idx(12,sze_t123)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t23
      if (dabs(t1(i) * t23(j)) >= thresh) then
        if (t1_idx(1,i) == t23_idx(1,j) .or. t1_idx(1,i) == t23_idx(2,j) .or. &
            t1_idx(1,i) == t23_idx(3,j) .or. t1_idx(1,i) == t23_idx(4,j) .or. &
            t1_idx(1,i) == t23_idx(5,j) .or. &
            t1_idx(2,i) == t23_idx(6,j) .or. t1_idx(2,i) == t23_idx(7,j) .or. &
            t1_idx(2,i) == t23_idx(8,j) .or. t1_idx(2,i) == t23_idx(9,j) .or. &
            t1_idx(2,i) == t23_idx(10,j)) cycle
        t123(idx) = t1(i) * t23(j)
        t123_idx(1,idx) = t1_idx(1,i)
        t123_idx(7,idx) = t1_idx(2,i)
        t123_idx(2,idx) = t23_idx(1,j)
        t123_idx(3,idx) = t23_idx(2,j)
        t123_idx(4,idx) = t23_idx(3,j)
        t123_idx(5,idx) = t23_idx(4,j)
        t123_idx(6,idx) = t23_idx(5,j)
        t123_idx(8,idx) = t23_idx(6,j)
        t123_idx(9,idx) = t23_idx(7,j)
        t123_idx(10,idx) = t23_idx(8,j)
        t123_idx(11,idx) = t23_idx(9,j)
        t123_idx(12,idx) = t23_idx(10,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo 

  ! Sort
  call sort_by_coef_idx(t123,t123_idx,sze_t123,12)

  ! Reorder the index of each t
  call reorder_t_idx(t123,t123_idx,sze_t123,12)

end  
#+end_src

** T1 T2 T3 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t123_full_nb(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t23,t23,t23_idx,sze_t123)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t23
  double precision, intent(in) :: thresh1,thresh2,t1(sze_t1),t23(sze_t23)
  integer, intent(in)          :: t1_idx(2,sze_t1),t23_idx(10,sze_t23)

  ! out
  integer, intent(out)         :: sze_t123

  integer :: i,j,idx,tmp_idx(12)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t23
      tmp = t1(i) * t23(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) == t23_idx(1,j) .or. t1_idx(1,i) == t23_idx(2,j) .or. &
            t1_idx(1,i) == t23_idx(3,j) .or. t1_idx(1,i) == t23_idx(4,j) .or. &
            t1_idx(1,i) == t23_idx(5,j) .or. &
            t1_idx(2,i) == t23_idx(6,j) .or. t1_idx(2,i) == t23_idx(7,j) .or. &
            t1_idx(2,i) == t23_idx(8,j) .or. t1_idx(2,i) == t23_idx(9,j) .or. &
            t1_idx(2,i) == t23_idx(10,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(7) = t1_idx(2,i)
        tmp_idx(2) = t23_idx(1,j)
        tmp_idx(3) = t23_idx(2,j)
        tmp_idx(4) = t23_idx(3,j)
        tmp_idx(5) = t23_idx(4,j)
        tmp_idx(6) = t23_idx(5,j)
        tmp_idx(8) = t23_idx(6,j)
        tmp_idx(9) = t23_idx(7,j)
        tmp_idx(10) = t23_idx(8,j)
        tmp_idx(11) = t23_idx(9,j)
        tmp_idx(12) = t23_idx(10,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,12,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t123 = idx
        
end

subroutine contrib_t123_full(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t23,t23,t23_idx,&
     sze_t123,t123,t123_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t23,sze_t123
  double precision, intent(in)    :: thresh1,thresh2,t1(sze_t1),t23(sze_t23)
  integer, intent(in)             :: t1_idx(2,sze_t1),t23_idx(10,sze_t23)

  ! out
  double precision, intent(out)   :: t123(sze_t123)
  integer, intent(out)            :: t123_idx(12,sze_t123)
  
  integer :: i,j,idx,tmp_idx(12)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t23
      tmp = t1(i) * t23(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) == t23_idx(1,j) .or. t1_idx(1,i) == t23_idx(2,j) .or. &
            t1_idx(1,i) == t23_idx(3,j) .or. t1_idx(1,i) == t23_idx(4,j) .or. &
            t1_idx(1,i) == t23_idx(5,j) .or. &
            t1_idx(2,i) == t23_idx(6,j) .or. t1_idx(2,i) == t23_idx(7,j) .or. &
            t1_idx(2,i) == t23_idx(8,j) .or. t1_idx(2,i) == t23_idx(9,j) .or. &
            t1_idx(2,i) == t23_idx(10,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(7) = t1_idx(2,i)
        tmp_idx(2) = t23_idx(1,j)
        tmp_idx(3) = t23_idx(2,j)
        tmp_idx(4) = t23_idx(3,j)
        tmp_idx(5) = t23_idx(4,j)
        tmp_idx(6) = t23_idx(5,j)
        tmp_idx(8) = t23_idx(6,j)
        tmp_idx(9) = t23_idx(7,j)
        tmp_idx(10) = t23_idx(8,j)
        tmp_idx(11) = t23_idx(9,j)
        tmp_idx(12) = t23_idx(10,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,12,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t123(idx) = tmp
        t123_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo 

  ! Sort
  call sort_by_coef_idx(t123,t123_idx,sze_t123,12)

  ! Reorder the index of each t
  call reorder_t_idx(t123,t123_idx,sze_t123,12)

end  
#+end_src

** T2^2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t22_nb(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2
  double precision, intent(in)    :: thresh,t2(sze_t2)
  integer, intent(in)             :: t2_idx(4,sze_t2)

  ! out
  integer, intent(out)          :: sze_t22

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t2-1
    do j = i+1, sze_t2
      if (dabs(t2(i) * t2(j)) >= thresh) then
        if (t2_idx(1,i) == t2_idx(1,j) .or. t2_idx(1,i) == t2_idx(2,j) .or. &
            t2_idx(2,i) == t2_idx(1,j) .or. t2_idx(2,i) == t2_idx(2,j) .or. &
            t2_idx(3,i) == t2_idx(3,j) .or. t2_idx(3,i) == t2_idx(4,j) .or. &
            t2_idx(4,i) == t2_idx(3,j) .or. t2_idx(4,i) == t2_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t22 = idx
        
end

subroutine contrib_t22(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2,sze_t22
  double precision, intent(in)    :: thresh,t2(sze_t2)
  integer, intent(in)             :: t2_idx(4,sze_t2)

  ! out
  double precision, intent(out)   :: t22(sze_t22)
  integer, intent(out)            :: t22_idx(8,sze_t22)
  
  integer :: i,j,idx
  
  idx = 1
  do i = 1, sze_t2-1
    do j = i+1, sze_t2
      if (dabs(t2(i) * t2(j)) >= thresh) then
        if (t2_idx(1,i) == t2_idx(1,j) .or. t2_idx(1,i) == t2_idx(2,j) .or. &
            t2_idx(2,i) == t2_idx(1,j) .or. t2_idx(2,i) == t2_idx(2,j) .or. &
            t2_idx(3,i) == t2_idx(3,j) .or. t2_idx(3,i) == t2_idx(4,j) .or. &
            t2_idx(4,i) == t2_idx(3,j) .or. t2_idx(4,i) == t2_idx(4,j)) cycle
        t22(idx) = t2(i) * t2(j)
        t22_idx(1,idx) = t2_idx(1,i)
        t22_idx(2,idx) = t2_idx(2,i)
        t22_idx(5,idx) = t2_idx(3,i)
        t22_idx(6,idx) = t2_idx(4,i)
        t22_idx(3,idx) = t2_idx(1,j)
        t22_idx(4,idx) = t2_idx(2,j)
        t22_idx(7,idx) = t2_idx(3,j)
        t22_idx(8,idx) = t2_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t22,t22_idx,sze_t22,8)

  ! Reorder the index of each t
  call reorder_t_idx(t22,t22_idx,sze_t22,8)
  
end  
#+end_src

** T2^2 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t22_full_nb(nO,nV,thresh1,thresh2,sze_t2,t2,t2_idx,sze_t22)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2
  double precision, intent(in)    :: thresh1,thresh2,t2(sze_t2)
  integer, intent(in)             :: t2_idx(4,sze_t2)

  ! out
  integer, intent(out)          :: sze_t22

  integer :: i,j,idx,ia,ib, tmp_idx(8)
  double precision :: coef(1), acc, tmp
  integer, external :: get_index_in_psi_det_alpha_unique
  integer, external :: get_index_in_psi_det_beta_unique
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique
  integer(bit_kind) :: det(N_int,2)
  logical :: ok

  acc = 0d0
  idx = 0
  do i = 1, sze_t2-1
    do j = i+1, sze_t2
      tmp = t2(i) * t2(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t2_idx(1,i) == t2_idx(1,j) .or. t2_idx(1,i) == t2_idx(2,j) .or. &
            t2_idx(2,i) == t2_idx(1,j) .or. t2_idx(2,i) == t2_idx(2,j) .or. &
            t2_idx(3,i) == t2_idx(3,j) .or. t2_idx(3,i) == t2_idx(4,j) .or. &
            t2_idx(4,i) == t2_idx(3,j) .or. t2_idx(4,i) == t2_idx(4,j)) cycle
        ! idx to det
        tmp_idx(1) = t2_idx(1,i)
        tmp_idx(2) = t2_idx(2,i)
        tmp_idx(5) = t2_idx(3,i)
        tmp_idx(6) = t2_idx(4,i)
        tmp_idx(3) = t2_idx(1,j)
        tmp_idx(4) = t2_idx(2,j)
        tmp_idx(7) = t2_idx(3,j)
        tmp_idx(8) = t2_idx(4,j)
        call build_det_t((/0d0/),tmp_idx,1,8,det,coef)
        ! index in the wf alpha/beta
        !ia = get_index_in_psi_det_alpha_unique(det(1,1),N_int)
        !!if (ia == 0) cycle
        !ib = get_index_in_psi_det_beta_unique (det(1,2),N_int)
        !print*,ia, is_in_psi_det_alpha_unique(det(1,1))
        !print*,ib, is_in_psi_det_beta_unique(det(1,2))
        !
        !!if (ib == 0 ) cycle
        !if (ia /= 0 .and. .not. is_in_psi_det_alpha_unique(det(1,1))) then
        !   print*,'pb a'
        !   call abort
        !endif
        !if (ib /= 0 .and. .not. is_in_psi_det_beta_unique(det(1,2))) then
        !   print*,'pb b'
        !   call abort
        !endif
        !if (ia > n_det_alpha_unique .or. ib > n_det_beta_unique) then
        !   print*,ia,ib
        !   print*,'pb'
        !   cycle
        !   call abort
        !endif
        !if (ia == 0) cycle
        !if (ib == 0 ) cycle
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        acc = acc + tmp**2
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t22 = idx
        
end

subroutine contrib_t22_full(nO,nV,thresh1,thresh2,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2,sze_t22
  double precision, intent(in)    :: thresh1,thresh2,t2(sze_t2)
  integer, intent(in)             :: t2_idx(4,sze_t2)

  ! out
  double precision, intent(out)   :: t22(sze_t22)
  integer, intent(out)            :: t22_idx(8,sze_t22)
  
  integer(bit_kind)  :: det(N_int,2)
  integer, external:: get_index_in_psi_det_alpha_unique
  integer, external:: get_index_in_psi_det_beta_unique
  logical, external:: is_in_psi_det_alpha_unique
  logical, external:: is_in_psi_det_beta_unique
  integer :: i,j,idx,ia,ib,tmp_idx(8)
  double precision :: coef(1), tmp
  
  idx = 1
  do i = 1, sze_t2-1
    do j = i+1, sze_t2
      tmp = t2(i) * t2(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t2_idx(1,i) == t2_idx(1,j) .or. t2_idx(1,i) == t2_idx(2,j) .or. &
            t2_idx(2,i) == t2_idx(1,j) .or. t2_idx(2,i) == t2_idx(2,j) .or. &
            t2_idx(3,i) == t2_idx(3,j) .or. t2_idx(3,i) == t2_idx(4,j) .or. &
            t2_idx(4,i) == t2_idx(3,j) .or. t2_idx(4,i) == t2_idx(4,j)) cycle
        tmp_idx(1) = t2_idx(1,i)
        tmp_idx(2) = t2_idx(2,i)
        tmp_idx(5) = t2_idx(3,i)
        tmp_idx(6) = t2_idx(4,i)
        tmp_idx(3) = t2_idx(1,j)
        tmp_idx(4) = t2_idx(2,j)
        tmp_idx(7) = t2_idx(3,j)
        tmp_idx(8) = t2_idx(4,j)
        call build_det_t((/0d0/),tmp_idx,1,8,det,coef)
        ! index in the wf alpha/beta
        !ia = get_index_in_psi_det_alpha_unique(det(1,1),N_int)
        !!if (ia == 0) cycle
        !ib = get_index_in_psi_det_beta_unique (det(1,2),N_int)
        !!if (ib == 0 ) cycle
        !print*,ia, is_in_psi_det_alpha_unique(det(1,1))
        !print*,ib, is_in_psi_det_beta_unique(det(1,2))
        !
        !!if (ib == 0 ) cycle
        !if (ia /= 0 .and. .not. is_in_psi_det_alpha_unique(det(1,1))) then
        !   print*,'pb a'
        !   call abort
        !endif
        !if (ib /= 0 .and. .not. is_in_psi_det_beta_unique(det(1,2))) then
        !   print*,'pb b'
        !   call abort
        !endif
        !if (ia > n_det_alpha_unique .or. ib > n_det_beta_unique) then
        !   print*,ia,ib
        !   print*,'pb'
        !   cycle
        !   call abort
        !endif
        !if (ia == 0) cycle
        !if (ib == 0 ) cycle
        !if (.not. is_in_psi_det_alpha_unique(det(1,1))) cycle
        !if (.not. is_in_psi_det_beta_unique(det(1,2))) cycle
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t22(idx) = tmp
        t22_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t22,t22_idx,sze_t22,8)

  ! Reorder the index of each t
  call reorder_t_idx(t22,t22_idx,sze_t22,8)
  
end  
#+end_src

** T1^3
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t111_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx,sze_t111)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t11
  double precision, intent(in)    :: thresh,t1(sze_t1),t11(sze_t11)
  integer, intent(in)             :: t1_idx(2,sze_t1), t11_idx(4,sze_t11)

  ! out
  integer, intent(out)          :: sze_t111

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t11
      if (dabs(t1(i) * t11(j)) >= thresh) then
        !if (t1_idx(1,i) == t11_idx(1,j) .or. t1_idx(1,i) == t11_idx(2,j) .or. &
        !    t1_idx(2,i) == t11_idx(3,j) .or. t1_idx(2,i) == t11_idx(4,j)) cycle
        if (t1_idx(1,i) >= t11_idx(1,j) .or. t1_idx(2,i) == t11_idx(3,j) .or. &
            t1_idx(2,i) == t11_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  !idx=0
  !do i = 1, sze_t1-2
  !  do j = i+1, sze_t1-1
  !    do k = j+1, sze_t1
  !      if (dabs(t1(i) * t1(j) * t1(k)) >= thresh) then
  !      if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(1,i) == t1_idx(1,k) .or. &
  !          t1_idx(2,i) == t1_idx(2,j) .or. t1_idx(2,i) == t1_idx(2,k) .or. &
  !          t1_idx(1,j) == t1_idx(1,k) .or. t1_idx(2,j) == t1_idx(2,k) ) cycle
  !      idx = idx + 1
  !      endif
  !    enddo
  !  enddo
  !enddo

  sze_t111 = idx

end

subroutine contrib_t111(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx, &
     sze_t111,t111,t111_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t11,sze_t111
  double precision, intent(in)    :: thresh,t1(sze_t1),t11(sze_t11)
  integer, intent(in)             :: t1_idx(2,sze_t1),t11_idx(4,sze_t11)

  ! out
  double precision, intent(out)   :: t111(sze_t111)
  integer, intent(out)            :: t111_idx(6,sze_t111)
  
  integer :: i,j,idx

  idx = 1
  !fact = 1d0/3d0
  do i = 1, sze_t1
    do j = 1, sze_t11
      if (dabs(t1(i) * t11(j)) >= thresh) then
        !if (t1_idx(1,i) == t11_idx(1,j) .or. t1_idx(1,i) == t11_idx(2,j) .or. &
        !    t1_idx(2,i) == t11_idx(3,j) .or. t1_idx(2,i) == t11_idx(4,j)) cycle
        if (t1_idx(1,i) >= t11_idx(1,j) .or. t1_idx(2,i) == t11_idx(3,j) .or. &
            t1_idx(2,i) == t11_idx(4,j)) cycle
        t111(idx) = t1(i) * t11(j) !* fact
        t111_idx(1,idx) = t1_idx(1,i)
        t111_idx(4,idx) = t1_idx(2,i)
        t111_idx(2,idx) = t11_idx(1,j)
        t111_idx(3,idx) = t11_idx(2,j)
        t111_idx(5,idx) = t11_idx(3,j)
        t111_idx(6,idx) = t11_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  !do i = 1, sze_t1-2
  !  do j = i+1, sze_t1-1
  !    do k = j+1, sze_t1
  !      if (dabs(t1(i) * t1(j) * t1(k)) >= thresh) then
  !      if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(1,i) == t1_idx(1,k) .or. &
  !          t1_idx(2,i) == t1_idx(2,j) .or. t1_idx(2,i) == t1_idx(2,k) .or. &
  !          t1_idx(1,j) == t1_idx(1,k) .or. t1_idx(2,j) == t1_idx(2,k) ) cycle
  !      t111(idx) = t1(i) * t1(j) * t1(k)
  !      t111_idx(1,idx) = t1_idx(1,i)
  !      t111_idx(4,idx) = t1_idx(2,i)
  !      t111_idx(2,idx) = t1_idx(1,j)
  !      t111_idx(5,idx) = t1_idx(2,j)
  !      t111_idx(3,idx) = t1_idx(1,k)
  !      t111_idx(6,idx) = t1_idx(2,k)
  !      !print*,t111(idx)
  !      !print*,t1_idx(:,i),t1_idx(:,j),t1_idx(:,k)
  !      !print*,t111_idx(:,idx)
  !      idx = idx + 1
  !      endif
  !    enddo
  !  enddo
  !enddo
         
  ! Sort
  call sort_by_coef_idx(t111,t111_idx,sze_t111,6)

  ! Reorder the index of each t
  call reorder_t_idx(t111,t111_idx,sze_t111,6)
  
end  
#+end_src

** T1^3 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t111_full_nb(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx,sze_t111)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t11
  double precision, intent(in)    :: thresh1,thresh2,t1(sze_t1),t11(sze_t11)
  integer, intent(in)             :: t1_idx(2,sze_t1), t11_idx(4,sze_t11)

  ! out
  integer, intent(out)          :: sze_t111

  integer :: i,j,idx,tmp_idx(6)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  acc = 0d0
  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t11
      tmp = t1(i) * t11(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        !if (t1_idx(1,i) == t11_idx(1,j) .or. t1_idx(1,i) == t11_idx(2,j) .or. &
        !    t1_idx(2,i) == t11_idx(3,j) .or. t1_idx(2,i) == t11_idx(4,j)) cycle
        if (t1_idx(1,i) >= t11_idx(1,j) .or. t1_idx(2,i) == t11_idx(3,j) .or. &
            t1_idx(2,i) == t11_idx(4,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(4) = t1_idx(2,i)
        tmp_idx(2) = t11_idx(1,j)
        tmp_idx(3) = t11_idx(2,j)
        tmp_idx(5) = t11_idx(3,j)
        tmp_idx(6) = t11_idx(4,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,6,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        acc = acc + tmp**2
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t111 = idx

end

subroutine contrib_t111_full(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx, &
     sze_t111,t111,t111_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t11,sze_t111
  double precision, intent(in)    :: thresh1,thresh2,t1(sze_t1),t11(sze_t11)
  integer, intent(in)             :: t1_idx(2,sze_t1),t11_idx(4,sze_t11)

  ! out
  double precision, intent(out)   :: t111(sze_t111)
  integer, intent(out)            :: t111_idx(6,sze_t111)
  
  integer :: i,j,idx,tmp_idx(6)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  !fact = 1d0/3d0
  do i = 1, sze_t1
    do j = 1, sze_t11
      tmp = t1(i) * t11(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) >= t11_idx(1,j) .or. t1_idx(2,i) == t11_idx(3,j) .or. &
            t1_idx(2,i) == t11_idx(4,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(4) = t1_idx(2,i)
        tmp_idx(2) = t11_idx(1,j)
        tmp_idx(3) = t11_idx(2,j)
        tmp_idx(5) = t11_idx(3,j)
        tmp_idx(6) = t11_idx(4,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,6,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t111(idx) = tmp
        t111_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
         
  ! Sort
  call sort_by_coef_idx(t111,t111_idx,sze_t111,6)

  ! Reorder the index of each t
  call reorder_t_idx(t111,t111_idx,sze_t111,6)
  
end  
#+end_src

** T1^2 T2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t112_nb(nO,nV,thresh,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx, &
     sze_t112)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t11,sze_t2
  double precision, intent(in) :: thresh,t11(sze_t11),t2(sze_t2)
  integer, intent(in)          :: t11_idx(4,sze_t11),t2_idx(4,sze_t2)

  ! out
  integer, intent(out)         :: sze_t112

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t11
    do j = 1, sze_t2
      if (dabs(t11(i) * t2(j)) >= thresh) then
        if (t11_idx(1,i) == t2_idx(1,j) .or. t11_idx(1,i) == t2_idx(2,j) .or. &
            t11_idx(2,i) == t2_idx(1,j) .or. t11_idx(2,i) == t2_idx(2,j) .or. &
            t11_idx(3,i) == t2_idx(3,j) .or. t11_idx(3,i) == t2_idx(4,j) .or. &
            t11_idx(4,i) == t2_idx(3,j) .or. t11_idx(4,i) == t2_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t112 = idx
  
end

subroutine contrib_t112(nO,nV,thresh,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx,&
     sze_t112,t112,t112_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t11,sze_t2,sze_t112
  double precision, intent(in)    :: thresh,t11(sze_t11),t2(sze_t2)
  integer, intent(in)             :: t11_idx(4,sze_t11),t2_idx(4,sze_t2)

  ! out
  double precision, intent(out)   :: t112(sze_t112)
  integer, intent(out)            :: t112_idx(8,sze_t112)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t11
    do j = 1, sze_t2
      if (dabs(t11(i) * t2(j)) >= thresh) then
        if (t11_idx(1,i) == t2_idx(1,j) .or. t11_idx(1,i) == t2_idx(2,j) .or. &
            t11_idx(2,i) == t2_idx(1,j) .or. t11_idx(2,i) == t2_idx(2,j) .or. &
            t11_idx(3,i) == t2_idx(3,j) .or. t11_idx(3,i) == t2_idx(4,j) .or. &
            t11_idx(4,i) == t2_idx(3,j) .or. t11_idx(4,i) == t2_idx(4,j)) cycle
        t112(idx) = t11(i) * t2(j)
        t112_idx(1,idx) = t11_idx(1,i)
        t112_idx(2,idx) = t11_idx(2,i)
        t112_idx(5,idx) = t11_idx(3,i)
        t112_idx(6,idx) = t11_idx(4,i)
        t112_idx(3,idx) = t2_idx(1,j)
        t112_idx(4,idx) = t2_idx(2,j)
        t112_idx(7,idx) = t2_idx(3,j)
        t112_idx(8,idx) = t2_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t112,t112_idx,sze_t112,8)

  ! Reorder the index of each t
  call reorder_t_idx(t112,t112_idx,sze_t112,8)
  
end  
#+end_src

** T1^2 T2 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t112_full_nb(nO,nV,thresh1,thresh2,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx, &
     sze_t112)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t11,sze_t2
  double precision, intent(in) :: thresh1,thresh2,t11(sze_t11),t2(sze_t2)
  integer, intent(in)          :: t11_idx(4,sze_t11),t2_idx(4,sze_t2)

  ! out
  integer, intent(out)         :: sze_t112

  integer :: i,j,idx, tmp_idx(8)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  acc = 0d0
  idx = 0
  do i = 1, sze_t11
    do j = 1, sze_t2
      tmp = t11(i) * t2(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t11_idx(1,i) == t2_idx(1,j) .or. t11_idx(1,i) == t2_idx(2,j) .or. &
            t11_idx(2,i) == t2_idx(1,j) .or. t11_idx(2,i) == t2_idx(2,j) .or. &
            t11_idx(3,i) == t2_idx(3,j) .or. t11_idx(3,i) == t2_idx(4,j) .or. &
            t11_idx(4,i) == t2_idx(3,j) .or. t11_idx(4,i) == t2_idx(4,j)) cycle
        ! Indexes
        tmp_idx(1) = t11_idx(1,i)
        tmp_idx(2) = t11_idx(2,i)
        tmp_idx(5) = t11_idx(3,i)
        tmp_idx(6) = t11_idx(4,i)
        tmp_idx(3) = t2_idx(1,j)
        tmp_idx(4) = t2_idx(2,j)
        tmp_idx(7) = t2_idx(3,j)
        tmp_idx(8) = t2_idx(4,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,8,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        acc = acc + tmp**2
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t112 = idx

end

subroutine contrib_t112_full(nO,nV,thresh1,thresh2,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx,&
     sze_t112,t112,t112_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t11,sze_t2,sze_t112
  double precision, intent(in)    :: thresh1,thresh2,t11(sze_t11),t2(sze_t2)
  integer, intent(in)             :: t11_idx(4,sze_t11),t2_idx(4,sze_t2)

  ! out
  double precision, intent(out)   :: t112(sze_t112)
  integer, intent(out)            :: t112_idx(8,sze_t112)
  
  integer :: i,j,idx,tmp_idx(8)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  do i = 1, sze_t11
    do j = 1, sze_t2
      tmp = t11(i) * t2(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t11_idx(1,i) == t2_idx(1,j) .or. t11_idx(1,i) == t2_idx(2,j) .or. &
            t11_idx(2,i) == t2_idx(1,j) .or. t11_idx(2,i) == t2_idx(2,j) .or. &
            t11_idx(3,i) == t2_idx(3,j) .or. t11_idx(3,i) == t2_idx(4,j) .or. &
            t11_idx(4,i) == t2_idx(3,j) .or. t11_idx(4,i) == t2_idx(4,j)) cycle
        ! Indexes
        tmp_idx(1) = t11_idx(1,i)
        tmp_idx(2) = t11_idx(2,i)
        tmp_idx(5) = t11_idx(3,i)
        tmp_idx(6) = t11_idx(4,i)
        tmp_idx(3) = t2_idx(1,j)
        tmp_idx(4) = t2_idx(2,j)
        tmp_idx(7) = t2_idx(3,j)
        tmp_idx(8) = t2_idx(4,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,8,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t112(idx) = tmp
        t112_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t112,t112_idx,sze_t112,8)

  ! Reorder the index of each t
  call reorder_t_idx(t112,t112_idx,sze_t112,8)
  
end  
#+end_src

** T1^4
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t1111_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx,sze_t1111)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t111
  double precision, intent(in)    :: thresh,t1(sze_t1),t111(sze_t111)
  integer, intent(in)             :: t1_idx(2,sze_t1), t111_idx(6,sze_t111)

  ! out
  integer, intent(out)          :: sze_t1111

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t111
      if (dabs(t1(i) * t111(j)) >= thresh) then
        !if (t1_idx(1,i) == t111_idx(1,j) .or. t1_idx(1,i) == t111_idx(2,j) .or. &
        !    t1_idx(1,i) == t111_idx(3,j) .or. &
        !    t1_idx(2,i) == t111_idx(4,j) .or. t1_idx(2,i) == t111_idx(5,j) .or. &
        !    t1_idx(2,i) == t111_idx(6,j)) cycle
        if (t1_idx(1,i) >= t111_idx(1,j) .or. t1_idx(2,i) == t111_idx(4,j) .or. &
            t1_idx(2,i) == t111_idx(5,j) .or. t1_idx(2,i) == t111_idx(6,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t1111 = idx
        
end

subroutine contrib_t1111(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx, &
     sze_t1111,t1111,t1111_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t111,sze_t1111
  double precision, intent(in)    :: thresh,t1(sze_t1),t111(sze_t111)
  integer, intent(in)             :: t1_idx(2,sze_t1),t111_idx(6,sze_t111)

  ! out
  double precision, intent(out)   :: t1111(sze_t1111)
  integer, intent(out)            :: t1111_idx(8,sze_t1111)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t111
      if (dabs(t1(i) * t111(j)) >= thresh) then
        !if (t1_idx(1,i) == t111_idx(1,j) .or. t1_idx(1,i) == t111_idx(2,j) .or. &
        !    t1_idx(1,i) == t111_idx(3,j) .or. &
        !    t1_idx(2,i) == t111_idx(4,j) .or. t1_idx(2,i) == t111_idx(5,j) .or. &
        !    t1_idx(2,i) == t111_idx(6,j)) cycle
        if (t1_idx(1,i) >= t111_idx(1,j) .or. t1_idx(2,i) == t111_idx(4,j) .or. &
            t1_idx(2,i) == t111_idx(5,j) .or. t1_idx(2,i) == t111_idx(6,j)) cycle
        t1111(idx) = t1(i) * t111(j)
        t1111_idx(1,idx) = t1_idx(1,i)
        t1111_idx(5,idx) = t1_idx(2,i)
        t1111_idx(2,idx) = t111_idx(1,j)
        t1111_idx(3,idx) = t111_idx(2,j)
        t1111_idx(4,idx) = t111_idx(3,j)
        t1111_idx(6,idx) = t111_idx(4,j)
        t1111_idx(7,idx) = t111_idx(5,j)
        t1111_idx(8,idx) = t111_idx(6,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t1111,t1111_idx,sze_t1111,8)

  ! Reorder the index of each t
  call reorder_t_idx(t1111,t1111_idx,sze_t1111,8)
  
end  
#+end_src

** T1^4 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t1111_full_nb(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx,sze_t1111)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t111
  double precision, intent(in)    :: thresh1,thresh2,t1(sze_t1),t111(sze_t111)
  integer, intent(in)             :: t1_idx(2,sze_t1), t111_idx(6,sze_t111)

  ! out
  integer, intent(out)          :: sze_t1111

  integer :: i,j,idx,tmp_idx(8)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  acc = 0d0
  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t111
      tmp = t1(i) * t111(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) >= t111_idx(1,j) .or. t1_idx(2,i) == t111_idx(4,j) .or. &
            t1_idx(2,i) == t111_idx(5,j) .or. t1_idx(2,i) == t111_idx(6,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(5) = t1_idx(2,i)
        tmp_idx(2) = t111_idx(1,j)
        tmp_idx(3) = t111_idx(2,j)
        tmp_idx(4) = t111_idx(3,j)
        tmp_idx(6) = t111_idx(4,j)
        tmp_idx(7) = t111_idx(5,j)
        tmp_idx(8) = t111_idx(6,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,8,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        acc = acc + tmp**2
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t1111 = idx

end

subroutine contrib_t1111_full(nO,nV,thresh1,thresh2,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx, &
     sze_t1111,t1111,t1111_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t111,sze_t1111
  double precision, intent(in)    :: thresh1,thresh2,t1(sze_t1),t111(sze_t111)
  integer, intent(in)             :: t1_idx(2,sze_t1),t111_idx(6,sze_t111)

  ! out
  double precision, intent(out)   :: t1111(sze_t1111)
  integer, intent(out)            :: t1111_idx(8,sze_t1111)
  
  integer :: i,j,idx,tmp_idx(8)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t111
      tmp = t1(i) * t111(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t1_idx(1,i) >= t111_idx(1,j) .or. t1_idx(2,i) == t111_idx(4,j) .or. &
            t1_idx(2,i) == t111_idx(5,j) .or. t1_idx(2,i) == t111_idx(6,j)) cycle
        ! Indexes
        tmp_idx(1) = t1_idx(1,i)
        tmp_idx(5) = t1_idx(2,i)
        tmp_idx(2) = t111_idx(1,j)
        tmp_idx(3) = t111_idx(2,j)
        tmp_idx(4) = t111_idx(3,j)
        tmp_idx(6) = t111_idx(4,j)
        tmp_idx(7) = t111_idx(5,j)
        tmp_idx(8) = t111_idx(6,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,8,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t1111(idx) = tmp
        t1111_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t1111,t1111_idx,sze_t1111,8)

  ! Reorder the index of each t
  call reorder_t_idx(t1111,t1111_idx,sze_t1111,8)
  
end  
#+end_src

** T2^3
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t222_nb(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx,sze_t222)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2,sze_t22
  double precision, intent(in)    :: thresh,t2(sze_t2),t22(sze_t22)
  integer, intent(in)             :: t2_idx(4,sze_t2), t22_idx(8,sze_t22)

  ! out
  integer, intent(out)          :: sze_t222

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t2
    do j = 1, sze_t22
      if (dabs(t2(i) * t22(j)) >= thresh) then
        if (t2_idx(1,i) >= t22_idx(1,j) .or. t2_idx(1,i) == t22_idx(2,j) .or. &
            t2_idx(1,i) == t22_idx(3,j) .or. t2_idx(1,i) == t22_idx(4,j) .or. &
            t2_idx(2,i) == t22_idx(1,j) .or. t2_idx(2,i) == t22_idx(2,j) .or. &
            t2_idx(2,i) == t22_idx(3,j) .or. t2_idx(2,i) == t22_idx(4,j) .or. &
            t2_idx(3,i) == t22_idx(5,j) .or. t2_idx(3,i) == t22_idx(6,j) .or. &
            t2_idx(3,i) == t22_idx(7,j) .or. t2_idx(3,i) == t22_idx(8,j) .or. &
            t2_idx(4,i) == t22_idx(5,j) .or. t2_idx(4,i) == t22_idx(6,j) .or. &
            t2_idx(4,i) == t22_idx(7,j) .or. t2_idx(4,i) == t22_idx(8,j)) cycle
         idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t222 = idx
  
end

subroutine contrib_t222(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx, &
     sze_t222,t222,t222_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2,sze_t22,sze_t222
  double precision, intent(in)    :: thresh,t2(sze_t2),t22(sze_t22)
  integer, intent(in)             :: t2_idx(4,sze_t2),t22_idx(8,sze_t22)

  ! out
  double precision, intent(out)   :: t222(sze_t222)
  integer, intent(out)            :: t222_idx(12,sze_t222)
  
  integer :: i,j,idx
  double precision :: fact

  idx = 1
  fact = 1d0/3d0
  do i = 1, sze_t2
    do j = 1, sze_t22
      if (dabs(t2(i) * t22(j)) >= thresh) then
        if (t2_idx(1,i) >= t22_idx(1,j) .or. t2_idx(1,i) == t22_idx(2,j) .or. &
            t2_idx(1,i) == t22_idx(3,j) .or. t2_idx(1,i) == t22_idx(4,j) .or. &
            t2_idx(2,i) == t22_idx(1,j) .or. t2_idx(2,i) == t22_idx(2,j) .or. &
            t2_idx(2,i) == t22_idx(3,j) .or. t2_idx(2,i) == t22_idx(4,j) .or. &
            t2_idx(3,i) == t22_idx(5,j) .or. t2_idx(3,i) == t22_idx(6,j) .or. &
            t2_idx(3,i) == t22_idx(7,j) .or. t2_idx(3,i) == t22_idx(8,j) .or. &
            t2_idx(4,i) == t22_idx(5,j) .or. t2_idx(4,i) == t22_idx(6,j) .or. &
            t2_idx(4,i) == t22_idx(7,j) .or. t2_idx(4,i) == t22_idx(8,j)) cycle
         t222(idx) = t2(i) * t22(j) !* fact
         t222_idx(1,idx) = t2_idx(1,i)
         t222_idx(2,idx) = t2_idx(2,i)
         t222_idx(7,idx) = t2_idx(3,i)
         t222_idx(8,idx) = t2_idx(4,i)
         t222_idx(3,idx) = t22_idx(1,j)
         t222_idx(4,idx) = t22_idx(2,j)
         t222_idx(5,idx) = t22_idx(3,j)
         t222_idx(6,idx) = t22_idx(4,j)
         t222_idx(9,idx) = t22_idx(5,j)
         t222_idx(10,idx) = t22_idx(6,j)
         t222_idx(11,idx) = t22_idx(7,j)
         t222_idx(12,idx) = t22_idx(8,j)
         idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t222,t222_idx,sze_t222,12)

  ! Reorder the index of each t
  call reorder_t_idx(t222,t222_idx,sze_t222,12)
  
end  
#+end_src

** T2^3 fill square
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t222_full_nb(nO,nV,thresh1,thresh2,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx,sze_t222)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2,sze_t22
  double precision, intent(in)    :: thresh1,thresh2,t2(sze_t2),t22(sze_t22)
  integer, intent(in)             :: t2_idx(4,sze_t2), t22_idx(8,sze_t22)

  ! out
  integer, intent(out)          :: sze_t222

  integer :: i,j,idx,tmp_idx(12)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  acc = 0d0
  idx = 0
  do i = 1, sze_t2
    do j = 1, sze_t22
      tmp = t2(i) * t22(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t2_idx(1,i) >= t22_idx(1,j) .or. t2_idx(1,i) == t22_idx(2,j) .or. &
            t2_idx(1,i) == t22_idx(3,j) .or. t2_idx(1,i) == t22_idx(4,j) .or. &
            t2_idx(2,i) == t22_idx(1,j) .or. t2_idx(2,i) == t22_idx(2,j) .or. &
            t2_idx(2,i) == t22_idx(3,j) .or. t2_idx(2,i) == t22_idx(4,j) .or. &
            t2_idx(3,i) == t22_idx(5,j) .or. t2_idx(3,i) == t22_idx(6,j) .or. &
            t2_idx(3,i) == t22_idx(7,j) .or. t2_idx(3,i) == t22_idx(8,j) .or. &
            t2_idx(4,i) == t22_idx(5,j) .or. t2_idx(4,i) == t22_idx(6,j) .or. &
            t2_idx(4,i) == t22_idx(7,j) .or. t2_idx(4,i) == t22_idx(8,j)) cycle
         ! Indexes
         tmp_idx(1) = t2_idx(1,i)
         tmp_idx(2) = t2_idx(2,i)
         tmp_idx(7) = t2_idx(3,i)
         tmp_idx(8) = t2_idx(4,i)
         tmp_idx(3) = t22_idx(1,j)
         tmp_idx(4) = t22_idx(2,j)
         tmp_idx(5) = t22_idx(3,j)
         tmp_idx(6) = t22_idx(4,j)
         tmp_idx(9) = t22_idx(5,j)
         tmp_idx(10) = t22_idx(6,j)
         tmp_idx(11) = t22_idx(7,j)
         tmp_idx(12) = t22_idx(8,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,12,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        acc = acc + tmp**2
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t222 = idx

end

subroutine contrib_t222_full(nO,nV,thresh1,thresh2,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx, &
     sze_t222,t222,t222_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2,sze_t22,sze_t222
  double precision, intent(in)    :: thresh1,thresh2,t2(sze_t2),t22(sze_t22)
  integer, intent(in)             :: t2_idx(4,sze_t2),t22_idx(8,sze_t22)

  ! out
  double precision, intent(out)   :: t222(sze_t222)
  integer, intent(out)            :: t222_idx(12,sze_t222)
  
  integer :: i,j,idx,tmp_idx(12)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  idx = 1
  do i = 1, sze_t2
    do j = 1, sze_t22
      tmp = t2(i) * t22(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t2_idx(1,i) >= t22_idx(1,j) .or. t2_idx(1,i) == t22_idx(2,j) .or. &
            t2_idx(1,i) == t22_idx(3,j) .or. t2_idx(1,i) == t22_idx(4,j) .or. &
            t2_idx(2,i) == t22_idx(1,j) .or. t2_idx(2,i) == t22_idx(2,j) .or. &
            t2_idx(2,i) == t22_idx(3,j) .or. t2_idx(2,i) == t22_idx(4,j) .or. &
            t2_idx(3,i) == t22_idx(5,j) .or. t2_idx(3,i) == t22_idx(6,j) .or. &
            t2_idx(3,i) == t22_idx(7,j) .or. t2_idx(3,i) == t22_idx(8,j) .or. &
            t2_idx(4,i) == t22_idx(5,j) .or. t2_idx(4,i) == t22_idx(6,j) .or. &
            t2_idx(4,i) == t22_idx(7,j) .or. t2_idx(4,i) == t22_idx(8,j)) cycle
         ! Indexes
         tmp_idx(1) = t2_idx(1,i)
         tmp_idx(2) = t2_idx(2,i)
         tmp_idx(7) = t2_idx(3,i)
         tmp_idx(8) = t2_idx(4,i)
         tmp_idx(3) = t22_idx(1,j)
         tmp_idx(4) = t22_idx(2,j)
         tmp_idx(5) = t22_idx(3,j)
         tmp_idx(6) = t22_idx(4,j)
         tmp_idx(9) = t22_idx(5,j)
         tmp_idx(10) = t22_idx(6,j)
         tmp_idx(11) = t22_idx(7,j)
         tmp_idx(12) = t22_idx(8,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,12,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t222(idx) = tmp
        t222_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t222,t222_idx,sze_t222,12)

  ! Reorder the index of each t
  call reorder_t_idx(t222,t222_idx,sze_t222,12)
  
end  
#+end_src

** T3^2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t33_nb(nO,nV,thresh,sze_t3,t3,t3_idx,sze_t33)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t3
  double precision, intent(in)    :: thresh,t3(sze_t3)
  integer, intent(in)             :: t3_idx(6,sze_t3)

  ! out
  integer, intent(out)          :: sze_t33

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t3-1
    do j = i+1, sze_t3
      if (dabs(t3(i) * t3(j)) >= thresh) then
        if (t3_idx(1,i) == t3_idx(1,j) .or. t3_idx(1,i) == t3_idx(2,j) .or. &
            t3_idx(1,i) == t3_idx(3,j) .or. &
            t3_idx(2,i) == t3_idx(1,j) .or. t3_idx(2,i) == t3_idx(2,j) .or. &
            t3_idx(2,i) == t3_idx(3,j) .or. &
            t3_idx(3,i) == t3_idx(1,j) .or. t3_idx(3,i) == t3_idx(2,j) .or. &
            t3_idx(3,i) == t3_idx(3,j) .or. &
            t3_idx(4,i) == t3_idx(4,j) .or. t3_idx(4,i) == t3_idx(5,j) .or. &
            t3_idx(4,i) == t3_idx(6,j) .or. &
            t3_idx(5,i) == t3_idx(4,j) .or. t3_idx(5,i) == t3_idx(5,j) .or. &
            t3_idx(5,i) == t3_idx(6,j) .or. &
            t3_idx(6,i) == t3_idx(4,j) .or. t3_idx(6,i) == t3_idx(5,j) .or. &
            t3_idx(6,i) == t3_idx(6,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t33 = idx
        
end

subroutine contrib_t33(nO,nV,thresh,sze_t3,t3,t3_idx,sze_t33,t33,t33_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t3,sze_t33
  double precision, intent(in)    :: thresh,t3(sze_t3)
  integer, intent(in)             :: t3_idx(6,sze_t3)

  ! out
  double precision, intent(out)   :: t33(sze_t33)
  integer, intent(out)            :: t33_idx(12,sze_t33)
  
  integer :: i,j,idx
  
  idx = 1
  do i = 1, sze_t3-1
    do j = i+1, sze_t3
      if (dabs(t3(i) * t3(j)) >= thresh) then
        if (t3_idx(1,i) == t3_idx(1,j) .or. t3_idx(1,i) == t3_idx(2,j) .or. &
            t3_idx(1,i) == t3_idx(3,j) .or. &
            t3_idx(2,i) == t3_idx(1,j) .or. t3_idx(2,i) == t3_idx(2,j) .or. &
            t3_idx(2,i) == t3_idx(3,j) .or. &
            t3_idx(3,i) == t3_idx(1,j) .or. t3_idx(3,i) == t3_idx(2,j) .or. &
            t3_idx(3,i) == t3_idx(3,j) .or. &
            t3_idx(4,i) == t3_idx(4,j) .or. t3_idx(4,i) == t3_idx(5,j) .or. &
            t3_idx(4,i) == t3_idx(6,j) .or. &
            t3_idx(5,i) == t3_idx(4,j) .or. t3_idx(5,i) == t3_idx(5,j) .or. &
            t3_idx(5,i) == t3_idx(6,j) .or. &
            t3_idx(6,i) == t3_idx(4,j) .or. t3_idx(6,i) == t3_idx(5,j) .or. &
            t3_idx(6,i) == t3_idx(6,j)) cycle
        t33(idx) = t3(i) * t3(j)
        t33_idx(1,idx) = t3_idx(1,i)
        t33_idx(2,idx) = t3_idx(2,i)
        t33_idx(3,idx) = t3_idx(3,i)
        t33_idx(7,idx) = t3_idx(4,i)
        t33_idx(8,idx) = t3_idx(5,i)
        t33_idx(9,idx) = t3_idx(6,i)
        t33_idx(4,idx) = t3_idx(1,j)
        t33_idx(5,idx) = t3_idx(2,j)
        t33_idx(6,idx) = t3_idx(3,j)
        t33_idx(10,idx) = t3_idx(4,j)
        t33_idx(11,idx) = t3_idx(5,j)
        t33_idx(12,idx) = t3_idx(6,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t33,t33_idx,sze_t33,12)

  ! Reorder the index of each t
  call reorder_t_idx(t33,t33_idx,sze_t33,12)
  
end  
#+end_src

** T3^2 square filler
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t33_full_nb(nO,nV,thresh1,thresh2,sze_t3,t3,t3_idx,sze_t33)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t3
  double precision, intent(in)    :: thresh1,thresh2,t3(sze_t3)
  integer, intent(in)             :: t3_idx(6,sze_t3)

  ! out
  integer, intent(out)          :: sze_t33

  integer :: i,j,idx,tmp_idx(12)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique

  acc = 0d0
  idx = 0
  do i = 1, sze_t3-1
    do j = i+1, sze_t3
      tmp = t3(i) * t3(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t3_idx(1,i) == t3_idx(1,j) .or. t3_idx(1,i) == t3_idx(2,j) .or. &
            t3_idx(1,i) == t3_idx(3,j) .or. &
            t3_idx(2,i) == t3_idx(1,j) .or. t3_idx(2,i) == t3_idx(2,j) .or. &
            t3_idx(2,i) == t3_idx(3,j) .or. &
            t3_idx(3,i) == t3_idx(1,j) .or. t3_idx(3,i) == t3_idx(2,j) .or. &
            t3_idx(3,i) == t3_idx(3,j) .or. &
            t3_idx(4,i) == t3_idx(4,j) .or. t3_idx(4,i) == t3_idx(5,j) .or. &
            t3_idx(4,i) == t3_idx(6,j) .or. &
            t3_idx(5,i) == t3_idx(4,j) .or. t3_idx(5,i) == t3_idx(5,j) .or. &
            t3_idx(5,i) == t3_idx(6,j) .or. &
            t3_idx(6,i) == t3_idx(4,j) .or. t3_idx(6,i) == t3_idx(5,j) .or. &
            t3_idx(6,i) == t3_idx(6,j)) cycle
        ! Indexes
        tmp_idx(1) = t3_idx(1,i)
        tmp_idx(2) = t3_idx(2,i)
        tmp_idx(3) = t3_idx(3,i)
        tmp_idx(7) = t3_idx(4,i)
        tmp_idx(8) = t3_idx(5,i)
        tmp_idx(9) = t3_idx(6,i)
        tmp_idx(4) = t3_idx(1,j)
        tmp_idx(5) = t3_idx(2,j)
        tmp_idx(6) = t3_idx(3,j)
        tmp_idx(10) = t3_idx(4,j)
        tmp_idx(11) = t3_idx(5,j)
        tmp_idx(12) = t3_idx(6,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,12,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        acc = acc + 0d0
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t33 = idx

end

subroutine contrib_t33_full(nO,nV,thresh1,thresh2,sze_t3,t3,t3_idx,&
     sze_t33,t33,t33_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t3,sze_t33
  double precision, intent(in)    :: thresh1,thresh2,t3(sze_t3)
  integer, intent(in)             :: t3_idx(6,sze_t3)

  ! out
  double precision, intent(out)   :: t33(sze_t33)
  integer, intent(out)            :: t33_idx(12,sze_t33)
  
  integer :: i,j,idx,tmp_idx(12)
  double precision :: acc, tmp, coef(1)
  integer(bit_kind) :: det(N_int,2)
  logical, external :: is_in_psi_det_alpha_unique
  logical, external :: is_in_psi_det_beta_unique
  
  idx = 1
  do i = 1, sze_t3-1
    do j = i+1, sze_t3
      tmp = t3(i) * t3(j)
      if (dabs(tmp) >= thresh1) cycle
      if (dabs(tmp) >= thresh2) then
        if (t3_idx(1,i) == t3_idx(1,j) .or. t3_idx(1,i) == t3_idx(2,j) .or. &
            t3_idx(1,i) == t3_idx(3,j) .or. &
            t3_idx(2,i) == t3_idx(1,j) .or. t3_idx(2,i) == t3_idx(2,j) .or. &
            t3_idx(2,i) == t3_idx(3,j) .or. &
            t3_idx(3,i) == t3_idx(1,j) .or. t3_idx(3,i) == t3_idx(2,j) .or. &
            t3_idx(3,i) == t3_idx(3,j) .or. &
            t3_idx(4,i) == t3_idx(4,j) .or. t3_idx(4,i) == t3_idx(5,j) .or. &
            t3_idx(4,i) == t3_idx(6,j) .or. &
            t3_idx(5,i) == t3_idx(4,j) .or. t3_idx(5,i) == t3_idx(5,j) .or. &
            t3_idx(5,i) == t3_idx(6,j) .or. &
            t3_idx(6,i) == t3_idx(4,j) .or. t3_idx(6,i) == t3_idx(5,j) .or. &
            t3_idx(6,i) == t3_idx(6,j)) cycle
        ! Indexes
        tmp_idx(1) = t3_idx(1,i)
        tmp_idx(2) = t3_idx(2,i)
        tmp_idx(3) = t3_idx(3,i)
        tmp_idx(7) = t3_idx(4,i)
        tmp_idx(8) = t3_idx(5,i)
        tmp_idx(9) = t3_idx(6,i)
        tmp_idx(4) = t3_idx(1,j)
        tmp_idx(5) = t3_idx(2,j)
        tmp_idx(6) = t3_idx(3,j)
        tmp_idx(10) = t3_idx(4,j)
        tmp_idx(11) = t3_idx(5,j)
        tmp_idx(12) = t3_idx(6,j)
        ! Det
        call build_det_t((/0d0/),tmp_idx,1,12,det,coef)
        ! Is in alpha C beta
        if (.not. is_in_psi_det_alpha_unique(det(1,1),N_int)) cycle
        if (.not. is_in_psi_det_beta_unique(det(1,2),N_int)) cycle
        t33(idx) = tmp
        t33_idx(:,idx) = tmp_idx(:)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t33,t33_idx,sze_t33,12)

  ! Reorder the index of each t
  call reorder_t_idx(t33,t33_idx,sze_t33,12)
  
end  
#+end_src


** Search det
#+begin_src f90 :comments org :tangle search_det.irp.f
logical function is_in_psi_det_alpha_unique(key,Nint)
  use bitmasks
  BEGIN_DOC
  ! Returns theis the determinant is in the :c:data:`psi_det_alpha_unique` array
  END_DOC
  implicit none

  integer, intent(in)            :: Nint
  integer(bit_kind), intent(in)  :: key(Nint)

  integer                        :: i, ibegin, iend, istep, l
  integer(8)                     :: det_ref, det_search
  integer(8), external           :: spin_det_search_key
  logical                        :: in_wavefunction

  in_wavefunction = .False.
  is_in_psi_det_alpha_unique = .False.
  ibegin = 1
  iend   = N_det_alpha_unique + 1

  !DIR$ FORCEINLINE
  det_ref = spin_det_search_key(key,Nint)

  !DIR$ FORCEINLINE
  det_search = spin_det_search_key(psi_det_alpha_unique(1,1),Nint)

  istep = shiftr(iend-ibegin,1)
  i=ibegin+istep
  do while (istep > 0)
    !DIR$ FORCEINLINE
    det_search = spin_det_search_key(psi_det_alpha_unique(1,i),Nint)
    if ( det_search > det_ref ) then
      iend = i
    else if ( det_search == det_ref ) then
      exit
    else
      ibegin = i
    endif
    istep = shiftr(iend-ibegin,1)
    i = ibegin + istep
  end do

  !DIR$ FORCEINLINE
  do while (spin_det_search_key(psi_det_alpha_unique(1,i),Nint) == det_ref)
    i = i-1
    if (i == 0) then
      exit
    endif
  enddo
  i += 1

  !DIR$ FORCEINLINE
  do while (spin_det_search_key(psi_det_alpha_unique(1,i),Nint) == det_ref)
    if (key(1) /= psi_det_alpha_unique(1,i)) then
      continue
    else
      in_wavefunction = .True.
      !DIR$ IVDEP
      !DIR$ LOOP COUNT MIN(3)
      do l=2,Nint
        if (key(l) /= psi_det_alpha_unique(l,i)) then
          in_wavefunction = .False.
        endif
      enddo
      if (in_wavefunction) then
        is_in_psi_det_alpha_unique = .True.
        return
      endif
    endif
    i += 1
    if (i > N_det_alpha_unique) then
        is_in_psi_det_alpha_unique = .False.
      return
    endif

  enddo

  is_in_psi_det_alpha_unique = in_wavefunction

end

logical function is_in_psi_det_beta_unique(key,Nint)
  use bitmasks
  BEGIN_DOC
  ! Returns if the determinant in the :c:data:`psi_det_beta_unique` array
  END_DOC
  implicit none

  integer, intent(in)            :: Nint
  integer(bit_kind), intent(in)  :: key(Nint)

  integer                        :: i, ibegin, iend, istep, l
  integer(8)                     :: det_ref, det_search
  integer(8), external           :: spin_det_search_key
  logical                        :: in_wavefunction

  in_wavefunction = .False.
  is_in_psi_det_beta_unique = in_wavefunction
  ibegin = 1
  iend   = N_det_beta_unique + 1

  !DIR$ FORCEINLINE
  det_ref = spin_det_search_key(key,Nint)
  !DIR$ FORCEINLINE
  det_search = spin_det_search_key(psi_det_beta_unique(1,1),Nint)

  istep = shiftr(iend-ibegin,1)
  i=ibegin+istep
  do while (istep > 0)
    !DIR$ FORCEINLINE
    det_search = spin_det_search_key(psi_det_beta_unique(1,i),Nint)
    if ( det_search > det_ref ) then
      iend = i
    else if ( det_search == det_ref ) then
      exit
    else
      ibegin = i
    endif
    istep = shiftr(iend-ibegin,1)
    i = ibegin + istep
  end do

  !DIR$ FORCEINLINE
  do while (spin_det_search_key(psi_det_beta_unique(1,i),Nint) == det_ref)
    i = i-1
    if (i == 0) then
      exit
    endif
  enddo
  i += 1

  !DIR$ FORCEINLINE
  do while (spin_det_search_key(psi_det_beta_unique(1,i),Nint) == det_ref)
    if (key(1) /= psi_det_beta_unique(1,i)) then
      continue
    else
      in_wavefunction = .True.
      !DIR$ IVDEP
      !DIR$ LOOP COUNT MIN(3)
      do l=2,Nint
        if (key(l) /= psi_det_beta_unique(l,i)) then
          in_wavefunction = .False.
        endif
      enddo
      if (in_wavefunction) then
         is_in_psi_det_beta_unique = .True.
        return
      endif
    endif
    i += 1
    if (i > N_det_beta_unique) then
         is_in_psi_det_beta_unique = .False.
      return
    endif

  enddo

  is_in_psi_det_beta_unique = in_wavefunction
  
end

!function is_in_psi_det_alpha_unique(det_a)
!
!  implicit none
!
!  integer(bit_kind), intent(in) :: det_a(N_int)
!  logical :: is_in_psi_det_alpha_unique
!  integer :: i,j,count
!
!  is_in_psi_det_alpha_unique = .False.
!
!  do j = 1, N_det_alpha_unique
!    count = 0
!    do i = 1, N_int
!      if (psi_det_alpha_unique(i,j) == det_a(i)) then
!        count = count + 1
!      endif
!    enddo
!    if (count == N_int) then
!      is_in_psi_det_alpha_unique = .True.
!      return
!    endif
!  enddo
!  
!end
!
!
!function is_in_psi_det_beta_unique(det_b)
!
!  implicit none
!
!  integer(bit_kind), intent(in) :: det_b(N_int)
!  logical :: is_in_psi_det_beta_unique
!  integer :: i,j,count
!
!  is_in_psi_det_beta_unique = .False.
!
!  do j = 1, N_det_beta_unique
!    count = 0
!    do i = 1, N_int
!      if (psi_det_beta_unique(i,j) == det_b(i)) then
!        count = count + 1
!      endif
!    enddo
!    if (count == N_int) then
!      is_in_psi_det_beta_unique = .True.
!      return
!    endif
!  enddo
!  
!end

#+end_src
