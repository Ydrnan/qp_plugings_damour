* Clsuetr decomposition

#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
program cc_to_ci
  implicit none

  BEGIN_DOC
  ! To compute the ci coeffcients from the CCSD/CCSD(T) amplitudes
  END_DOC

  integer :: nO,nV
  double precision,allocatable :: t1(:,:),t2(:,:,:,:)

  read_wf = .True.
  touch read_wf
  
  nO = cc_nOab
  nV = cc_nVab

  allocate(t1(nO,nV),t2(nO,nO,nV,nV))

  call read_t1(nO,nV,t1)
  call read_t2(nO,nV,t2)
  
  call smart_xc(nO,nV,t1,t2)
  
end
#+end_src

** Test
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine smart_xc(nO,nV,t1_full,t2_full)

  implicit none

  integer, intent(in) ::nO,nV
  double precision, intent(in) :: t1_full(nO,nV), t2_full(nO,nO,nV,nV)

  integer :: i,j,k,l,a,b,c,d
  double precision, allocatable :: t1(:), t2(:), t11(:)
  double precision, allocatable :: t111(:), t12(:)
  double precision, allocatable :: t1111(:), t112(:), t22(:)
  integer, allocatable :: tmp_idx(:,:), t1_idx(:,:), t2_idx(:,:), t11_idx(:,:)
  integer, allocatable :: t111_idx(:,:), t12_idx(:,:)
  integer, allocatable :: t1111_idx(:,:), t112_idx(:,:), t22_idx(:,:)
  integer :: sze_t1, sze_t11, sze_t2, sze_t111, sze_t12
  integer :: sze_t1111, sze_t112, sze_t22
  integer :: new_sze_t11, new_sze_t22
  integer :: new_sze_t12, new_sze_t112, new_sze_t111,new_sze_t1111
  logical :: must_exit, all_t1, all_t2
  integer :: sze_t222, new_sze_t222
  double precision, allocatable :: t222(:)
  integer, allocatable :: t222_idx(:,:)
  integer, allocatable :: c1_idx(:,:), c2_idx(:,:), c3_idx(:,:), c4_idx(:,:), c6_idx(:,:)
  double precision, allocatable :: c1(:), c2(:), c3(:), c4(:), c6(:)
  integer :: sze_c1, sze_c2, sze_c3, sze_c4, sze_c6
  integer :: new_sze_c2, new_sze_c3, new_sze_c4, new_sze_c6
  double precision, allocatable :: f_o(:), f_v(:), f_oo(:,:), f_vv(:,:)
  double precision, allocatable :: v_ooov(:,:,:,:), v_vvvo(:,:,:,:)
  double precision, allocatable :: t3(:)
  integer, allocatable :: t3_idx(:,:)
  integer :: sze_t3
  integer :: sze_t13, new_sze_t13
  double precision, allocatable :: t13(:)
  integer, allocatable :: t13_idx(:,:)
  integer(bit_kind), allocatable :: c1_det(:,:,:), c2_det(:,:,:)
  integer(bit_kind), allocatable :: c3_det(:,:,:), c4_det(:,:,:), c6_det(:,:,:)
  double precision, allocatable :: c1_coef(:), c2_coef(:), c3_coef(:), c4_coef(:), c6_coef(:)
  integer :: sze_cc
  integer(bit_kind), allocatable :: psi_det_cc(:,:,:)
  double precision, allocatable :: psi_coef_cc(:)



  double precision ::phase,norm
  integer(bit_kind) :: det(N_int,2)
  integer :: degree
  double precision :: energy
  double precision :: thresh, thresh_t1
  double precision :: s2_val
  double precision :: f_norm
  integer          :: count, sze, sze_max, idx

  all_t1 = .True.

  ! Thresh
  thresh = thresh_extract_c

  if (all_t1) then
    thresh_t1 = 1d-16
  else
    thresh_t1 = thresh
  endif

  ! T
  ! t1
  print*,'T1'
  call contrib_t1_nb(nO,nV,thresh_t1,t1_full,sze_t1)
  print*, sze_t1
  allocate(t1(sze_t1),t1_idx(2,sze_t1))
  call contrib_t1(nO,nV,thresh_t1,t1_full,sze_t1,t1,t1_idx)
  
  ! t2
  print*,'T2'
  call contrib_t2_nb(nO,nV,thresh,t2_full,sze_t2)
  print*,sze_t2
  allocate(t2(sze_t2),t2_idx(4,sze_t2))
  call contrib_t2(nO,nV,thresh,t2_full,sze_t2,t2,t2_idx)

  ! T3 from (T)
  ! Only for canonical orbitals !!!
  if (use_par_t) then
    allocate(f_oo(nO,nO),f_vv(nV,nV),f_o(nO),f_v(nV))
    allocate(v_ooov(nO,nO,nO,nV),v_vvvo(nV,nV,nV,nO))
    
    ! Fock elements
    call gen_f_spin(psi_det(1,1,cc_ref), cc_nO_m,cc_nO_m, cc_nO_S,cc_nO_S, cc_list_occ_spin,cc_list_occ_spin, nO,nO, f_oo)
    call gen_f_spin(psi_det(1,1,cc_ref), cc_nV_m,cc_nV_m, cc_nV_S,cc_nV_S, cc_list_vir_spin,cc_list_vir_spin, nV,nV, f_vv)

    ! Diag elements
    do i = 1, nO
      f_o(i) = f_oo(i,i)
    enddo
    do i = 1, nV
      f_v(i) = f_vv(i,i)
    enddo

    ! Load int for (T)
    call gen_v_spin(cc_nO_m,cc_nO_m,cc_nO_m,cc_nV_m, &
         cc_nO_S,cc_nO_S,cc_nO_S,cc_nV_S, &
         cc_list_occ_spin,cc_list_occ_spin,cc_list_occ_spin,cc_list_vir_spin, &
         nO,nO,nO,nV, v_ooov)
    
    call gen_v_spin(cc_nV_m,cc_nV_m,cc_nV_m,cc_nO_m, &
         cc_nV_S,cc_nV_S,cc_nV_S,cc_nO_S, &
         cc_list_vir_spin,cc_list_vir_spin,cc_list_vir_spin,cc_list_occ_spin, &
         nV,nV,nV,nO, v_vvvo)

    ! t3
    call contrib_t3_nb(nO,nV,thresh,t1_full,t2_full,f_o,f_v, &
    v_ooov,v_vvvo,sze_t3)
    print*,sze_t3
    allocate(t3(sze_t3), t3_idx(6,sze_t3))
    call contrib_t3(nO,nV,thresh,t1_full,t2_full,f_o,f_v, &
    v_ooov,v_vvvo,sze_t3,t3,t3_idx)

  else
    sze_t3 = 1
    allocate(t3(sze_t3), t3_idx(6,sze_t3))
    sze_t3 = 0
  endif

  ! t11
  print*,'T1^2'
  call contrib_t11_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11)
  print*,sze_t11
  allocate(t11(sze_t11),t11_idx(4,sze_t11))
  call contrib_t11(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx)
        
  ! t12
  print*,'T1T2'
  call contrib_t12_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx,sze_t12)
  print*,sze_t12
  allocate(t12(sze_t12),t12_idx(6,sze_t12))
  call contrib_t12(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx, &
       sze_t12,t12,t12_idx)
  
  ! t13
  if (use_par_t) then
    print*,'T1T3'
    call contrib_t13_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,&
       sze_t13)
    print*,sze_t13
    allocate(t13(sze_t13),t13_idx(8,sze_t13))
    call contrib_t13(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,&
       sze_t13,t13,t13_idx)
  else
     sze_t13 = 1
     allocate(t13(sze_t13),t13_idx(8,sze_t13))
     sze_t13 = 0
  endif
        
  ! t22
  print*,'T2^2'
  call contrib_t22_nb(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22)
  print*,sze_t22
  allocate(t22(sze_t22),t22_idx(8,sze_t22))
  call contrib_t22(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx)

  ! t23
  ! TODO

  ! t33
  ! TODO

  ! t111
  print*,'T1^3'
  call contrib_t111_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx,sze_t111)
  print*,sze_t111
  allocate(t111(sze_t111),t111_idx(6,sze_t111))
  call contrib_t111(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx, &
       sze_t111,t111,t111_idx)

  ! t112
  print*,'T1^2T2'
  call contrib_t112_nb(nO,nV,thresh,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx,&
     sze_t112)
  print*,sze_t112
  allocate(t112(sze_t112),t112_idx(8,sze_t112))
  call contrib_t112(nO,nV,thresh,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx,&
     sze_t112,t112,t112_idx)

  ! t113
  ! TODO

  ! t123
  ! TODO

  ! T2^3
  print*,'T2^3'
  call contrib_t222_nb(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx, &
     sze_t222)
  print*,sze_t222
  allocate(t222(sze_t222),t222_idx(12,sze_t222))
  call contrib_t222(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx, &
     sze_t222,t222,t222_idx)

  ! t1111
  print*,'T1^4'
  call contrib_t1111_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx, &
     sze_t1111)
  print*,sze_t1111
  allocate(t1111(sze_t1111),t1111_idx(8,sze_t1111))
  call contrib_t1111(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx, &
     sze_t1111,t1111,t1111_idx)

  ! Recursive sort after the reordering
  call recursive_sort_idx(t11,t11_idx,sze_t11,4,1)
  call recursive_sort_idx(t12,t12_idx,sze_t12,6,1)
  call recursive_sort_idx(t13,t13_idx,sze_t13,8,1)
  call recursive_sort_idx(t22,t22_idx,sze_t22,8,1)
  call recursive_sort_idx(t111,t111_idx,sze_t111,6,1)
  call recursive_sort_idx(t112,t112_idx,sze_t112,8,1)
  call recursive_sort_idx(t222,t222_idx,sze_t222,12,1)
  call recursive_sort_idx(t1111,t1111_idx,sze_t1111,8,1)
  
  ! Remove the duplicate and accumulate
  call remove_duplicate_idx(t11,t11_idx,sze_t11,4)
  call remove_duplicate_idx(t12,t12_idx,sze_t12,6)
  call remove_duplicate_idx(t13,t13_idx,sze_t13,8)
  call remove_duplicate_idx(t22,t22_idx,sze_t22,8)
  call remove_duplicate_idx(t111,t111_idx,sze_t111,6)
  call remove_duplicate_idx(t112,t112_idx,sze_t112,8)
  call remove_duplicate_idx(t222,t222_idx,sze_t222,12)
  call remove_duplicate_idx(t1111,t1111_idx,sze_t1111,8)
  
  print*,''
  write(*,'(A6,A10,A12)')     '     ', '  N'    , 'Norm' 
  write(*,'(A6,I10,1pE12.4)') 't1   ', sze_t1   , f_norm(t1   ,sze_t1   )
  write(*,'(A6,I10,1pE12.4)') 't2   ', sze_t2   , f_norm(t2   ,sze_t2   )
  write(*,'(A6,I10,1pE12.4)') 't3   ', sze_t3   , f_norm(t3   ,sze_t3   )
  write(*,'(A6,I10,1pE12.4)') 't11  ', sze_t11  , f_norm(t11  ,sze_t11  )
  write(*,'(A6,I10,1pE12.4)') 't12  ', sze_t12  , f_norm(t12  ,sze_t12  )
  write(*,'(A6,I10,1pE12.4)') 't13  ', sze_t13  , f_norm(t13  ,sze_t13  )
  write(*,'(A6,I10,1pE12.4)') 't111 ', sze_t111 , f_norm(t111 ,sze_t111 )
  write(*,'(A6,I10,1pE12.4)') 't22  ', sze_t22  , f_norm(t22  ,sze_t22  )
  write(*,'(A6,I10,1pE12.4)') 't112 ', sze_t112 , f_norm(t112 ,sze_t112 )
  write(*,'(A6,I10,1pE12.4)') 't222 ', sze_t222 , f_norm(t222 ,sze_t222 )
  write(*,'(A6,I10,1pE12.4)') 't1111', sze_t1111, f_norm(t1111,sze_t1111)
  
  ! Gather list with the same number of indexes
  sze_c1 = sze_t1
  sze_c2 = sze_t11 + sze_t2
  sze_c3 = sze_t111 + sze_t12 + sze_t3
  sze_c4 = sze_t1111 + sze_t112 + sze_t22 + sze_t13
  sze_c6 = sze_t222

  allocate(c1_idx(2,sze_c1), c2_idx(4,sze_c2))
  allocate(c3_idx(6,sze_c3))
  allocate(c4_idx(8,sze_c4))
  allocate(c6_idx(12,sze_c6))
  allocate(c1(sze_c1), c2(sze_c2))
  allocate(c3(sze_c3))
  allocate(c4(sze_c4))
  allocate(c6(sze_c6))

  ! C1
  ! t1
  do i = 1, sze_t1
    c1(i) = t1(i)
    c1_idx(:,i) = t1_idx(:,i)
  enddo

  ! C2
  ! t2
  do i = 1, sze_t2
    c2(i) = t2(i)
    c2_idx(:,i) = t2_idx(:,i)
  enddo
  k = sze_t2
  ! t11
  do i = 1, sze_t11
    c2(k+i) = t11(i)
    c2_idx(:,k+i) = t11_idx(:,i)
  enddo

  ! C3
  ! t12
  do i = 1, sze_t12
    c3(i) = t12(i)
    c3_idx(:,i) = t12_idx(:,i)
  enddo
  k = sze_t12
  ! t111
  do i = 1, sze_t111
    c3(k+i) = t111(i)
    c3_idx(:,k+i) = t111_idx(:,i)
  enddo
  k = k + sze_t111
  ! t3
  do i = 1, sze_t3
    c3(k+i) = t3(i)
    c3_idx(:,k+i) = t3_idx(:,i)
  enddo 

  ! C4
  ! t22
  do i = 1, sze_t22
    c4(i) = t22(i)
    c4_idx(:,i) = t22_idx(:,i)
  enddo
  k = sze_t22
  ! t112
  do i = 1, sze_t112
    c4(k+i) = t112(i)
    c4_idx(:,k+i) = t112_idx(:,i)
  enddo
  k = k + sze_t112
  ! t1111
  do i = 1, sze_t1111
    c4(k+i) = t1111(i)
    c4_idx(:,k+i) = t1111_idx(:,i)
  enddo
  k = k + sze_t1111
  ! t13
  do i = 1, sze_t13
    c4(k+i) = t13(i)
    c4_idx(:,k+i) = t13_idx(:,i)
  enddo

  ! C6
  ! t222
  do i = 1, sze_c6
    c6(i) = t222(i)
    c6_idx(:,i) = t222_idx(:,i)
  enddo
  
  ! Sort
  call recursive_sort_idx(c2,c2_idx,sze_c2,4,1)
  call recursive_sort_idx(c3,c3_idx,sze_c3,6,1)
  call recursive_sort_idx(c4,c4_idx,sze_c4,8,1)
  call recursive_sort_idx(c6,c6_idx,sze_c6,12,1)
  
  ! Remove the duplicate and accumulate
  call remove_duplicate_idx(c2,c2_idx,sze_c2,4)
  call remove_duplicate_idx(c3,c3_idx,sze_c3,6)
  call remove_duplicate_idx(c4,c4_idx,sze_c4,8)
  call remove_duplicate_idx(c6,c6_idx,sze_c6,12)

  print*,''
  write(*,'(A6,I10,1pE12.4)') 'C1   ', sze_c1, f_norm(c1,sze_c1)
  write(*,'(A6,I10,1pE12.4)') 'C2   ', sze_c2, f_norm(c2,sze_c2)
  write(*,'(A6,I10,1pE12.4)') 'C3   ', sze_c3, f_norm(c3,sze_c3)
  write(*,'(A6,I10,1pE12.4)') 'C4   ', sze_c4, f_norm(c4,sze_c4)
  write(*,'(A6,I10,1pE12.4)') 'C6   ', sze_c6, f_norm(c6,sze_c6)

  ! Build the determinants
  allocate(c1_det(N_int,2,sze_c1),c1_coef(sze_c1))
  allocate(c2_det(N_int,2,sze_c2),c2_coef(sze_c2))
  allocate(c3_det(N_int,2,sze_c3),c3_coef(sze_c3))
  allocate(c4_det(N_int,2,sze_c4),c4_coef(sze_c4))
  allocate(c6_det(N_int,2,sze_c6),c6_coef(sze_c6))

  call build_det_t(c1,c1_idx,sze_c1,2,c1_det,c1_coef)
  call build_det_t(c2,c2_idx,sze_c2,4,c2_det,c2_coef)
  call build_det_t(c3,c3_idx,sze_c3,6,c3_det,c3_coef)
  call build_det_t(c4,c4_idx,sze_c4,8,c4_det,c4_coef)
  call build_det_t(c6,c6_idx,sze_c6,12,c6_det,c6_coef)

  sze_cc = 1 + sze_c1 + sze_c2 + sze_c3 + sze_c4 + sze_c6

  allocate(psi_det_cc(N_int,2,sze_cc),psi_coef_cc(sze_cc))

  ! Ref
  psi_coef_cc(1) = 1d0
  psi_det_cc(:,:,1) = psi_det(:,:,cc_ref)

  ! C1
  k = 1
  do i = 1, sze_c1
    psi_coef_cc(k+i) = c1_coef(i)
    psi_det_cc(:,:,k+i) = c1_det(:,:,i)
  enddo

  ! C2
  k = k + sze_c1
  do i = 1, sze_c2
    psi_coef_cc(k+i) = c2_coef(i)
    psi_det_cc(:,:,k+i) = c2_det(:,:,i)
  enddo

  ! C3
  k = k + sze_c2
  do i = 1, sze_c3
    psi_coef_cc(k+i) = c3_coef(i)
    psi_det_cc(:,:,k+i) = c3_det(:,:,i)
  enddo
  
  ! C4
  k = k + sze_c3
  do i = 1, sze_c4
    psi_coef_cc(k+i) = c4_coef(i)
    psi_det_cc(:,:,k+i) = c4_det(:,:,i)
  enddo

  ! C6
  k = k + sze_c4
  do i = 1, sze_c6
    psi_coef_cc(k+i) = c6_coef(i)
    psi_det_cc(:,:,k+i) = c6_det(:,:,i)
  enddo

  write(*,'(A6,I10,1pE12.4)') ' Psi  ', sze_cc, f_norm(psi_coef_cc, sze_cc)

  ! Phase
  norm = 1d0
  det(:,:) = psi_det_cc(:,:,1)
  do i = 2, sze_cc
    !call print_det(psi_det_cc(1,1,i),N_int)
    call get_phase_general(det,psi_det_cc(1,1,i),phase,degree,N_int)
    psi_coef_cc(i) = psi_coef_cc(i) * phase
    norm = norm + psi_coef_cc(i)**2
  enddo
  
  call i_H_psi(psi_det_cc(1,1,1),psi_det_cc,psi_coef_cc,N_int,sze_cc,sze_cc,1,energy)
  print*,''
  print*,'<0|H|Psi> =',energy+nuclear_repulsion

  ! Normalization
  norm = 1d0/dsqrt(norm)
  do i = 1, sze_cc
    psi_coef_cc(i) = psi_coef_cc(i) * norm
  enddo
  
  ! Sort by ci coef
  call sort_by_coef_det(psi_coef_cc,psi_det_cc,sze_cc,N_int)
  !do i = sze_cc, 1, -1
  !   call print_det(psi_det_cc(1,1,i),N_int)
  !   call print_det(psi_det(1,1,i),N_int)
  !   print*,psi_coef_cc(i),psi_coef(i,1),psi_coef_cc(i)-psi_coef(i,1)
  !enddo

  ! Overlap
  !call overlap_wf_safe(sze_cc,psi_det_cc,psi_coef_cc)
  call overlap_fast(psi_det,psi_coef,N_states,N_det,psi_det_cc,psi_coef_cc,1,sze_cc)

  ! S^2
  call u_0_S2_u_0(s2_val,psi_coef_cc,sze_cc,psi_det_cc,N_int,1,sze_cc)
  print*,''
  print*,'S^2 =', s2_val
  print*,''
  
  ! Save wf
  call save_wf_cc(psi_det_cc,psi_coef_cc,sze_cc)
  !touch psi_det psi_coef N_det 

  print*,''
  print*,'<Psi|H|Psi>/<Psi|Psi> =',psi_energy+nuclear_repulsion
  print*,''
  
end
#+end_src

** Reorder t_idx
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine reorder_t_idx(t,t_idx,sze_t,n_idx)
 
  implicit none

  BEGIN_DOC
  ! Order the indexes of each t
  END_DOC

  integer, intent(in) :: sze_t, n_idx
  integer, intent(inout) :: t_idx(n_idx,sze_t)
  double precision, intent(inout) :: t(sze_t)
  
  integer :: i,j,k,o,s
  integer, allocatable :: tmp_t_idx(:,:), p_f(:), idx(:), p_i(:), iorder(:)
  double precision, allocatable :: tmp_t(:)
  double precision :: sign
  integer :: dist, n_cross, n_pairs

  do i = 1, sze_t
    sign = 1d0
    call reorder_t_idx_rec(t_idx(1,i),n_idx/2,sign,1)
    call reorder_t_idx_rec(t_idx(n_idx/2+1,i),n_idx/2,sign,1)
    t(i) = t(i) * sign
  enddo

  return
  
  allocate(tmp_t(sze_t), tmp_t_idx(n_idx,sze_t),idx(n_idx/2))
  allocate(iorder(n_idx/2))
  
  do i = 1, sze_t
    ! Sort of the idx
    dist = 0
    n_cross = 0
    ! Loop over occ and vir spin orbitals
    do o = 1, 2
      if (o == 2) then
         s = n_idx/2
      else
         s = 0
      endif
         
      do j = 1, n_idx/2
        idx(j) = t_idx(s+j,i)
        iorder(j) = j
      enddo
      call isort(idx,iorder,n_idx/2)

      ! "Distance"
      n_pairs = 0
      do j = 1, n_idx/2
        dist = dist + abs(iorder(j) - j)
        if (abs(iorder(j) - j) /= 0) then
          n_pairs = n_pairs + 1
        endif
      enddo
      
      !allocate(p_f(n_pairs),p_i(n_pairs))
      !k = 1
      !do j = 1, n_idx/2
      !  if (abs(iorder(j) - j) /= 0) then
      !    p_i(k) = min(j,iorder(j))
      !    p_f(k) = max(j,iorder(j))
      !    k = k + 1
      !  endif
      !enddo
 
      !! Crossing : ...p_i(j) ... p_i(k) ... p_f(j) ... p_f(k)...
      !do j = 1, n_pairs
      !  do k = j+1, n_pairs
      !    print*,'p',p_i(j),p_i(k),p_f(j),p_f(k)
      !    if ( ( p_f(k) > p_f(j) ) .and. ( p_i(k) < p_f(j) ) .and. ( p_i(k) > p_i(j) ) ) then
      !      n_cross = n_cross + 1
      !    endif
      !  enddo
      !enddo
      !deallocate(p_f,p_i)

      do j = 1, n_idx/2
        tmp_t_idx(s+j,i) = idx(j)
      enddo
    enddo
    ! Final sign
    !print*,'1',t_idx(:,i)
    !print*,'2',tmp_t_idx(:,i)
    sign = dble((-1)**(dist/2))!+n_cross))
    !print*,dist,sign
    tmp_t(i) = t(i) * sign
  enddo

  ! Apply changes
  do i = 1, sze_t
    t(i) = tmp_t(i)
    t_idx(:,i) = tmp_t_idx(:,i)
    !print*,i,t_idx(:,i)
  enddo
    
  deallocate(tmp_t,tmp_t_idx,idx)
  
end

recursive subroutine reorder_t_idx_rec(t_idx,nb_idx,sign,idx)

  implicit none

  integer, intent(in) :: nb_idx,idx
  integer, intent(inout) :: t_idx(nb_idx)
  double precision, intent(inout) :: sign
  integer :: tmp,i

  if (idx < nb_idx) then
    if (t_idx(idx) > t_idx(idx+1)) then
      tmp = t_idx(idx)
      t_idx(idx) = t_idx(idx+1)
      t_idx(idx+1) = tmp
      sign = - sign
      if (idx > 1) then
        i = idx - 1
      else
        i = idx + 1
      endif
    else
      i = idx + 1
    endif
    call reorder_t_idx_rec(t_idx,nb_idx,sign,i)
  else
    return
  endif
 
end
#+end_src

** Build det
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine build_det_t(t,t_idx,sze_t,n_idx,psi_det_t,psi_coef_t)

  implicit none

  integer, intent(in) :: sze_t, n_idx, t_idx(n_idx,sze_t)
  double precision, intent(in) :: t(sze_t)

  integer(bit_kind), intent(out) :: psi_det_t(N_int,2,sze_t)
  double precision, intent(out) :: psi_coef_t(sze_t)

  integer :: i,j,k
  integer :: s,h,p
  logical :: ok
  integer(bit_kind) :: det(N_int,2),res(N_int,2)  
  
  do i = 1, sze_t
    det(:,:) = psi_det(:,:,cc_ref)
    !print*,t_idx(:,i)
    
    ! Holes
    do j = 1, n_idx/2
      h = t_idx(j,i)
      if (h > cc_nOa) then
        h = h - cc_nOa
        s = 2
      else
        s = 1
      endif
      h = cc_list_occ_spin(h,s)
      !call print_det(det,N_int)
      call apply_hole(det,s,h,res,ok,N_int)
      if (.not. ok) then
        print*,'big problem h'
        print*,t_idx(:,i)
        print*,t_idx(j,i),s,h
        call abort
      endif
      det = res
    enddo

    ! Particles
    do j = n_idx/2+1, n_idx
      p = t_idx(j,i)
      if (p > cc_nVa) then
        p = p - cc_nVa
        s = 2
      else
        s = 1
      endif
      p = cc_list_vir_spin(p,s)
      !p = p + cc_nO_S(s)
      !p = p + n_core_orb
      call apply_particle(det,s,p,res,ok,N_int)
      if (.not. ok) then
        print*,'big problem p'
        call abort
      endif
      det = res
    enddo
    psi_det_t(:,:,i) = det(:,:)
    psi_coef_t(i) = t(i)
    !call print_det(det,N_int)
    !print*,psi_coef_t(i),psi_det_t(1,1,i),psi_det_t(1,2,i)
  enddo

end
#+end_src

** Det way
*** Sort det
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine sort_det(psi_det_t,psi_coef_t,sze)

  implicit none

  integer, intent(in) :: sze
  integer(bit_kind), intent(inout) :: psi_det_t(N_int,2,sze)
  double precision, intent(inout) :: psi_coef_t(sze)

  integer(bit_kind), allocatable :: tmp_psi_det(:,:,:), tmp_psi_det_a(:,:), tmp_det_b(:,:)
  double precision, allocatable :: tmp_psi_coef(:), tmp_coef(:)
  integer, allocatable :: iorder(:), border(:), n_da(:)
  integer(bit_kind) :: da(1)

  integer :: i,j,k,l,o, n_da_unique, degree
  
  if (N_int /= 1) then
    print*,'N_int /= 1, abort'
    call abort
  endif

  allocate(tmp_psi_coef(sze),tmp_psi_det(1,2,sze))
  
  allocate(iorder(sze),tmp_psi_det_a(N_int,sze))

  do i = 1, sze
    tmp_psi_det_a(1,i) = psi_det_t(1,1,i)
    iorder(i) = i
  enddo

  call i8sort(tmp_psi_det_a,iorder,sze)

  do i = 1, sze
    tmp_psi_coef(i) = psi_coef_t(iorder(i))
    tmp_psi_det(1,1,i) = psi_det_t(1,1,iorder(i))
    tmp_psi_det(1,2,i) = psi_det_t(1,2,iorder(i))
  enddo
  do i = 1, sze
    psi_coef_t(i) = tmp_psi_coef(i)    
    psi_det_t(1,1,i) = tmp_psi_det(1,1,i)
    psi_det_t(1,2,i) = tmp_psi_det(1,2,i)
  enddo
  tmp_psi_det = 0
  tmp_psi_coef = 0d0

  allocate(n_da(sze))
  n_da = 0
  n_da_unique = 1
  n_da(1) = 1 
  da = tmp_psi_det_a(1,1)
  do i = 2, sze
    call get_excitation_degree_spin(tmp_psi_det_a(1,i),da,degree,N_int)
    if (degree /= 0) then
      da = tmp_psi_det_a(1,i)
      n_da_unique = n_da_unique + 1
      n_da(n_da_unique) = n_da(n_da_unique) + 1
    else
      n_da(n_da_unique) = n_da(n_da_unique) + 1
    endif
  enddo

  k = 1
  l = 1
  do i = 1, n_da_unique
    allocate(tmp_det_b(1,n_da(i)),border(n_da(i)),tmp_coef(n_da(i)))
    do j = 1, n_da(i)
      tmp_det_b(1,j) = psi_det_t(1,2,k)
      !print*, tmp_det_b(1,j)
      tmp_coef(j) = psi_coef_t(k)
      border(j) = j
      k = k + 1
    enddo

    call i8sort(tmp_det_b,border,n_da(i))
    !print*,'b',tmp_det_b
    !print*,''

    ! no need of tmp arrays
    do j = 1, n_da(i)
      psi_det_t(1,2,l) = tmp_det_b(1,j)
      psi_coef_t(l) = tmp_coef(border(j))
      l = l + 1
    enddo
    deallocate(tmp_det_b,border,tmp_coef)
  enddo

  ! Check
  !print*,''
  !do i = 1, sze
  !  print*,psi_coef_t(i),psi_det_t(1,1,i),psi_det_t(1,2,i)
  !  !call print_det(psi_det_t(1,1,i),N_int)
  !enddo
  
end
#+end_src

*** Remove duplicate det
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine remove_duplicate_det(psi_det_t,psi_coef_t,sze_t)

  implicit none

  integer, intent(inout) :: sze_t
  integer(bit_kind) , intent(inout) :: psi_det_t(N_int,2,sze_t)
  double precision, intent(inout) :: psi_coef_t(sze_t)

  integer(bit_kind), allocatable :: tmp_det(:,:,:)
  double precision, allocatable :: tmp_coef(:)
  integer(bit_kind) :: det(N_int,2)

  integer :: i,j,k,l,idx,new_sze_t
  logical :: is_eq

  allocate(tmp_det(N_int,2,sze_t),tmp_coef(sze_t))

  idx = 1
  tmp_det(:,:,idx) = psi_det_t(:,:,1)
  tmp_coef(idx) = psi_coef_t(1)
  do i = 2, sze_t
    is_eq = .True.
    do j = 1, 2
      do k = 1, N_int
        if (tmp_det(k,j,idx) /= psi_det_t(k,j,i)) then
           is_eq = .False.
        endif
      enddo
    enddo
    if (is_eq) then
       tmp_coef(idx) = tmp_coef(idx) + psi_coef_t(i)
    else
       idx = idx + 1
       tmp_coef(idx) = psi_coef_t(i)
       tmp_det(:,:,idx) = psi_det_t(:,:,i)
    endif
  enddo

  new_sze_t = idx

  do i = 1, new_sze_t
    psi_coef_t(i) = tmp_coef(i)
    psi_det_t(:,:,i) = tmp_det(:,:,i)
  enddo
  do i = new_sze_t+1, sze_t
    psi_coef_t(i) = 0d0
    psi_det_t(:,:,i) = 0
  enddo

  sze_t = new_sze_t
  
end
#+end_src

** idx way
*** Recursive sort t_idx
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
recursive subroutine recursive_sort_idx(t,t_idx,sze,n_idx,idx)

  implicit none

  integer, intent(in) :: sze,n_idx,idx
  integer, intent(inout) :: t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer :: i,j,k,l,val,nb_u
  integer, allocatable :: tmp(:),tmp_idx(:,:),iorder(:),nu(:),pu(:)
  double precision, allocatable :: tmp_t(:)

  if (sze == 0) return

  if (idx < n_idx) then

    ! Sort
    call multiple_idx_sort(t,t_idx,sze,n_idx,idx)

    allocate(pu(sze),nu(sze))
    ! Unique, nb and position
    call search_unique_idx(t_idx,sze,n_idx,idx,nb_u,nu,pu)

    do i = 1, nb_u
      call recursive_sort_idx(t(pu(i)),t_idx(1,pu(i)),nu(i),n_idx,idx+1)
    enddo
    deallocate(pu,nu)

  else

    ! Sort
    call multiple_idx_sort(t,t_idx,sze,n_idx,idx)

  endif

end
#+end_src

*** sort
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine multiple_idx_sort(t,t_idx,sze,n_idx,idx)

  implicit none

  integer, intent(in) :: sze,n_idx,idx
  integer, intent(inout) :: t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer :: i,j,k,l,val
  integer, allocatable :: tmp(:),tmp_idx(:,:),iorder(:)
  double precision, allocatable :: tmp_t(:)

  ! Sort
  allocate(tmp(sze),tmp_idx(n_idx,sze),tmp_t(sze),iorder(sze))

  do i = 1, sze
    tmp(i) = t_idx(idx,i)
    tmp_idx(:,i) = t_idx(:,i)
    tmp_t(i) = t(i)
    iorder(i) = i
  enddo

  call isort(tmp,iorder,sze)

  do i = 1, sze
    t_idx(:,i) = tmp_idx(:,iorder(i))
    t(i) = tmp_t(iorder(i))
  enddo
  
  deallocate(tmp,tmp_idx,tmp_t,iorder)
end
#+end_src

*** Unique
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine search_unique_idx(t_idx,sze,n_idx,idx,nb_u,nu,pu)

  implicit none

  integer, intent(in) :: sze,n_idx,idx
  integer, intent(in) :: t_idx(n_idx,sze)

  integer, intent(out) :: nb_u, nu(sze), pu(sze)

  integer :: i,j,k,l,val
  double precision, allocatable :: tmp_t(:)
  
  ! Unique, nb and position
  k = 1
  pu = 0 ! starting position
  nu = 0 ! nb
  pu(1) = 1
  nu(1) = 1
  val = t_idx(idx,1) 
  do i = 2, sze
    if (val /= t_idx(idx,i)) then
      k = k + 1
      pu(k) = i
      nu(k) = nu(k) + 1
      val = t_idx(idx,i)
    else
      nu(k) = nu(k) + 1
    endif
  enddo

  nb_u = k

end
#+end_src

*** Remove duplicate
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine remove_duplicate_idx(t,t_idx,sze,n_idx)

  implicit none

  integer, intent(in) :: n_idx
  integer, intent(inout) :: sze,t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer :: new_sze
  integer :: i,j,k,l
  integer, allocatable :: idx(:), tmp_idx(:,:)
  double precision, allocatable :: tmp_coef(:)
  logical :: is_eq

  new_sze = 0
  if (sze == 0) return
  
  allocate(idx(n_idx),tmp_idx(n_idx,sze),tmp_coef(sze))

  ! Init
  tmp_idx = 0
  tmp_coef = 0d0

  k = 1
  idx(:) = t_idx(:,1)
  tmp_idx(:,1) = idx(:)
  tmp_coef(1) = t(1)
  
  do i = 2, sze

    !print*,''
    !print*,idx(:)
    !print*,t_idx(:,i)
    ! Same indexes ?
    is_eq = .True.
    do j = 1, n_idx
      if (idx(j) /= t_idx(j,i)) then
        is_eq = .False.
        exit
      endif
    enddo
    !print*,is_eq
    
    ! Accumulate the duplicates
    if (is_eq) then
      tmp_coef(k) = tmp_coef(k) + t(i)
    else
      k = k + 1
      tmp_coef(k) = t(i)
      idx(:) = t_idx(:,i)
      tmp_idx(:,k) = idx(:)
    endif
    
  enddo

  new_sze = k

  ! Copy
  do i = 1, new_sze
    t(i) = tmp_coef(i)
    t_idx(:,i) = tmp_idx(:,i)
  enddo

  ! Nullify the remaining elements
  do i = new_sze+1, sze
    t(i) = 0d0
    t_idx(:,i) = 0
  enddo

  sze = new_sze

  deallocate(idx,tmp_idx,tmp_coef)

end
#+end_src

** Sort by coef
*** idx
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine sort_by_coef_idx(t,t_idx,sze,n_idx)

  implicit none

  integer, intent(in) :: sze,n_idx
  integer, intent(inout) :: t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer :: i,j,k,l,val
  integer, allocatable :: tmp_idx(:,:),iorder(:)
  double precision, allocatable :: tmp_t(:), tmp(:)

  if (sze == 0) return
  
  ! Sort
  allocate(tmp(sze),tmp_idx(n_idx,sze),tmp_t(sze),iorder(sze))

  do i = 1, sze
    tmp(i) = -dabs(t(i))
    tmp_idx(:,i) = t_idx(:,i)
    tmp_t(i) = t(i)
    iorder(i) = i
  enddo

  call dsort(tmp,iorder,sze)

  do i = 1, sze
    !print*,tmp(i)
    t_idx(:,i) = tmp_idx(:,iorder(i))
    t(i) = tmp_t(iorder(i))
  enddo
  
  deallocate(tmp,tmp_idx,tmp_t,iorder)
end
#+end_src

*** det
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine sort_by_coef_det(psi_coef_t,psi_det_t,sze,Nint)

  use bitmasks
  
  implicit none

  integer, intent(in) :: sze,Nint
  integer(bit_kind), intent(inout) :: psi_det_t(Nint,2,sze)
  double precision, intent(inout) :: psi_coef_t(sze)

  integer :: i,j,k,l,val
  integer(bit_kind), allocatable :: tmp_det(:,:,:)
  integer, allocatable :: iorder(:)
  double precision, allocatable :: tmp_coef(:), tmp(:)

  ! Sort
  allocate(tmp(sze),tmp_det(Nint,2,sze),tmp_coef(sze),iorder(sze))

  do i = 1, sze
    tmp(i) = -dabs(psi_coef_t(i))
    tmp_det(:,:,i) = psi_det_t(:,:,i)
    tmp_coef(i) = psi_coef_t(i)
    iorder(i) = i
  enddo

  call dsort(tmp,iorder,sze)

  do i = 1, sze
    !print*,tmp(i)
    psi_det_t(:,:,i) = tmp_det(:,:,iorder(i))
    psi_coef_t(i) = tmp_coef(iorder(i))
  enddo
  
  deallocate(tmp,tmp_det,tmp_coef,iorder)
end
#+end_src

** Norm
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
function f_norm(v,sze)

  implicit none

  integer, intent(in) :: sze
  double precision, intent(in) :: v(sze)
  double precision :: f_norm
  integer :: i

  f_norm = 0d0
  
  do i = 1, sze
    f_norm = f_norm + v(i)**2
  enddo

end
#+end_src


** T1
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t1_nb(nO,nV,thresh,t1_full,sze_t1)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV
  double precision, intent(in)    :: thresh, t1_full(nO,nV)

  ! out
  integer, intent(out)          :: sze_t1

  integer :: i,a,idx

  ! t1
  idx = 0
  do a = 1, nV
    do i = 1, nO
      if (dabs(t1_full(i,a)) >= thresh) then
        if (i > cc_nOa .and. a <= cc_nVa) cycle
        if (i <= cc_nOa .and. a > cc_nVa) cycle
        idx = idx + 1
      endif
    enddo
  enddo

  sze_t1 = idx

end

subroutine contrib_t1(nO,nV,thresh,t1_full,sze_t1,t1,t1_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1
  double precision, intent(in)    :: thresh,t1_full(nO,nV)

  ! out
  double precision, intent(out)   :: t1(sze_t1)
  integer, intent(out)            :: t1_idx(2,sze_t1)
  
  integer :: i,a,idx
  double precision :: thresh_t1
  
  idx = 1
  do a = 1, nV
    do i = 1, nO
      if (dabs(t1_full(i,a)) >= thresh) then
        if (i > cc_nOa .and. a <= cc_nVa) cycle
        if (i <= cc_nOa .and. a > cc_nVa) cycle
        t1(idx) = t1_full(i,a)
        t1_idx(1,idx) = i
        t1_idx(2,idx) = a
        idx = idx + 1
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t1,t1_idx,sze_t1,2)

end  
#+end_src

** T2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t2_nb(nO,nV,thresh,t2_full,sze_t2)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV
  double precision, intent(in)    :: thresh, t2_full(nO,nO,nV,nV)

  ! out
  integer, intent(out)          :: sze_t2

  integer :: i,j,a,b,idx
  
  idx = 0
  do b = 1, nV
    do a = b+1, nV
      do j = 1, nO
        do i = j+1, nO
          if (dabs(t2_full(i,j,a,b)) >= thresh) then
            if (i <= cc_nOa .and. j <= cc_nOa .and. (a > cc_nVa .or. b > cc_nVa)) cycle
            if (i > cc_nOa .and. j > cc_nOa .and. (a <= cc_nVa .or. b <= cc_nVa)) cycle
            if (a > cc_nVa .and. b > cc_nVa .and. (i <= cc_nOa .or. j <= cc_nOa)) cycle
            if (a <= cc_nVa .and. b <= cc_nVa .and. (i > cc_nOa .or. j > cc_nOa)) cycle
            idx = idx + 1
          endif
        enddo
      enddo
    enddo
  enddo

  sze_t2 = idx

end

subroutine contrib_t2(nO,nV,thresh,t2_full,sze_t2,t2,t2_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2
  double precision, intent(in)    :: thresh,t2_full(nO,nO,nV,nV)

  ! out
  double precision, intent(out)   :: t2(sze_t2)
  integer, intent(out)            :: t2_idx(4,sze_t2)
  
  integer :: i,j,a,b,idx
  
  idx = 1
  do b = 1, nV
    do a = b+1, nV
      do j = 1, nO
        do i = j+1, nO
          if (dabs(t2_full(i,j,a,b)) >= thresh) then
             
            if (i <= cc_nOa .and. j <= cc_nOa .and. (a > cc_nVa .or. b > cc_nVa)) cycle
            if (i > cc_nOa .and. j > cc_nOa .and. (a <= cc_nVa .or. b <= cc_nVa)) cycle
            if (a > cc_nVa .and. b > cc_nVa .and. (i <= cc_nOa .or. j <= cc_nOa)) cycle
            if (a <= cc_nVa .and. b <= cc_nVa .and. (i > cc_nOa .or. j > cc_nOa)) cycle
            t2(idx) = t2_full(i,j,a,b)
            t2_idx(1,idx) = i
            t2_idx(2,idx) = j
            t2_idx(3,idx) = a
            t2_idx(4,idx) = b
            idx = idx + 1
          endif
        enddo
      enddo
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t2,t2_idx,sze_t2,4)
  
  ! Reorder the index of each t
  call reorder_t_idx(t2,t2_idx,sze_t2,4)

end  
#+end_src



** T3 from (T)
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t3_nb(nO,nV,thresh,t1_full,t2_full,f_o,f_v, &
  v_ooov,v_vvvo,sze_t3)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV
  double precision, intent(in) :: thresh, t1_full(nO,nV), t2_full(nO,nO,nV,nV)
  double precision, intent(in) :: f_o(nO), f_v(nV)
  double precision, intent(in) :: v_ooov(nO,nO,nO,nV), v_vvvo(nV,nV,nV,nO)

  ! out
  integer, intent(out)         :: sze_t3

  integer                      :: i,j,k,m,a,b,c,e,idx
  double precision             :: delta, delta_abc, acc


  ! T3 from (T)
  ! Only for canonical orbitals !!!
  ! Check
  print*,'T3'
  do i = 1, N_int
    if (psi_det(i,1,cc_ref) /= hf_bitmask(i,1) .or. &
        psi_det(i,2,cc_ref) /= hf_bitmask(i,2)) then
      print*,'T3 only available for HF reference with canonical orbitals'
      print*,'Reference used:'
      call print_det(psi_det(1,1,cc_ref))
      call abort
    endif
  enddo
  
  do j = 1, mo_num
    do i = 1, mo_num
      if (i == j) cycle
      if (dabs(fock_matrix_mo(i,j)) > 1e-4) then
        print*,'T3 only available for HF reference with canonical orbitals'
        print*,'Non-zero off-diagonal elements detected:'
        print*,i,j,fock_matrix_mo(i,j)
        call abort
      endif
    enddo
  enddo
  
  idx = 0
  do c = 1, nV-2
    do b = c+1, nV-1
      do a = b+1, nV
        delta_abc = f_v(a) + f_v(b) + f_v(c)
        do k = 1, nO-2
          do j = k+1, nO-1
            do i = j+1, nO
              acc = 0d0
              delta = f_o(i) + f_o(j) + f_o(k) - delta_abc
              do e = 1, nV
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                acc = acc &
                  + t2_full(j,k,a,e) * v_vvvo(b,c,e,i) &
                  - t2_full(i,k,a,e) * v_vvvo(b,c,e,j) & ! - P(ij)
                  - t2_full(j,i,a,e) * v_vvvo(b,c,e,k) & ! - P(ik)
                  - t2_full(j,k,b,e) * v_vvvo(a,c,e,i) & ! - P(ab)
                  - t2_full(j,k,c,e) * v_vvvo(b,a,e,i) & ! - P(ac)
                  + t2_full(i,k,b,e) * v_vvvo(a,c,e,j) & ! + P(ij) P(ab)
                  + t2_full(i,k,c,e) * v_vvvo(b,a,e,j) & ! + P(ij) P(ac)
                  + t2_full(j,i,b,e) * v_vvvo(a,c,e,k) & ! + P(ik) P(ab)
                  + t2_full(j,i,c,e) * v_vvvo(b,a,e,k)   ! + P(ik) P(ac)
              enddo
              do m = 1, nO
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                acc = acc &
                  + t2_full(m,i,b,c) * v_ooov(j,k,m,a) &
                  - t2_full(m,j,b,c) * v_ooov(i,k,m,a) & ! - P(ij)
                  - t2_full(m,k,b,c) * v_ooov(j,i,m,a) & ! - P(ik)
                  - t2_full(m,i,a,c) * v_ooov(j,k,m,b) & ! - P(ab)
                  - t2_full(m,i,b,a) * v_ooov(j,k,m,c) & ! - P(ac)
                  + t2_full(m,j,a,c) * v_ooov(i,k,m,b) & ! + P(ij) P(ab)
                  + t2_full(m,j,b,a) * v_ooov(i,k,m,c) & ! + P(ij) P(ac)
                  + t2_full(m,k,a,c) * v_ooov(j,i,m,b) & ! + P(ik) P(ab)
                  + t2_full(m,k,b,a) * v_ooov(j,i,m,c)   ! + P(ik) P(ac)
              enddo
              !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) * (1d0 / delta)
              acc = acc / delta
              if (dabs(acc) >= thresh) then
                idx = idx + 1
              endif
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo

  sze_t3 = idx
  
end

subroutine contrib_t3(nO,nV,thresh,t1_full,t2_full,f_o,f_v, &
  v_ooov,v_vvvo,sze_t3,t3,t3_idx)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t3
  double precision, intent(in) :: thresh,t1_full(nO,nV),t2_full(nO,nO,nV,nV)
  double precision, intent(in) :: f_o(nO), f_v(nV)
  double precision, intent(in) :: v_ooov(nO,nO,nO,nV), v_vvvo(nV,nV,nV,nO)

  ! out
  double precision, intent(out)   :: t3(sze_t3)
  integer, intent(out)            :: t3_idx(6,sze_t3)
  
  integer                      :: i,j,k,m,a,b,c,e,idx
  double precision             :: delta, delta_abc, acc

  idx = 1
  do c = 1, nV-2
    do b = c+1, nV-1
      do a = b+1, nV
        delta_abc = f_v(a) + f_v(b) + f_v(c)
        do k = 1, nO-2
          do j = k+1, nO-1
            do i = j+1, nO
              acc = 0d0
              delta = f_o(i) + f_o(j) + f_o(k) - delta_abc
              do e = 1, nV
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                acc = acc &
                  + t2_full(j,k,a,e) * v_vvvo(b,c,e,i) &
                  - t2_full(i,k,a,e) * v_vvvo(b,c,e,j) & ! - P(ij)
                  - t2_full(j,i,a,e) * v_vvvo(b,c,e,k) & ! - P(ik)
                  - t2_full(j,k,b,e) * v_vvvo(a,c,e,i) & ! - P(ab)
                  - t2_full(j,k,c,e) * v_vvvo(b,a,e,i) & ! - P(ac)
                  + t2_full(i,k,b,e) * v_vvvo(a,c,e,j) & ! + P(ij) P(ab)
                  + t2_full(i,k,c,e) * v_vvvo(b,a,e,j) & ! + P(ij) P(ac)
                  + t2_full(j,i,b,e) * v_vvvo(a,c,e,k) & ! + P(ik) P(ab)
                  + t2_full(j,i,c,e) * v_vvvo(b,a,e,k)   ! + P(ik) P(ac)
              enddo
              do m = 1, nO
                !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
                acc = acc &
                  + t2_full(m,i,b,c) * v_ooov(j,k,m,a) &
                  - t2_full(m,j,b,c) * v_ooov(i,k,m,a) & ! - P(ij)
                  - t2_full(m,k,b,c) * v_ooov(j,i,m,a) & ! - P(ik)
                  - t2_full(m,i,a,c) * v_ooov(j,k,m,b) & ! - P(ab)
                  - t2_full(m,i,b,a) * v_ooov(j,k,m,c) & ! - P(ac)
                  + t2_full(m,j,a,c) * v_ooov(i,k,m,b) & ! + P(ij) P(ab)
                  + t2_full(m,j,b,a) * v_ooov(i,k,m,c) & ! + P(ij) P(ac)
                  + t2_full(m,k,a,c) * v_ooov(j,i,m,b) & ! + P(ik) P(ab)
                  + t2_full(m,k,b,a) * v_ooov(j,i,m,c)   ! + P(ik) P(ac)
              enddo
              !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) * (1d0 / delta)
              acc = acc / delta
              if (dabs(acc) >= thresh) then
                t3(idx) = acc
                t3_idx(1,idx) = i
                t3_idx(2,idx) = j
                t3_idx(3,idx) = k
                t3_idx(4,idx) = a
                t3_idx(5,idx) = b
                t3_idx(6,idx) = c
                idx = idx + 1
              endif
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t3,t3_idx,sze_t3,6)

  ! Reorder the index of each t
  call reorder_t_idx(t3,t3_idx,sze_t3,6)

end  
#+end_src

** T1^2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t11_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1
  double precision, intent(in)    :: thresh,t1(sze_t1)
  integer, intent(in)             :: t1_idx(2,sze_t1)

  ! out
  integer, intent(out)          :: sze_t11

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t1-1
    do j = i+1, sze_t1
      if (dabs(t1(i) * t1(j)) >= thresh) then
        ! The resulting coeff can't contain 2 times the same spin orbital index
        if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(2,i) == t1_idx(2,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t11 = idx

end

subroutine contrib_t11(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t11
  double precision, intent(in)    :: thresh,t1(sze_t1)
  integer, intent(in)             :: t1_idx(2,sze_t1)

  ! out
  double precision, intent(out)   :: t11(sze_t11)
  integer, intent(out)            :: t11_idx(4,sze_t11)
  
  integer :: i,j,idx
  
  idx = 1
  do i = 1, sze_t1-1
    do j = i+1, sze_t1
      if (dabs(t1(i) * t1(j)) >= thresh) then
        if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(2,i) == t1_idx(2,j)) cycle
        t11(idx) = t1(i) * t1(j)
        t11_idx(1,idx) = t1_idx(1,i)
        t11_idx(3,idx) = t1_idx(2,i)
        t11_idx(2,idx) = t1_idx(1,j)
        t11_idx(4,idx) = t1_idx(2,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t11,t11_idx,sze_t11,4)

  ! Reorder the index of each t
  call reorder_t_idx(t11,t11_idx,sze_t11,4)

end  
#+end_src

** T1 T2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t12_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx,sze_t12)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t2
  double precision, intent(in) :: thresh,t1(sze_t1),t2(sze_t2)
  integer, intent(in)          :: t1_idx(2,sze_t1),t2_idx(4,sze_t2)

  ! out
  integer, intent(out)         :: sze_t12

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t2
      if (dabs(t1(i) * t2(j)) >= thresh) then
        if (t1_idx(1,i) == t2_idx(1,j) .or. t1_idx(1,i) == t2_idx(2,j) .or. &
            t1_idx(2,i) == t2_idx(3,j) .or. t1_idx(2,i) == t2_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t12 = idx
        
end

subroutine contrib_t12(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t2,t2,t2_idx,&
     sze_t12,t12,t12_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t2,sze_t12
  double precision, intent(in)    :: thresh,t1(sze_t1),t2(sze_t2)
  integer, intent(in)             :: t1_idx(2,sze_t1),t2_idx(4,sze_t2)

  ! out
  double precision, intent(out)   :: t12(sze_t12)
  integer, intent(out)            :: t12_idx(6,sze_t12)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t2
      if (dabs(t1(i) * t2(j)) >= thresh) then
        if (t1_idx(1,i) == t2_idx(1,j) .or. t1_idx(1,i) == t2_idx(2,j) .or. &
            t1_idx(2,i) == t2_idx(3,j) .or. t1_idx(2,i) == t2_idx(4,j)) cycle
        t12(idx) = t1(i) * t2(j)
        t12_idx(1,idx) = t1_idx(1,i)
        t12_idx(4,idx) = t1_idx(2,i)
        t12_idx(2,idx) = t2_idx(1,j)
        t12_idx(3,idx) = t2_idx(2,j)
        t12_idx(5,idx) = t2_idx(3,j)
        t12_idx(6,idx) = t2_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo 
  ! Sort
  call sort_by_coef_idx(t12,t12_idx,sze_t12,6)
  ! Reorder the index of each t
  call reorder_t_idx(t12,t12_idx,sze_t12,6)

end  
#+end_src

** T1 T3
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t13_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,sze_t13)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t1,sze_t3
  double precision, intent(in) :: thresh,t1(sze_t1),t3(sze_t3)
  integer, intent(in)          :: t1_idx(2,sze_t1),t3_idx(6,sze_t3)

  ! out
  integer, intent(out)         :: sze_t13

  integer :: i,j,idx

  ! t13
  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t3
      if (dabs(t1(i) * t3(j)) >= thresh) then
        if (t1_idx(1,i) == t3_idx(1,j) .or. t1_idx(1,i) == t3_idx(2,j) .or. &
            t1_idx(1,i) == t3_idx(3,j) .or. &
            t1_idx(2,i) == t3_idx(4,j) .or. t1_idx(2,i) == t3_idx(5,j) .or. &
            t1_idx(2,i) == t3_idx(6,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t13 = idx
        
end

subroutine contrib_t13(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t3,t3,t3_idx,&
     sze_t13,t13,t13_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t3,sze_t13
  double precision, intent(in)    :: thresh,t1(sze_t1),t3(sze_t3)
  integer, intent(in)             :: t1_idx(2,sze_t1),t3_idx(6,sze_t3)

  ! out
  double precision, intent(out)   :: t13(sze_t13)
  integer, intent(out)            :: t13_idx(8,sze_t13)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t3
      if (dabs(t1(i) * t3(j)) >= thresh) then
        if (t1_idx(1,i) == t3_idx(1,j) .or. t1_idx(1,i) == t3_idx(2,j) .or. &
            t1_idx(1,i) == t3_idx(3,j) .or. &
            t1_idx(2,i) == t3_idx(4,j) .or. t1_idx(2,i) == t3_idx(5,j) .or. &
            t1_idx(2,i) == t3_idx(6,j)) cycle
        t13(idx) = t1(i) * t3(j)
        t13_idx(1,idx) = t1_idx(1,i)
        t13_idx(5,idx) = t1_idx(2,i)
        t13_idx(2,idx) = t3_idx(1,j)
        t13_idx(3,idx) = t3_idx(2,j)
        t13_idx(4,idx) = t3_idx(3,j)
        t13_idx(6,idx) = t3_idx(4,j)
        t13_idx(7,idx) = t3_idx(5,j)
        t13_idx(8,idx) = t3_idx(6,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t13,t13_idx,sze_t13,8)
  
  ! Reorder the index of each t
  call reorder_t_idx(t13,t13_idx,sze_t13,8)    
end  
#+end_src

** T2^2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t22_nb(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2
  double precision, intent(in)    :: thresh,t2(sze_t2)
  integer, intent(in)             :: t2_idx(4,sze_t2)

  ! out
  integer, intent(out)          :: sze_t22

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t2-1
    do j = i+1, sze_t2
      if (dabs(t2(i) * t2(j)) >= thresh) then
        if (t2_idx(1,i) == t2_idx(1,j) .or. t2_idx(1,i) == t2_idx(2,j) .or. &
            t2_idx(2,i) == t2_idx(1,j) .or. t2_idx(2,i) == t2_idx(2,j) .or. &
            t2_idx(3,i) == t2_idx(3,j) .or. t2_idx(3,i) == t2_idx(4,j) .or. &
            t2_idx(4,i) == t2_idx(3,j) .or. t2_idx(4,i) == t2_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t22 = idx
        
end

subroutine contrib_t22(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2,sze_t22
  double precision, intent(in)    :: thresh,t2(sze_t2)
  integer, intent(in)             :: t2_idx(4,sze_t2)

  ! out
  double precision, intent(out)   :: t22(sze_t22)
  integer, intent(out)            :: t22_idx(8,sze_t22)
  
  integer :: i,j,idx
  
  idx = 1
  do i = 1, sze_t2-1
    do j = i+1, sze_t2
      if (dabs(t2(i) * t2(j)) >= thresh) then
        if (t2_idx(1,i) == t2_idx(1,j) .or. t2_idx(1,i) == t2_idx(2,j) .or. &
            t2_idx(2,i) == t2_idx(1,j) .or. t2_idx(2,i) == t2_idx(2,j) .or. &
            t2_idx(3,i) == t2_idx(3,j) .or. t2_idx(3,i) == t2_idx(4,j) .or. &
            t2_idx(4,i) == t2_idx(3,j) .or. t2_idx(4,i) == t2_idx(4,j)) cycle
        t22(idx) = t2(i) * t2(j)
        t22_idx(1,idx) = t2_idx(1,i)
        t22_idx(2,idx) = t2_idx(2,i)
        t22_idx(5,idx) = t2_idx(3,i)
        t22_idx(6,idx) = t2_idx(4,i)
        t22_idx(3,idx) = t2_idx(1,j)
        t22_idx(4,idx) = t2_idx(2,j)
        t22_idx(7,idx) = t2_idx(3,j)
        t22_idx(8,idx) = t2_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t22,t22_idx,sze_t22,8)

  ! Reorder the index of each t
  call reorder_t_idx(t22,t22_idx,sze_t22,8)
  
end  
#+end_src

** T1^3
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t111_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx,sze_t111)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t11
  double precision, intent(in)    :: thresh,t1(sze_t1),t11(sze_t11)
  integer, intent(in)             :: t1_idx(2,sze_t1), t11_idx(4,sze_t11)

  ! out
  integer, intent(out)          :: sze_t111

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t11
      if (dabs(t1(i) * t11(j)) >= thresh) then
        !if (t1_idx(1,i) == t11_idx(1,j) .or. t1_idx(1,i) == t11_idx(2,j) .or. &
        !    t1_idx(2,i) == t11_idx(3,j) .or. t1_idx(2,i) == t11_idx(4,j)) cycle
        if (t1_idx(1,i) >= t11_idx(1,j) .or. t1_idx(2,i) == t11_idx(3,j) .or. &
            t1_idx(2,i) == t11_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  !idx=0
  !do i = 1, sze_t1-2
  !  do j = i+1, sze_t1-1
  !    do k = j+1, sze_t1
  !      if (dabs(t1(i) * t1(j) * t1(k)) >= thresh) then
  !      if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(1,i) == t1_idx(1,k) .or. &
  !          t1_idx(2,i) == t1_idx(2,j) .or. t1_idx(2,i) == t1_idx(2,k) .or. &
  !          t1_idx(1,j) == t1_idx(1,k) .or. t1_idx(2,j) == t1_idx(2,k) ) cycle
  !      idx = idx + 1
  !      endif
  !    enddo
  !  enddo
  !enddo

  sze_t111 = idx

end

subroutine contrib_t111(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t11,t11,t11_idx, &
     sze_t111,t111,t111_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t11,sze_t111
  double precision, intent(in)    :: thresh,t1(sze_t1),t11(sze_t11)
  integer, intent(in)             :: t1_idx(2,sze_t1),t11_idx(4,sze_t11)

  ! out
  double precision, intent(out)   :: t111(sze_t111)
  integer, intent(out)            :: t111_idx(6,sze_t111)
  
  integer :: i,j,idx

  idx = 1
  !fact = 1d0/3d0
  do i = 1, sze_t1
    do j = 1, sze_t11
      if (dabs(t1(i) * t11(j)) >= thresh) then
        !if (t1_idx(1,i) == t11_idx(1,j) .or. t1_idx(1,i) == t11_idx(2,j) .or. &
        !    t1_idx(2,i) == t11_idx(3,j) .or. t1_idx(2,i) == t11_idx(4,j)) cycle
        if (t1_idx(1,i) >= t11_idx(1,j) .or. t1_idx(2,i) == t11_idx(3,j) .or. &
            t1_idx(2,i) == t11_idx(4,j)) cycle
        t111(idx) = t1(i) * t11(j) !* fact
        t111_idx(1,idx) = t1_idx(1,i)
        t111_idx(4,idx) = t1_idx(2,i)
        t111_idx(2,idx) = t11_idx(1,j)
        t111_idx(3,idx) = t11_idx(2,j)
        t111_idx(5,idx) = t11_idx(3,j)
        t111_idx(6,idx) = t11_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  !do i = 1, sze_t1-2
  !  do j = i+1, sze_t1-1
  !    do k = j+1, sze_t1
  !      if (dabs(t1(i) * t1(j) * t1(k)) >= thresh) then
  !      if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(1,i) == t1_idx(1,k) .or. &
  !          t1_idx(2,i) == t1_idx(2,j) .or. t1_idx(2,i) == t1_idx(2,k) .or. &
  !          t1_idx(1,j) == t1_idx(1,k) .or. t1_idx(2,j) == t1_idx(2,k) ) cycle
  !      t111(idx) = t1(i) * t1(j) * t1(k)
  !      t111_idx(1,idx) = t1_idx(1,i)
  !      t111_idx(4,idx) = t1_idx(2,i)
  !      t111_idx(2,idx) = t1_idx(1,j)
  !      t111_idx(5,idx) = t1_idx(2,j)
  !      t111_idx(3,idx) = t1_idx(1,k)
  !      t111_idx(6,idx) = t1_idx(2,k)
  !      !print*,t111(idx)
  !      !print*,t1_idx(:,i),t1_idx(:,j),t1_idx(:,k)
  !      !print*,t111_idx(:,idx)
  !      idx = idx + 1
  !      endif
  !    enddo
  !  enddo
  !enddo
         
  ! Sort
  call sort_by_coef_idx(t111,t111_idx,sze_t111,6)

  ! Reorder the index of each t
  call reorder_t_idx(t111,t111_idx,sze_t111,6)
  
end  
#+end_src

** T1^2 T2
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t112_nb(nO,nV,thresh,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx, &
     sze_t112)

  implicit none

  ! in
  integer, intent(in)          :: nO,nV,sze_t11,sze_t2
  double precision, intent(in) :: thresh,t11(sze_t11),t2(sze_t2)
  integer, intent(in)          :: t11_idx(4,sze_t11),t2_idx(4,sze_t2)

  ! out
  integer, intent(out)         :: sze_t112

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t11
    do j = 1, sze_t2
      if (dabs(t11(i) * t2(j)) >= thresh) then
        if (t11_idx(1,i) == t2_idx(1,j) .or. t11_idx(1,i) == t2_idx(2,j) .or. &
            t11_idx(2,i) == t2_idx(1,j) .or. t11_idx(2,i) == t2_idx(2,j) .or. &
            t11_idx(3,i) == t2_idx(3,j) .or. t11_idx(3,i) == t2_idx(4,j) .or. &
            t11_idx(4,i) == t2_idx(3,j) .or. t11_idx(4,i) == t2_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t112 = idx
  
end

subroutine contrib_t112(nO,nV,thresh,sze_t11,t11,t11_idx,sze_t2,t2,t2_idx,&
     sze_t112,t112,t112_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t11,sze_t2,sze_t112
  double precision, intent(in)    :: thresh,t11(sze_t11),t2(sze_t2)
  integer, intent(in)             :: t11_idx(4,sze_t11),t2_idx(4,sze_t2)

  ! out
  double precision, intent(out)   :: t112(sze_t112)
  integer, intent(out)            :: t112_idx(8,sze_t112)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t11
    do j = 1, sze_t2
      if (dabs(t11(i) * t2(j)) >= thresh) then
        if (t11_idx(1,i) == t2_idx(1,j) .or. t11_idx(1,i) == t2_idx(2,j) .or. &
            t11_idx(2,i) == t2_idx(1,j) .or. t11_idx(2,i) == t2_idx(2,j) .or. &
            t11_idx(3,i) == t2_idx(3,j) .or. t11_idx(3,i) == t2_idx(4,j) .or. &
            t11_idx(4,i) == t2_idx(3,j) .or. t11_idx(4,i) == t2_idx(4,j)) cycle
        t112(idx) = t11(i) * t2(j)
        t112_idx(1,idx) = t11_idx(1,i)
        t112_idx(2,idx) = t11_idx(2,i)
        t112_idx(5,idx) = t11_idx(3,i)
        t112_idx(6,idx) = t11_idx(4,i)
        t112_idx(3,idx) = t2_idx(1,j)
        t112_idx(4,idx) = t2_idx(2,j)
        t112_idx(7,idx) = t2_idx(3,j)
        t112_idx(8,idx) = t2_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t112,t112_idx,sze_t112,8)

  ! Reorder the index of each t
  call reorder_t_idx(t112,t112_idx,sze_t112,8)
  
end  
#+end_src


** T1^4
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t1111_nb(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx,sze_t1111)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t111
  double precision, intent(in)    :: thresh,t1(sze_t1),t111(sze_t111)
  integer, intent(in)             :: t1_idx(2,sze_t1), t111_idx(6,sze_t111)

  ! out
  integer, intent(out)          :: sze_t1111

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t111
      if (dabs(t1(i) * t111(j)) >= thresh) then
        !if (t1_idx(1,i) == t111_idx(1,j) .or. t1_idx(1,i) == t111_idx(2,j) .or. &
        !    t1_idx(1,i) == t111_idx(3,j) .or. &
        !    t1_idx(2,i) == t111_idx(4,j) .or. t1_idx(2,i) == t111_idx(5,j) .or. &
        !    t1_idx(2,i) == t111_idx(6,j)) cycle
        if (t1_idx(1,i) >= t111_idx(1,j) .or. t1_idx(2,i) == t111_idx(4,j) .or. &
            t1_idx(2,i) == t111_idx(5,j) .or. t1_idx(2,i) == t111_idx(6,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t1111 = idx
        
end

subroutine contrib_t1111(nO,nV,thresh,sze_t1,t1,t1_idx,sze_t111,t111,t111_idx, &
     sze_t1111,t1111,t1111_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t1,sze_t111,sze_t1111
  double precision, intent(in)    :: thresh,t1(sze_t1),t111(sze_t111)
  integer, intent(in)             :: t1_idx(2,sze_t1),t111_idx(6,sze_t111)

  ! out
  double precision, intent(out)   :: t1111(sze_t1111)
  integer, intent(out)            :: t1111_idx(8,sze_t1111)
  
  integer :: i,j,idx

  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t111
      if (dabs(t1(i) * t111(j)) >= thresh) then
        !if (t1_idx(1,i) == t111_idx(1,j) .or. t1_idx(1,i) == t111_idx(2,j) .or. &
        !    t1_idx(1,i) == t111_idx(3,j) .or. &
        !    t1_idx(2,i) == t111_idx(4,j) .or. t1_idx(2,i) == t111_idx(5,j) .or. &
        !    t1_idx(2,i) == t111_idx(6,j)) cycle
        if (t1_idx(1,i) >= t111_idx(1,j) .or. t1_idx(2,i) == t111_idx(4,j) .or. &
            t1_idx(2,i) == t111_idx(5,j) .or. t1_idx(2,i) == t111_idx(6,j)) cycle
        t1111(idx) = t1(i) * t111(j)
        t1111_idx(1,idx) = t1_idx(1,i)
        t1111_idx(5,idx) = t1_idx(2,i)
        t1111_idx(2,idx) = t111_idx(1,j)
        t1111_idx(3,idx) = t111_idx(2,j)
        t1111_idx(4,idx) = t111_idx(3,j)
        t1111_idx(6,idx) = t111_idx(4,j)
        t1111_idx(7,idx) = t111_idx(5,j)
        t1111_idx(8,idx) = t111_idx(6,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  ! Sort
  call sort_by_coef_idx(t1111,t1111_idx,sze_t1111,8)

  ! Reorder the index of each t
  call reorder_t_idx(t1111,t1111_idx,sze_t1111,8)
  
end  
#+end_src

** T2^3
#+begin_src f90 :comments org :tangle cc_to_ci.irp.f
subroutine contrib_t222_nb(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx,sze_t222)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2,sze_t22
  double precision, intent(in)    :: thresh,t2(sze_t2),t22(sze_t22)
  integer, intent(in)             :: t2_idx(4,sze_t2), t22_idx(8,sze_t22)

  ! out
  integer, intent(out)          :: sze_t222

  integer :: i,j,idx

  idx = 0
  do i = 1, sze_t2
    do j = 1, sze_t22
      if (dabs(t2(i) * t22(j)) >= thresh) then
        if (t2_idx(1,i) == t22_idx(1,j) .or. t2_idx(1,i) == t22_idx(2,j) .or. &
            t2_idx(1,i) == t22_idx(3,j) .or. t2_idx(1,i) == t22_idx(4,j) .or. &
            t2_idx(2,i) == t22_idx(1,j) .or. t2_idx(2,i) == t22_idx(2,j) .or. &
            t2_idx(2,i) == t22_idx(3,j) .or. t2_idx(2,i) == t22_idx(4,j) .or. &
            t2_idx(3,i) == t22_idx(5,j) .or. t2_idx(3,i) == t22_idx(6,j) .or. &
            t2_idx(3,i) == t22_idx(7,j) .or. t2_idx(3,i) == t22_idx(8,j) .or. &
            t2_idx(4,i) == t22_idx(5,j) .or. t2_idx(4,i) == t22_idx(6,j) .or. &
            t2_idx(4,i) == t22_idx(7,j) .or. t2_idx(4,i) == t22_idx(8,j)) cycle
         idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t222 = idx
  
end

subroutine contrib_t222(nO,nV,thresh,sze_t2,t2,t2_idx,sze_t22,t22,t22_idx, &
     sze_t222,t222,t222_idx)

  implicit none

  ! in
  integer, intent(in)             :: nO,nV,sze_t2,sze_t22,sze_t222
  double precision, intent(in)    :: thresh,t2(sze_t2),t22(sze_t22)
  integer, intent(in)             :: t2_idx(4,sze_t2),t22_idx(8,sze_t22)

  ! out
  double precision, intent(out)   :: t222(sze_t222)
  integer, intent(out)            :: t222_idx(12,sze_t222)
  
  integer :: i,j,idx
  double precision :: fact

  idx = 1
  fact = 1d0/3d0
  do i = 1, sze_t2
    do j = 1, sze_t22
      if (dabs(t2(i) * t22(j)) >= thresh) then
        if (t2_idx(1,i) == t22_idx(1,j) .or. t2_idx(1,i) == t22_idx(2,j) .or. &
            t2_idx(1,i) == t22_idx(3,j) .or. t2_idx(1,i) == t22_idx(4,j) .or. &
            t2_idx(2,i) == t22_idx(1,j) .or. t2_idx(2,i) == t22_idx(2,j) .or. &
            t2_idx(2,i) == t22_idx(3,j) .or. t2_idx(2,i) == t22_idx(4,j) .or. &
            t2_idx(3,i) == t22_idx(5,j) .or. t2_idx(3,i) == t22_idx(6,j) .or. &
            t2_idx(3,i) == t22_idx(7,j) .or. t2_idx(3,i) == t22_idx(8,j) .or. &
            t2_idx(4,i) == t22_idx(5,j) .or. t2_idx(4,i) == t22_idx(6,j) .or. &
            t2_idx(4,i) == t22_idx(7,j) .or. t2_idx(4,i) == t22_idx(8,j)) cycle
         t222(idx) = t2(i) * t22(j) * fact
         t222_idx(1,idx) = t2_idx(1,i)
         t222_idx(2,idx) = t2_idx(2,i)
         t222_idx(7,idx) = t2_idx(3,i)
         t222_idx(8,idx) = t2_idx(4,i)
         t222_idx(3,idx) = t22_idx(1,j)
         t222_idx(4,idx) = t22_idx(2,j)
         t222_idx(5,idx) = t22_idx(3,j)
         t222_idx(6,idx) = t22_idx(4,j)
         t222_idx(9,idx) = t22_idx(5,j)
         t222_idx(10,idx) = t22_idx(6,j)
         t222_idx(11,idx) = t22_idx(7,j)
         t222_idx(12,idx) = t22_idx(8,j)
         idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  ! Sort
  call sort_by_coef_idx(t222,t222_idx,sze_t222,12)

  ! Reorder the index of each t
  call reorder_t_idx(t222,t222_idx,sze_t222,12)
  
end  
#+end_src

