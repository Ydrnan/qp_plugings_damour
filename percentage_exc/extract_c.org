#+begin_src f90 :org comments :tangle extract_c.irp.f
program extract_c

  implicit none

  read_wf = .True.
  TOUCH read_wf

  call run_extract_c
  
end
#+end_src

* Extract c
#+begin_src f90 :org comments :tangle extract_c.irp.f
subroutine run_extract_c

  implicit none

  double precision, allocatable :: t1(:,:), t2(:,:,:,:)
  double precision, allocatable :: c1(:,:), c2(:,:,:,:), c3_bc(:,:,:,:), c4_abcd(:,:,:,:)
  double precision, allocatable :: tmp_coef(:), l_coef(:), abs_coef(:)
  integer :: nO,nV,nOa,nOb,nVa,nVb,nO_m,nV_m,nO_S(2),nV_S(2)
  integer, allocatable :: list_occ(:,:),list_vir(:,:),list_spin_occ(:,:), list_spin_vir(:,:), key(:)
  integer :: i,j,k,l,a,b,c,d,tmp_i,tmp_j,tmp_k,tmp_l,tmp_a,tmp_b,tmp_c,tmp_d,s1,s2,s3,s4
  integer :: idx_i,idx_j,idx_a,idx_b,idx_coef,nb_coef,up_bd,p1,p2,p3,p4,h1,h2,h3,h4, degree
  double precision :: thresh_coef, factor, norm, phase,s2_val
  integer(bit_kind) :: res1(N_int,2), res2(N_int,2), res3(N_int,2), res4(N_int,2), res5(N_int,2), res6(N_int,2), res7(N_int,2), exc(0:2,2,2)
  integer(bit_kind), allocatable :: det(:,:), tmp_det(:,:,:), l_det(:,:,:)
  logical :: ok
  integer :: shift_occ(2)
  integer :: shift_vir(2)

  PROVIDE s2_values
  
  allocate(det(N_int,2))

  det = psi_det(:,:,cc_ref)
  print*,'Reference determinant:'
  call print_det(det,N_int)
  
  thresh_coef = thresh_extract_c

  ! Total number of occ/vir spin orb
  nO = cc_nOab
  nV = cc_nVab
  !print*,nO,nV

  ! Number of occ/vir spin orb per spin
  nO_S = cc_nO_S
  nV_S = cc_nV_S
  !print*,nO_S,nV_S

  ! Maximal number of occ/vir 
  nO_m = cc_nO_m
  nV_m = cc_nV_m

  shift_occ = (/0,cc_nOa/)
  shift_vir = (/0,cc_nVa/)

  allocate(list_occ(nO_m,2), list_vir(nV_m,2))
  call extract_list_orb_spin(det,nO_m,nV_m,list_occ,list_vir)
  !print*,'occ a',list_occ(:,1)
  !print*,'occ b',list_occ(:,2)
  !print*,'vir a',list_vir(:,1)
  !print*,'vir b',list_vir(:,2)
  !print*,'nO_S',nO_s
  !print*,'nV_S',nV_s
  
  allocate(list_spin_occ(nO_m,2), list_spin_vir(nV_m,2))

  list_spin_occ = cc_list_occ_spin
  list_spin_vir = cc_list_vir_spin

  allocate(t1(nO,nV), t2(nO,nO,nV,nV))
  allocate(c1(nO,nV), c2(nO,nO,nV,nV), c3_bc(nO,nO,nO,nV), c4_abcd(nO,nO,nO,nO))

  print*, 'T1 and T2 read from disk'
  call read_t1(nO,nV,t1)
  call read_t2(nO,nV,t2)
  
  c1 = t1
  call extract_c2(nO,nV,t1,t2,c2)

  ! Count the number of coefficients s.t. |c| > thresh
  nb_coef = 1 ! Ref
  ! c1
  do s1 = 1, 2
    do tmp_a = 1, nV_S(s1)
      a = tmp_a + shift_vir(s1)
      do tmp_i = 1, nO_S(s1)
        i = tmp_i + shift_occ(s1)
        if (dabs(c1(i,a)) >= thresh_coef) then
          nb_coef = nb_coef + 1
        endif
        
      enddo
    enddo
  enddo

  print*,'Nb C1 computed' 
  
  !c2
  do s1 = 1, 2
    do s2 = s1, 2
      do tmp_b = 1, nV_S(s2)
        b = tmp_b + shift_vir(s2)
        do tmp_a = 1, nV_S(s1)
          a = tmp_a + shift_vir(s1)
          if (s1 == s2 .and. a <= b) cycle
          do tmp_j = 1, nO_S(s2)
            j = tmp_j + shift_occ(s2)
            do tmp_i = 1, nO_S(s1)
              i = tmp_i + shift_occ(s1)
              if (s1 == s2 .and. i <= j) cycle
              
              if (dabs(c2(i,j,a,b)) >= thresh_coef) then
                nb_coef = nb_coef + 1
              endif
              
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo
  
  print*,'Nb C2 computed'  

  !c3
  if (extract_c3) then
    do s1 = 1, 2
      do s2 = s1, 2
        do s3 = s2, 2
          do tmp_c = 1, nV_S(s3)
            c = tmp_c + shift_vir(s3)
            do tmp_b = 1, nV_S(s2)
              b = tmp_b + shift_vir(s2)
              if (s2 == s3 .and. b <= c) cycle
              ! C3 for b and c fixed
              call extract_c3_bc(nO,nV,t1,t2,b,c,c3_bc)
              do tmp_a = 1, nV_S(s1)
                a = tmp_a + shift_vir(s1)
                if (s1 == s2 .and. a <= b) cycle
                do tmp_k = 1, nO_S(s3)
                  k = tmp_k + shift_occ(s3)
                  do tmp_j = 1, nO_S(s2)
                    j = tmp_j + shift_occ(s2)
                    if (s2 == s3 .and. j <= k) cycle
                    do tmp_i = 1, nO_S(s1)
                      i = tmp_i + shift_occ(s1)
                      if (s1 == s2 .and. i <= j) cycle
                      
                      if (dabs(c3_bc(i,j,k,a)) >= thresh_coef) then
                        nb_coef = nb_coef + 1
                      endif
                      
                    enddo
                  enddo
                enddo
              enddo
            enddo
          enddo
        enddo
      enddo
    enddo
    print*,'Nb C3 computed'  
  endif
  
  !c4
  if (extract_c4) then
    do s1 = 1, 2
      do s2 = s1, 2
        do s3 = s2, 2
          do s4 = s3, 2
            do tmp_d = 1, nV_S(s4)
              d = tmp_d + shift_vir(s4)
              do tmp_c = 1, nV_S(s3)
                c = tmp_c + shift_vir(s3)
                if (s3 == s4 .and. c <= d) cycle
                do tmp_b = 1, nV_S(s2)
                  b = tmp_b + shift_vir(s2)
                  if (s2 == s3 .and. b <= c) cycle
                  do tmp_a = 1, nV_S(s1)
                    a = tmp_a + shift_vir(s1)
                    if (s1 == s2 .and. a <= b) cycle
                    ! C4 for a,b,c and d fixed
                    call extract_c4_abcd(nO,nV,t1,t2,a,b,c,d,c4_abcd)
                    do tmp_l = 1, nO_S(s4)
                      l = tmp_l + shift_occ(s4)
                      do tmp_k = 1, nO_S(s3)
                        k = tmp_k + shift_occ(s3)
                        if (s3 == s4 .and. k <= l) cycle
                        do tmp_j = 1, nO_S(s2)
                          j = tmp_j + shift_occ(s2)
                          if (s2 == s3 .and. j <= k) cycle
                          do tmp_i = 1, nO_S(s1)
                            i = tmp_i + shift_occ(s1)
                            if (s1 == s2 .and. i <= j) cycle
                            
                            if (dabs(c4_abcd(i,j,k,l)) >= thresh_coef) then
                              nb_coef = nb_coef + 1
                            endif
                            
                          enddo
                        enddo
                      enddo
                    enddo
                  enddo
                enddo
              enddo
            enddo
          enddo
        enddo
      enddo
    enddo
    print*,'Nb C4 computed'  
  endif

  print*,''
  print*,'Nb of coef', nb_coef

  ! Allocate and fill 
  allocate(tmp_coef(nb_coef), abs_coef(nb_coef), tmp_det(N_int,2,nb_coef))

  ! Ref
  tmp_coef(1) = 1d0
  tmp_det(:,:,1) = det
  
  idx_coef = 2
  ! c1
  do s1 = 1, 2
    do tmp_a = 1, nV_S(s1)
      a = tmp_a + shift_vir(s1)
      p1 = list_vir(tmp_a,s1)
      do tmp_i = 1, nO_S(s1)
        i = tmp_i + shift_occ(s1)
        h1 = list_occ(tmp_i,s1)
        
        if (dabs(c1(i,a)) >= thresh_coef) then
          call apply_hole(det, s1, h1, res1, ok, N_int)
          call apply_particle(res1, s1, p1, tmp_det(1,1,idx_coef), ok, N_int)
          call get_excitation(det,tmp_det(1,1,idx_coef),exc,degree,phase,N_int)
          tmp_coef(idx_coef) = c1(i,a) * phase
          idx_coef = idx_coef + 1
        endif
        
      enddo
    enddo
  enddo

  print*,'C1: Done'
  
  !c2
  do s1 = 1, 2
    do s2 = s1, 2
      do tmp_b = 1, nV_S(s2)
        b = tmp_b + shift_vir(s2)
        p2 = list_vir(tmp_b,s2)
        do tmp_a = 1, nV_S(s1)
          a = tmp_a + shift_vir(s1)
          p1 = list_vir(tmp_a,s1)
          if (s1 == s2 .and. a <= b) cycle
          do tmp_j = 1, nO_S(s2)
            j = tmp_j + shift_occ(s2)
            h2 = list_occ(tmp_j,s2)
            do tmp_i = 1, nO_S(s1)
              i = tmp_i + shift_occ(s1)
              h1 = list_occ(tmp_i,s1)
              if (s1 == s2 .and. i <= j) cycle
              
              if (dabs(c2(i,j,a,b)) >= thresh_coef) then
                call apply_hole(det, s1, h1, res1, ok, N_int)
                call apply_hole(res1, s2, h2, res2, ok, N_int)
                call apply_particle(res2, s1, p1, res3, ok, N_int)
                call apply_particle(res3, s2, p2, tmp_det(1,1,idx_coef), ok, N_int)
                call get_excitation(det,tmp_det(1,1,idx_coef),exc,degree,phase,N_int)
                tmp_coef(idx_coef) = c2(i,j,a,b) * phase
                !print*,tmp_coef(idx_coef)
                !print*,i,j,a,b
                idx_coef = idx_coef + 1
              endif
              
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo

  print*,'C2: Done'
  
  !c3
  if (extract_c3) then
    do s1 = 1, 2
      do s2 = s1, 2
        do s3 = s2, 2
          do tmp_c = 1, nV_S(s3)
            c = tmp_c +  shift_vir(s3)
            p3 = list_vir(tmp_c,s3)
            do tmp_b = 1, nV_S(s2)
              b = tmp_b + shift_vir(s2)
              p2 = list_vir(tmp_b,s2)
              if (s2 == s3 .and. b <= c) cycle
              ! C3 for b and c fixed
              call extract_c3_bc(nO,nV,t1,t2,b,c,c3_bc)
              do tmp_a = 1, nV_S(s1)
                a = tmp_a + shift_vir(s1)
                p1 = list_vir(tmp_a,s1)
                if (s1 == s2 .and. a <= b) cycle
                do tmp_k = 1, nO_S(s3)
                   k = tmp_k + shift_occ(s3)
                   h3 = list_occ(tmp_k,s3)
                  do tmp_j = 1, nO_S(s2)
                    j = tmp_j + shift_occ(s2)
                    h2 = list_occ(tmp_j,s2)
                    if (s2 == s3 .and. j <= k) cycle
                    do tmp_i = 1, nO_S(s1)
                      i = tmp_i + shift_occ(s1)
                      h1 = list_occ(tmp_i,s1)
                      if (s1 == s2 .and. i <= j) cycle
                      
                      if (dabs(c3_bc(i,j,k,a)) >= thresh_coef) then
                        call apply_hole(det, s1, h1, res1, ok, N_int)
                        call apply_hole(res1, s2, h2, res2, ok, N_int)
                        call apply_hole(res2, s3, h3, res3, ok, N_int)
                        call apply_particle(res3, s1, p1, res4, ok, N_int)
                        call apply_particle(res4, s2, p2, res5, ok, N_int)
                        call apply_particle(res5, s3, p3, tmp_det(1,1,idx_coef), ok, N_int)
                        !call get_excitation(psi_det(1,1,1),tmp_det(1,1,idx_coef),exc,degree,phase,N_int)
                        call get_phase_general(det,tmp_det(1,1,idx_coef),phase,degree,N_int)
                        tmp_coef(idx_coef) = c3_bc(i,j,k,a) * phase
                        idx_coef = idx_coef + 1
                      endif
                      
                    enddo
                  enddo
                enddo
              enddo
            enddo
          enddo
        enddo
      enddo
    enddo
    print*,'C3: Done'
  endif
  
  !c4
  if (extract_c4) then
    do s1 = 1, 2
      do s2 = s1, 2
        do s3 = s2, 2
          do s4 = s3, 2
            do tmp_d = 1, nV_S(s4)
              d = tmp_d + shift_vir(s4)
              p4 = list_vir(tmp_d,s4)
              do tmp_c = 1, nV_S(s3)
                c = tmp_c + shift_vir(s3)
                p3 = list_vir(tmp_c,s3)
                if (s3 == s4 .and. c <= d) cycle
                do tmp_b = 1, nV_S(s2)
                  b = tmp_b + shift_vir(s2)
                  p2 = list_vir(tmp_b,s2)
                  if (s2 == s3 .and. b <= c) cycle
                  do tmp_a = 1, nV_S(s1)
                    a = tmp_a + shift_vir(s1)
                    p1 = list_vir(tmp_a,s1)
                    if (s1 == s2 .and. a <= b) cycle
                    ! C4 for a,b,c and d fixed
                    call extract_c4_abcd(nO,nV,t1,t2,a,b,c,d,c4_abcd)
                    do tmp_l = 1, nO_S(s4)
                      l = tmp_l + shift_occ(s4)
                      h4 = list_occ(tmp_l,s4)
                      do tmp_k = 1, nO_S(s3)
                         k = tmp_k + shift_occ(s3)
                         h3 = list_occ(tmp_k,s3)
                         if (s3 == s4 .and. k <= l) cycle
                        do tmp_j = 1, nO_S(s2)
                          j = tmp_j + shift_occ(s2)
                          h2 = list_occ(tmp_j,s2)
                          if (s2 == s3 .and. j <= k) cycle
                          do tmp_i = 1, nO_S(s1)
                            i = tmp_i + shift_occ(s1)
                            h1 = list_occ(tmp_i,s1)
                            if (s1 == s2 .and. i <= j) cycle
                            
                            if (dabs(c4_abcd(i,j,k,l)) >= thresh_coef) then
                              call apply_hole(det, s1, h1, res1, ok, N_int)
                              call apply_hole(res1, s2, h2, res2, ok, N_int)
                              call apply_hole(res2, s3, h3, res3, ok, N_int)
                              call apply_hole(res3, s4, h4, res4, ok, N_int)
                              call apply_particle(res4, s1, p1, res5, ok, N_int)
                              call apply_particle(res5, s2, p2, res6, ok, N_int)
                              call apply_particle(res6, s3, p3, res7, ok, N_int)
                              call apply_particle(res7, s4, p4, tmp_det(1,1,idx_coef), ok, N_int)
                              !call get_excitation(psi_det(1,1,1),tmp_det(1,1,idx_coef),exc,degree,phase,N_int)
                              call get_phase_general(det,tmp_det(1,1,idx_coef),phase,degree,N_int)
                              tmp_coef(idx_coef) = c4_abcd(i,j,k,l) * phase
                              idx_coef = idx_coef + 1
                            endif
                            
                          enddo
                        enddo
                      enddo
                    enddo
                  enddo
                enddo
              enddo
            enddo
          enddo
        enddo
      enddo
    enddo
    print*,'C4: Done'
  endif

  deallocate(t1,c1,t2,c2,c3_bc,c4_abcd)

  ! Sort the det wrt their coef
  allocate(l_coef(nb_coef), l_det(N_int,2,nb_coef))
  abs_coef = dabs(tmp_coef)
  allocate(key(nb_coef))
  do i = 1, nb_coef
    key(i) = i
  enddo
  call dsort(-abs_coef, key, nb_coef)
  do i = 1, nb_coef
    l_coef(i)    = tmp_coef(key(i))
    l_det(:,:,i) = tmp_det(:,:,key(i))
  enddo
  deallocate(key,tmp_coef,abs_coef,tmp_det)

  ! Normalization
  norm = 0d0
  do i = 1, nb_coef
    norm = norm + l_coef(i)**2
  enddo
  norm = dsqrt(norm)
  factor = 1d0 / norm

  l_coef = l_coef * factor

  ! print
  print*,'N_det', nb_coef
  !do i = 1, nb_coef
  !   print*,l_coef(i)
  !  call print_det(l_det(1,1,i),N_int)
  !  print*,''
  !enddo

  !call overlap_wf(nb_coef,l_det,l_coef)
  !call overlap_wf_safe(nb_coef,l_det,l_coef)
  call overlap_fast(l_det,l_coef,1,nb_coef,psi_det,psi_coef,N_states,N_det)

  !if (write_cc_wf) then
  !  ! Save the wave function
  !  print*,'Save the wave function...'
  !  ! Save a one det wf
  !  call save_det_cc(1, N_states, l_det, l_coef)
  !  ! Just to have a large enough psi_det vector...
  !  if (nb_coef > N_det) then
  !    call fill_H_apply_buffer_no_selection(nb_coef-N_det,l_det,N_int,0)
  !    call copy_H_apply_buffer_to_wf
  !    SOFT_TOUCH psi_det psi_coef N_det !N_det_beta_unique N_det_alpha_unique psi_det_alpha_unique psi_det_beta_unique
  !  endif
  !  ! Save the wave function
  !  call save_det_cc(nb_coef, N_states, l_det, l_coef)
  !  print*,'Done'
  !endif

  call save_wf_cc(l_det,l_coef,nb_coef)

  call u_0_S2_u_0(s2_val,l_coef,nb_coef,l_det,N_int,1,nb_coef)
  print*,''
  print*,'S^2 =', s2_val
  print*,''

  deallocate(l_coef,l_det)

end
#+end_src

** Extract c
#+begin_src f90 :org comments :tangle extract_c.irp.f
subroutine extract_c2(nO,nV,t1,t2,c2)

  implicit none

  integer, intent(in)           :: nO,nV
  double precision, intent(in)  :: t1(nO,nV), t2(nO,nO,nV,nV)
  double precision, intent(out) :: c2(nO,nO,nV,nV)
  integer                       :: i,j,a,b

  do b = 1, nV
    do a = 1, nV
      do j = 1, nO
        do i = 1, nO
          c2(i,j,a,b) = t2(i,j,a,b) + t1(i,a) * t1(j,b) - t1(i,b) * t1(j,a)
        enddo
      enddo
    enddo
  enddo
  
end
#+end_src

#+begin_src f90 :org comments :tangle extract_c.irp.f
subroutine extract_c3(nO,nV,t1,t2,c3)

  implicit none

  integer, intent(in)           :: nO,nV
  double precision, intent(in)  :: t1(nO,nV), t2(nO,nO,nV,nV)
  double precision, intent(out) :: c3(nO,nO,nO,nV,nV,nV)
  integer                       :: i,j,k,a,b,c

  do c = 1, nV
    do b = 1, nV
      do a = 1, nV
        do k = 1, nO
          do j = 1, nO
            do i = 1, nO
              c3(i,j,k,a,b,c) = - ( &
               t1(i,c) * t1(j,b) * t1(k,a) - t1(i,b) * t1(j,c) * t1(k,a) - & 
               t1(i,c) * t1(j,a) * t1(k,b) + t1(i,a) * t1(j,c) * t1(k,b) + &
               t1(i,b) * t1(j,a) * t1(k,c) - t1(i,a) * t1(j,b) * t1(k,c) - &
               t1(k,c) * t2(i,j,a,b) + t1(k,b) * t2(i,j,a,c) - &
               t1(k,a) * t2(i,j,b,c) + t1(j,c) * t2(i,k,a,b) - &
               t1(j,b) * t2(i,k,a,c) + t1(j,a) * t2(i,k,b,c) - &
               t1(i,c) * t2(j,k,a,b) + t1(i,b) * t2(j,k,a,c) - &
               t1(i,a) * t2(j,k,b,c))
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo

  
end
#+end_src

#+begin_src f90 :org comments :tangle extract_c.irp.f
subroutine extract_c3_bc(nO,nV,t1,t2,b,c,c3_bc)

  implicit none

  integer, intent(in) :: nO,nV,b,c
  double precision, intent(in) :: t1(nO,nV), t2(nO,nO,nV,nV)
  
  double precision, intent(out) :: c3_bc(nO,nO,nO,nV)

  integer :: i,j,k,a

  do a = 1, nV
    do k = 1, nO
      do j = 1, nO
        do i = 1, nO
          c3_bc(i,j,k,a) = - t1(i, c) * t1(j, b) * t1(k, a) &
          + t1(i, b) * t1(j, c) * t1(k, a) + t1(i, c) * t1(j, a) * t1(k, b) &
          - t1(i, a) * t1(j, c) * t1(k, b) - t1(i, b) * t1(j, a) * t1(k, c) &
          + t1(i, a) * t1(j, b) * t1(k, c) + t1(k, c) * t2(i, j, a, b) &
          - t1(k, b) * t2(i, j, a, c) + t1(k, a) * t2(i, j, b, c) &
          - t1(j, c) * t2(i, k, a, b) + t1(j, b) * t2(i, k, a, c) &
          - t1(j, a) * t2(i, k, b, c) + t1(i, c) * t2(j, k, a, b) &
          - t1(i, b) * t2(j, k, a, c) + t1(i, a) * t2(j, k, b, c)
          !if ( dabs(c3_bc(i,j,k,a)) > 0d0) then
          !     print*,i,j,k,a,b,c
          !     print*,c3_bc(i,j,k,a)
          !     print*, - t1(i, c) * t1(j, b) * t1(k, a), &
          !     + t1(i, b) * t1(j, c) * t1(k, a),  + t1(i, c) * t1(j, a) * t1(k, b), &
          !     - t1(i, a) * t1(j, c) * t1(k, b), - t1(i, b) * t1(j, a) * t1(k, c), &
          !     + t1(i, a) * t1(j, b) * t1(k, c)
          !endif
        enddo
      enddo
    enddo
  enddo

end
#+end_src

#+begin_src f90 :org comments :tangle extract_c.irp.f
subroutine extract_c4_abcd(nO,nV,t1,t2,a,b,c,d,c4_abcd)

  implicit none

  integer, intent(in) :: nO,nV,a,b,c,d
  double precision, intent(in) :: t1(nO,nV), t2(nO,nO,nV,nV)
  
  double precision, intent(out) :: c4_abcd(nO,nO,nO,nO)

  integer :: i,j,k,l

  do l = 1, nO
    do k = 1, nO
      do j = 1, nO
        do i = 1, nO             
          c4_abcd(i,j,k,l) = &
            t1(i, d) * t1(j, c) * t1(k, b) * t1(l, a) - & 
            t1(i, c) * t1(j, d) * t1(k, b) * t1(l, a) - & 
            t1(i, d) * t1(j, b) * t1(k, c) * t1(l, a) + & 
            t1(i, b) * t1(j, d) * t1(k, c) * t1(l, a) + & 
            t1(i, c) * t1(j, b) * t1(k, d) * t1(l, a) - & 
            t1(i, b) * t1(j, c) * t1(k, d) * t1(l, a) - & 
            t1(i, d) * t1(j, c) * t1(k, a) * t1(l, b) + & 
            t1(i, c) * t1(j, d) * t1(k, a) * t1(l, b) + & 
            t1(i, d) * t1(j, a) * t1(k, c) * t1(l, b) - & 
            t1(i, a) * t1(j, d) * t1(k, c) * t1(l, b) - & 
            t1(i, c) * t1(j, a) * t1(k, d) * t1(l, b) + & 
            t1(i, a) * t1(j, c) * t1(k, d) * t1(l, b) + & 
            t1(i, d) * t1(j, b) * t1(k, a) * t1(l, c) - & 
            t1(i, b) * t1(j, d) * t1(k, a) * t1(l, c) - & 
            t1(i, d) * t1(j, a) * t1(k, b) * t1(l, c) + & 
            t1(i, a) * t1(j, d) * t1(k, b) * t1(l, c) + & 
            t1(i, b) * t1(j, a) * t1(k, d) * t1(l, c) - & 
            t1(i, a) * t1(j, b) * t1(k, d) * t1(l, c) - & 
            t1(i, c) * t1(j, b) * t1(k, a) * t1(l, d) + & 
            t1(i, b) * t1(j, c) * t1(k, a) * t1(l, d) + & 
            t1(i, c) * t1(j, a) * t1(k, b) * t1(l, d) - & 
            t1(i, a) * t1(j, c) * t1(k, b) * t1(l, d) - & 
            t1(i, b) * t1(j, a) * t1(k, c) * t1(l, d) + & 
            t1(i, a) * t1(j, b) * t1(k, c) * t1(l, d) - & 
            t1(k, d) * t1(l, c) * t2(i, j, a, b) + & 
            t1(k, c) * t1(l, d) * t2(i, j, a, b) + & 
            t1(k, d) * t1(l, b) * t2(i, j, a, c) - & 
            t1(k, b) * t1(l, d) * t2(i, j, a, c) - & 
            t1(k, c) * t1(l, b) * t2(i, j, a, d) + & 
            t1(k, b) * t1(l, c) * t2(i, j, a, d) - & 
            t1(k, d) * t1(l, a) * t2(i, j, b, c) + & 
            t1(k, a) * t1(l, d) * t2(i, j, b, c) + & 
            t1(k, c) * t1(l, a) * t2(i, j, b, d) - & 
            t1(k, a) * t1(l, c) * t2(i, j, b, d) - & 
            t1(k, b) * t1(l, a) * t2(i, j, c, d) + & 
            t1(k, a) * t1(l, b) * t2(i, j, c, d) + & 
            t1(j, d) * t1(l, c) * t2(i, k, a, b) - & 
            t1(j, c) * t1(l, d) * t2(i, k, a, b) - & 
            t1(j, d) * t1(l, b) * t2(i, k, a, c) + & 
            t1(j, b) * t1(l, d) * t2(i, k, a, c) + & 
            t1(j, c) * t1(l, b) * t2(i, k, a, d) - & 
            t1(j, b) * t1(l, c) * t2(i, k, a, d) + & 
            t1(j, d) * t1(l, a) * t2(i, k, b, c) - & 
            t1(j, a) * t1(l, d) * t2(i, k, b, c) - & 
            t1(j, c) * t1(l, a) * t2(i, k, b, d) + & 
            t1(j, a) * t1(l, c) * t2(i, k, b, d) + & 
            t1(j, b) * t1(l, a) * t2(i, k, c, d) - & 
            t1(j, a) * t1(l, b) * t2(i, k, c, d) - & 
            t1(j, d) * t1(k, c) * t2(i, l, a, b) + & 
            t1(j, c) * t1(k, d) * t2(i, l, a, b) + & 
            t1(j, d) * t1(k, b) * t2(i, l, a, c) - & 
            t1(j, b) * t1(k, d) * t2(i, l, a, c) - & 
            t1(j, c) * t1(k, b) * t2(i, l, a, d) + & 
            t1(j, b) * t1(k, c) * t2(i, l, a, d) - & 
            t1(j, d) * t1(k, a) * t2(i, l, b, c) + & 
            t1(j, a) * t1(k, d) * t2(i, l, b, c) + & 
            t1(j, c) * t1(k, a) * t2(i, l, b, d) - & 
            t1(j, a) * t1(k, c) * t2(i, l, b, d) - & 
            t1(j, b) * t1(k, a) * t2(i, l, c, d) + & 
            t1(j, a) * t1(k, b) * t2(i, l, c, d) - & 
            t1(i, d) * t1(l, c) * t2(j, k, a, b) + & 
            t1(i, c) * t1(l, d) * t2(j, k, a, b) + & 
            t2(i, l, c, d) * t2(j, k, a, b) +      & 
            t1(i, d) * t1(l, b) * t2(j, k, a, c) - & 
            t1(i, b) * t1(l, d) * t2(j, k, a, c) - &
            t2(i, l, b, d) * t2(j, k, a, c) -      &
            t1(i, c) * t1(l, b) * t2(j, k, a, d) + & 
            t1(i, b) * t1(l, c) * t2(j, k, a, d) + &
            t2(i, l, b, c) * t2(j, k, a, d) -      &
            t1(i, d) * t1(l, a) * t2(j, k, b, c) + & 
            t1(i, a) * t1(l, d) * t2(j, k, b, c) + &
            t2(i, l, a, d) * t2(j, k, b, c) +      &
            t1(i, c) * t1(l, a) * t2(j, k, b, d) - & 
            t1(i, a) * t1(l, c) * t2(j, k, b, d) - &
            t2(i, l, a, c) * t2(j, k, b, d) -      &
            t1(i, b) * t1(l, a) * t2(j, k, c, d) + & 
            t1(i, a) * t1(l, b) * t2(j, k, c, d) + &
            t2(i, l, a, b) * t2(j, k, c, d) +      &
            t1(i, d) * t1(k, c) * t2(j, l, a, b) - & 
            t1(i, c) * t1(k, d) * t2(j, l, a, b) - &
            t2(i, k, c, d) * t2(j, l, a, b) -      &
            t1(i, d) * t1(k, b) * t2(j, l, a, c) + & 
            t1(i, b) * t1(k, d) * t2(j, l, a, c) + &
            t2(i, k, b, d) * t2(j, l, a, c) +      &
            t1(i, c) * t1(k, b) * t2(j, l, a, d) - & 
            t1(i, b) * t1(k, c) * t2(j, l, a, d) - &
            t2(i, k, b, c) * t2(j, l, a, d) +      &
            t1(i, d) * t1(k, a) * t2(j, l, b, c) - & 
            t1(i, a) * t1(k, d) * t2(j, l, b, c) - &
            t2(i, k, a, d) * t2(j, l, b, c) -      &
            t1(i, c) * t1(k, a) * t2(j, l, b, d) + & 
            t1(i, a) * t1(k, c) * t2(j, l, b, d) + &
            t2(i, k, a, c) * t2(j, l, b, d) +      &
            t1(i, b) * t1(k, a) * t2(j, l, c, d) - & 
            t1(i, a) * t1(k, b) * t2(j, l, c, d) - &
            t2(i, k, a, b) * t2(j, l, c, d) -      &
            t1(i, d) * t1(j, c) * t2(k, l, a, b) + &
            t1(i, c) * t1(j, d) * t2(k, l, a, b) + &
            t2(i, j, c, d) * t2(k, l, a, b) +      &
            t1(i, d) * t1(j, b) * t2(k, l, a, c) - & 
            t1(i, b) * t1(j, d) * t2(k, l, a, c) - &
            t2(i, j, b, d) * t2(k, l, a, c) -      &
            t1(i, c) * t1(j, b) * t2(k, l, a, d) + &
            t1(i, b) * t1(j, c) * t2(k, l, a, d) + &
            t2(i, j, b, c) * t2(k, l, a, d) -      &
            t1(i, d) * t1(j, a) * t2(k, l, b, c) + & 
            t1(i, a) * t1(j, d) * t2(k, l, b, c) + &
            t2(i, j, a, d) * t2(k, l, b, c) +      &
            t1(i, c) * t1(j, a) * t2(k, l, b, d) - &
            t1(i, a) * t1(j, c) * t2(k, l, b, d) - &
            t2(i, j, a, c) * t2(k, l, b, d) -      &
            t1(i, b) * t1(j, a) * t2(k, l, c, d) + & 
            t1(i, a) * t1(j, b) * t2(k, l, c, d) + &
            t2(i, j, a, b) * t2(k, l, c, d)
        enddo
      enddo
    enddo
  enddo

end
#+end_src

#+begin_src
c1(i,a) = t1(i, a)

c2(i,j,a,b) = -t1(i, b) * t1(j, a) + t1(i, a) * t1(j, b) + 
  t2(i, j, a, b)

c3(i,j,k,a,b,c) = -t1(i, c) * t1(j, b) * t1(k, a) + 
  t1(i, b) * t1(j, c) * t1(k, a) + t1(i, c) * t1(j, a) * t1(k, b) - 
  t1(i, a) * t1(j, c) * t1(k, b) - t1(i, b) * t1(j, a) * t1(k, c) + 
  t1(i, a) * t1(j, b) * t1(k, c) + t1(k, c) * t2(i, j, a, b) - 
  t1(k, b) * t2(i, j, a, c) + t1(k, a) * t2(i, j, b, c) - 
  t1(j, c) * t2(i, k, a, b) + t1(j, b) * t2(i, k, a, c) - 
  t1(j, a) * t2(i, k, b, c) + t1(i, c) * t2(j, k, a, b) - 
  t1(i, b) * t2(j, k, a, c) + t1(i, a) * t2(j, k, b, c) + 
  t3(i, j, k, a, b, c)

c4(i,j,k,l,a,b,c,d) =
  t1(i, d) * t1(j, c) * t1(k, b) * t1(l, a) - 
  t1(i, c) * t1(j, d) * t1(k, b) * t1(l, a) - 
  t1(i, d) * t1(j, b) * t1(k, c) * t1(l, a) + 
  t1(i, b) * t1(j, d) * t1(k, c) * t1(l, a) + 
  t1(i, c) * t1(j, b) * t1(k, d) * t1(l, a) - 
  t1(i, b) * t1(j, c) * t1(k, d) * t1(l, a) - 
  t1(i, d) * t1(j, c) * t1(k, a) * t1(l, b) + 
  t1(i, c) * t1(j, d) * t1(k, a) * t1(l, b) + 
  t1(i, d) * t1(j, a) * t1(k, c) * t1(l, b) - 
  t1(i, a) * t1(j, d) * t1(k, c) * t1(l, b) - 
  t1(i, c) * t1(j, a) * t1(k, d) * t1(l, b) + 
  t1(i, a) * t1(j, c) * t1(k, d) * t1(l, b) + 
  t1(i, d) * t1(j, b) * t1(k, a) * t1(l, c) - 
  t1(i, b) * t1(j, d) * t1(k, a) * t1(l, c) - 
  t1(i, d) * t1(j, a) * t1(k, b) * t1(l, c) + 
  t1(i, a) * t1(j, d) * t1(k, b) * t1(l, c) + 
  t1(i, b) * t1(j, a) * t1(k, d) * t1(l, c) - 
  t1(i, a) * t1(j, b) * t1(k, d) * t1(l, c) - 
  t1(i, c) * t1(j, b) * t1(k, a) * t1(l, d) + 
  t1(i, b) * t1(j, c) * t1(k, a) * t1(l, d) + 
  t1(i, c) * t1(j, a) * t1(k, b) * t1(l, d) - 
  t1(i, a) * t1(j, c) * t1(k, b) * t1(l, d) - 
  t1(i, b) * t1(j, a) * t1(k, c) * t1(l, d) + 
  t1(i, a) * t1(j, b) * t1(k, c) * t1(l, d) - 
  t1(k, d) * t1(l, c) * t2(i, j, a, b) + 
  t1(k, c) * t1(l, d) * t2(i, j, a, b) + 
  t1(k, d) * t1(l, b) * t2(i, j, a, c) - 
  t1(k, b) * t1(l, d) * t2(i, j, a, c) - 
  t1(k, c) * t1(l, b) * t2(i, j, a, d) + 
  t1(k, b) * t1(l, c) * t2(i, j, a, d) - 
  t1(k, d) * t1(l, a) * t2(i, j, b, c) + 
  t1(k, a) * t1(l, d) * t2(i, j, b, c) + 
  t1(k, c) * t1(l, a) * t2(i, j, b, d) - 
  t1(k, a) * t1(l, c) * t2(i, j, b, d) - 
  t1(k, b) * t1(l, a) * t2(i, j, c, d) + 
  t1(k, a) * t1(l, b) * t2(i, j, c, d) + 
  t1(j, d) * t1(l, c) * t2(i, k, a, b) - 
  t1(j, c) * t1(l, d) * t2(i, k, a, b) - 
  t1(j, d) * t1(l, b) * t2(i, k, a, c) + 
  t1(j, b) * t1(l, d) * t2(i, k, a, c) + 
  t1(j, c) * t1(l, b) * t2(i, k, a, d) - 
  t1(j, b) * t1(l, c) * t2(i, k, a, d) + 
  t1(j, d) * t1(l, a) * t2(i, k, b, c) - 
  t1(j, a) * t1(l, d) * t2(i, k, b, c) - 
  t1(j, c) * t1(l, a) * t2(i, k, b, d) + 
  t1(j, a) * t1(l, c) * t2(i, k, b, d) + 
  t1(j, b) * t1(l, a) * t2(i, k, c, d) - 
  t1(j, a) * t1(l, b) * t2(i, k, c, d) - 
  t1(j, d) * t1(k, c) * t2(i, l, a, b) + 
  t1(j, c) * t1(k, d) * t2(i, l, a, b) + 
  t1(j, d) * t1(k, b) * t2(i, l, a, c) - 
  t1(j, b) * t1(k, d) * t2(i, l, a, c) - 
  t1(j, c) * t1(k, b) * t2(i, l, a, d) + 
  t1(j, b) * t1(k, c) * t2(i, l, a, d) - 
  t1(j, d) * t1(k, a) * t2(i, l, b, c) + 
  t1(j, a) * t1(k, d) * t2(i, l, b, c) + 
  t1(j, c) * t1(k, a) * t2(i, l, b, d) - 
  t1(j, a) * t1(k, c) * t2(i, l, b, d) - 
  t1(j, b) * t1(k, a) * t2(i, l, c, d) + 
  t1(j, a) * t1(k, b) * t2(i, l, c, d) - 
  t1(i, d) * t1(l, c) * t2(j, k, a, b) + 
  t1(i, c) * t1(l, d) * t2(j, k, a, b) + t2(i, l, c, d) * t2(j, k, a, b) + 
  t1(i, d) * t1(l, b) * t2(j, k, a, c) - 
  t1(i, b) * t1(l, d) * t2(j, k, a, c) - t2(i, l, b, d) * t2(j, k, a, c) - 
  t1(i, c) * t1(l, b) * t2(j, k, a, d) + 
  t1(i, b) * t1(l, c) * t2(j, k, a, d) + t2(i, l, b, c) * t2(j, k, a, d) - 
  t1(i, d) * t1(l, a) * t2(j, k, b, c) + 
  t1(i, a) * t1(l, d) * t2(j, k, b, c) + t2(i, l, a, d) * t2(j, k, b, c) + 
  t1(i, c) * t1(l, a) * t2(j, k, b, d) - 
  t1(i, a) * t1(l, c) * t2(j, k, b, d) - t2(i, l, a, c) * t2(j, k, b, d) - 
  t1(i, b) * t1(l, a) * t2(j, k, c, d) + 
  t1(i, a) * t1(l, b) * t2(j, k, c, d) + t2(i, l, a, b) * t2(j, k, c, d) + 
  t1(i, d) * t1(k, c) * t2(j, l, a, b) - 
  t1(i, c) * t1(k, d) * t2(j, l, a, b) - t2(i, k, c, d) * t2(j, l, a, b) - 
  t1(i, d) * t1(k, b) * t2(j, l, a, c) + 
  t1(i, b) * t1(k, d) * t2(j, l, a, c) + t2(i, k, b, d) * t2(j, l, a, c) + 
  t1(i, c) * t1(k, b) * t2(j, l, a, d) - 
  t1(i, b) * t1(k, c) * t2(j, l, a, d) - t2(i, k, b, c) * t2(j, l, a, d) + 
  t1(i, d) * t1(k, a) * t2(j, l, b, c) - 
  t1(i, a) * t1(k, d) * t2(j, l, b, c) - t2(i, k, a, d) * t2(j, l, b, c) - 
  t1(i, c) * t1(k, a) * t2(j, l, b, d) + 
  t1(i, a) * t1(k, c) * t2(j, l, b, d) + t2(i, k, a, c) * t2(j, l, b, d) + 
  t1(i, b) * t1(k, a) * t2(j, l, c, d) - 
  t1(i, a) * t1(k, b) * t2(j, l, c, d) - t2(i, k, a, b) * t2(j, l, c, d) - 
  t1(i, d) * t1(j, c) * t2(k, l, a, b) + 
  t1(i, c) * t1(j, d) * t2(k, l, a, b) + t2(i, j, c, d) * t2(k, l, a, b) + 
  t1(i, d) * t1(j, b) * t2(k, l, a, c) - 
  t1(i, b) * t1(j, d) * t2(k, l, a, c) - t2(i, j, b, d) * t2(k, l, a, c) - 
  t1(i, c) * t1(j, b) * t2(k, l, a, d) + 
  t1(i, b) * t1(j, c) * t2(k, l, a, d) + t2(i, j, b, c) * t2(k, l, a, d) - 
  t1(i, d) * t1(j, a) * t2(k, l, b, c) + 
  t1(i, a) * t1(j, d) * t2(k, l, b, c) + t2(i, j, a, d) * t2(k, l, b, c) + 
  t1(i, c) * t1(j, a) * t2(k, l, b, d) - 
  t1(i, a) * t1(j, c) * t2(k, l, b, d) - t2(i, j, a, c) * t2(k, l, b, d) - 
  t1(i, b) * t1(j, a) * t2(k, l, c, d) + 
  t1(i, a) * t1(j, b) * t2(k, l, c, d) + t2(i, j, a, b) * t2(k, l, c, d) + 
  t1(l, d) * t3(i, j, k, a, b, c) - t1(l, c) * t3(i, j, k, a, b, d) + 
  t1(l, b) * t3(i, j, k, a, c, d) - t1(l, a) * t3(i, j, k, b, c, d) - 
  t1(k, d) * t3(i, j, l, a, b, c) + t1(k, c) * t3(i, j, l, a, b, d) - 
  t1(k, b) * t3(i, j, l, a, c, d) + t1(k, a) * t3(i, j, l, b, c, d) + 
  t1(j, d) * t3(i, k, l, a, b, c) - t1(j, c) * t3(i, k, l, a, b, d) + 
  t1(j, b) * t3(i, k, l, a, c, d) - t1(j, a) * t3(i, k, l, b, c, d) - 
  t1(i, d) * t3(j, k, l, a, b, c) + t1(i, c) * t3(j, k, l, a, b, d) - 
  t1(i, b) * t3(j, k, l, a, c, d) + t1(i, a) * t3(j, k, l, b, c, d) + 
  t4(i, j, k, l, a, b, c, d)

#+end_src

* Experimental

#+begin_src f90 :comments org :tangle exp_c.irp.f
program exp
  implicit none

  integer :: nO,nV
  double precision,allocatable :: t1(:,:),t2(:,:,:,:)

  read_wf = .True.
  touch read_wf
  
  nO = cc_nOab
  nV = cc_nVab

  allocate(t1(nO,nV),t2(nO,nO,nV,nV))

  call read_t1(nO,nV,t1)
  call read_t2(nO,nV,t2)
  
  call smart_xc(nO,nV,t1,t2)
  
end
#+end_src

** Test
#+begin_src f90 :comments org :tangle exp_c.irp.f
subroutine smart_xc(nO,nV,t1_full,t2_full)

  implicit none

  integer, intent(in) ::nO,nV
  double precision, intent(in) :: t1_full(nO,nV), t2_full(nO,nO,nV,nV)

  integer :: i,j,k,l,a,b,c,d
  double precision, allocatable :: t1(:), t2(:), t11(:)
  double precision, allocatable :: t111(:), t12(:)
  double precision, allocatable :: t1111(:), t112(:), t22(:)
  integer, allocatable :: tmp_idx(:,:), t1_idx(:,:), t2_idx(:,:), t11_idx(:,:)
  integer, allocatable :: t111_idx(:,:), t12_idx(:,:)
  integer, allocatable :: t1111_idx(:,:), t112_idx(:,:), t22_idx(:,:)
  integer :: sze_t1, sze_t11, sze_t2, sze_t111, sze_t12
  integer :: sze_t1111, sze_t112, sze_t22
  integer :: new_sze_t11, new_sze_t22
  integer :: new_sze_t12, new_sze_t112, new_sze_t111,new_sze_t1111
  logical :: must_exit, all_t1, all_t2

  double precision :: thresh, thresh_t1, thresh_t2, fact
  double precision :: s2_val
  double precision :: f_norm
  integer          :: count, sze, sze_max, idx

  all_t1 = .True.
  all_t2 = .False.

  ! Thresh
  thresh = thresh_extract_c

  if (all_t1) then
    thresh_t1 = 1d-16
  else
    thresh_t1 = thresh
  endif

  if (all_t2) then
    thresh_t2 = 1d-16
  else
    thresh_t2 = thresh
  endif
  
  ! T
  ! t1
  idx = 0
  do a = 1, nV
    do i = 1, nO
      if (dabs(t1_full(i,a)) >= thresh_t1) then
        if (i > cc_nOa .and. a <= cc_nVa) cycle
        if (i <= cc_nOa .and. a > cc_nVa) cycle
        idx = idx + 1
      endif
    enddo
  enddo

  sze_t1 = idx
  allocate(t1(sze_t1),t1_idx(2,sze_t1))
  
  idx = 1
  do a = 1, nV
    do i = 1, nO
      if (dabs(t1_full(i,a)) >= thresh_t1) then
        if (i > cc_nOa .and. a <= cc_nVa) cycle
        if (i <= cc_nOa .and. a > cc_nVa) cycle
        t1(idx) = t1_full(i,a)
        t1_idx(1,idx) = i
        t1_idx(2,idx) = a
        idx = idx + 1
      endif
    enddo
  enddo
  ! Sort
  call sort_by_coef_idx(t1,t1_idx,sze_t1,2)

  ! t2
  idx = 0
  do b = 1, nV
    do a = b+1, nV
      do j = 1, nO
        do i = j+1, nO
          if (dabs(t2_full(i,j,a,b)) >= thresh_t2) then
            if (i <= cc_nOa .and. j <= cc_nOa .and. (a > cc_nVa .or. b > cc_nVa)) cycle
            if (i > cc_nOa .and. j > cc_nOa .and. (a <= cc_nVa .or. b <= cc_nVa)) cycle
            if (a > cc_nVa .and. b > cc_nVa .and. (i <= cc_nOa .or. j <= cc_nOa)) cycle
            if (a <= cc_nVa .and. b <= cc_nVa .and. (i > cc_nOa .or. j > cc_nOa)) cycle
            idx = idx + 1
          endif
        enddo
      enddo
    enddo
  enddo

  sze_t2 = idx
  allocate(t2(sze_t2),t2_idx(4,sze_t2))
   
  idx = 1
  do b = 1, nV
    do a = b+1, nV
      do j = 1, nO
        do i = j+1, nO
          if (dabs(t2_full(i,j,a,b)) >= thresh_t2) then
             
            if (i <= cc_nOa .and. j <= cc_nOa .and. (a > cc_nVa .or. b > cc_nVa)) cycle
            if (i > cc_nOa .and. j > cc_nOa .and. (a <= cc_nVa .or. b <= cc_nVa)) cycle
            if (a > cc_nVa .and. b > cc_nVa .and. (i <= cc_nOa .or. j <= cc_nOa)) cycle
            if (a <= cc_nVa .and. b <= cc_nVa .and. (i > cc_nOa .or. j > cc_nOa)) cycle
            t2(idx) = t2_full(i,j,a,b)
            t2_idx(1,idx) = i
            t2_idx(2,idx) = j
            t2_idx(3,idx) = a
            t2_idx(4,idx) = b
            idx = idx + 1
          endif
        enddo
      enddo
    enddo
  enddo
  ! Sort
  call sort_by_coef_idx(t2,t2_idx,sze_t2,4)
  ! Reorder the index of each t
  call reorder_t_idx(t2,t2_idx,sze_t2,4)

  ! T3 from (T)
  ! Only for canonical orbitals !!!
  ! Check
  do i = 1, N_int
    if (psi_det(i,1,cc_ref) /= hf_bitmask(i,1) .or. &
        psi_det(i,2,cc_ref) /= hf_bitmask(i,2)) then
      print*,'T3 only available for HF reference with canonical orbitals'
      print*,'Reference used:'
      call print_det(psi_det(1,1,cc_ref))
      call abort
    endif
  enddo
  
  do j = 1, mo_num
    do i = 1, mo_num
      if (i == j) cycle
      if (dabs(fock_matrix_mo(i,j)) > 1e-4) then
        print*,'T3 only available for HF reference with canonical orbitals'
        print*,'Non-zero off-diagonal elements detected:'
        print*,i,j,fock_matrix_mo(i,j)
        call abort
      endif
    enddo
  enddo
  
  double precision, allocatable :: f_o(:), f_v(:), f_oo(:,:), f_vv(:,:)
  double precision, allocatable :: v_ooov(:,:,:,:), v_vvvo(:,:,:,:)
  double precision :: delta, delta_abc, acc
  double precision, allocatable :: t3(:)
  integer, allocatable :: t3_idx(:,:)
  integer :: sze_t3,m,e
  integer :: sze_t13, new_sze_t13
  double precision, allocatable :: t13(:)
  integer, allocatable :: t13_idx(:,:)

  allocate(f_oo(nO,nO),f_vv(nV,nV),f_o(nO),f_v(nV))
  allocate(v_ooov(nO,nO,nO,nV),v_vvvo(nV,nV,nV,nO))
  
  ! Fock elements
  call gen_f_spin(psi_det(1,1,cc_ref), cc_nO_m,cc_nO_m, cc_nO_S,cc_nO_S, cc_list_occ_spin,cc_list_occ_spin, nO,nO, f_oo)
  call gen_f_spin(psi_det(1,1,cc_ref), cc_nV_m,cc_nV_m, cc_nV_S,cc_nV_S, cc_list_vir_spin,cc_list_vir_spin, nV,nV, f_vv)

  ! Diag elements
  do i = 1, nO
    f_o(i) = f_oo(i,i)
  enddo
  do i = 1, nV
    f_v(i) = f_vv(i,i)
  enddo
  
  call gen_v_spin(cc_nO_m,cc_nO_m,cc_nO_m,cc_nV_m, &
       cc_nO_S,cc_nO_S,cc_nO_S,cc_nV_S, &
       cc_list_occ_spin,cc_list_occ_spin,cc_list_occ_spin,cc_list_vir_spin, &
       nO,nO,nO,nV, v_ooov)
  
  call gen_v_spin(cc_nV_m,cc_nV_m,cc_nV_m,cc_nO_m, &
       cc_nV_S,cc_nV_S,cc_nV_S,cc_nO_S, &
       cc_list_vir_spin,cc_list_vir_spin,cc_list_vir_spin,cc_list_occ_spin, &
       nV,nV,nV,nO, v_vvvo)

  !idx = 0
  !do c = 1, nV-2
  !  do b = c+1, nV-1
  !    do a = b+1, nV
  !      delta_abc = f_v(a) + f_v(b) + f_v(c)
  !      do k = 1, nO-2
  !        do j = k+1, nO-1
  !          do i = j+1, nO
  !            acc = 0d0
  !            delta = f_o(i) + f_o(j) + f_o(k) - delta_abc
  !            do e = 1, nV
  !              !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
  !              acc = acc &
  !                + t2_full(j,k,a,e) * v_vvvo(b,c,e,i) &
  !                - t2_full(i,k,a,e) * v_vvvo(b,c,e,j) & ! - P(ij)
  !                - t2_full(j,i,a,e) * v_vvvo(b,c,e,k) & ! - P(ik)
  !                - t2_full(j,k,b,e) * v_vvvo(a,c,e,i) & ! - P(ab)
  !                - t2_full(j,k,c,e) * v_vvvo(b,a,e,i) & ! - P(ac)
  !                + t2_full(i,k,b,e) * v_vvvo(a,c,e,j) & ! + P(ij) P(ab)
  !                + t2_full(i,k,c,e) * v_vvvo(b,a,e,j) & ! + P(ij) P(ac)
  !                + t2_full(j,i,b,e) * v_vvvo(a,c,e,k) & ! + P(ik) P(ab)
  !                + t2_full(j,i,c,e) * v_vvvo(b,a,e,k)   ! + P(ik) P(ac)
  !            enddo
  !            do m = 1, nO
  !              !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
  !              acc = acc &
  !                + t2_full(m,i,b,c) * v_ooov(j,k,m,a) &
  !                - t2_full(m,j,b,c) * v_ooov(i,k,m,a) & ! - P(ij)
  !                - t2_full(m,k,b,c) * v_ooov(j,i,m,a) & ! - P(ik)
  !                - t2_full(m,i,a,c) * v_ooov(j,k,m,b) & ! - P(ab)
  !                - t2_full(m,i,b,a) * v_ooov(j,k,m,c) & ! - P(ac)
  !                + t2_full(m,j,a,c) * v_ooov(i,k,m,b) & ! + P(ij) P(ab)
  !                + t2_full(m,j,b,a) * v_ooov(i,k,m,c) & ! + P(ij) P(ac)
  !                + t2_full(m,k,a,c) * v_ooov(j,i,m,b) & ! + P(ik) P(ab)
  !                + t2_full(m,k,b,a) * v_ooov(j,i,m,c)   ! + P(ik) P(ac)
  !            enddo
  !            !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) * (1d0 / delta)
  !            acc = acc / delta
  !            if (dabs(acc) >= thresh) then
  !              idx = idx + 1
  !            endif
  !          enddo
  !        enddo
  !      enddo
  !    enddo
  !  enddo
  !enddo

  !sze_t3 = idx
  !print*,'nb(t3)',sze_t3
  !allocate(t3(sze_t3), t3_idx(6,sze_t3))
  !
  !idx = 1
  !do c = 1, nV-2
  !  do b = c+1, nV-1
  !    do a = b+1, nV
  !      delta_abc = f_v(a) + f_v(b) + f_v(c)
  !      do k = 1, nO-2
  !        do j = k+1, nO-1
  !          do i = j+1, nO
  !            acc = 0d0
  !            delta = f_o(i) + f_o(j) + f_o(k) - delta_abc
  !            do e = 1, nV
  !              !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
  !              acc = acc &
  !                + t2_full(j,k,a,e) * v_vvvo(b,c,e,i) &
  !                - t2_full(i,k,a,e) * v_vvvo(b,c,e,j) & ! - P(ij)
  !                - t2_full(j,i,a,e) * v_vvvo(b,c,e,k) & ! - P(ik)
  !                - t2_full(j,k,b,e) * v_vvvo(a,c,e,i) & ! - P(ab)
  !                - t2_full(j,k,c,e) * v_vvvo(b,a,e,i) & ! - P(ac)
  !                + t2_full(i,k,b,e) * v_vvvo(a,c,e,j) & ! + P(ij) P(ab)
  !                + t2_full(i,k,c,e) * v_vvvo(b,a,e,j) & ! + P(ij) P(ac)
  !                + t2_full(j,i,b,e) * v_vvvo(a,c,e,k) & ! + P(ik) P(ab)
  !                + t2_full(j,i,c,e) * v_vvvo(b,a,e,k)   ! + P(ik) P(ac)
  !            enddo
  !            do m = 1, nO
  !              !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) &
  !              acc = acc &
  !                + t2_full(m,i,b,c) * v_ooov(j,k,m,a) &
  !                - t2_full(m,j,b,c) * v_ooov(i,k,m,a) & ! - P(ij)
  !                - t2_full(m,k,b,c) * v_ooov(j,i,m,a) & ! - P(ik)
  !                - t2_full(m,i,a,c) * v_ooov(j,k,m,b) & ! - P(ab)
  !                - t2_full(m,i,b,a) * v_ooov(j,k,m,c) & ! - P(ac)
  !                + t2_full(m,j,a,c) * v_ooov(i,k,m,b) & ! + P(ij) P(ab)
  !                + t2_full(m,j,b,a) * v_ooov(i,k,m,c) & ! + P(ij) P(ac)
  !                + t2_full(m,k,a,c) * v_ooov(j,i,m,b) & ! + P(ik) P(ab)
  !                + t2_full(m,k,b,a) * v_ooov(j,i,m,c)   ! + P(ik) P(ac)
  !            enddo
  !            !t3(i,j,k,a,b,c) = t3(i,j,k,a,b,c) * (1d0 / delta)
  !            acc = acc / delta
  !            if (dabs(acc) >= thresh) then
  !              t3(idx) = acc
  !              t3_idx(1,idx) = i
  !              t3_idx(2,idx) = j
  !              t3_idx(3,idx) = k
  !              t3_idx(4,idx) = a
  !              t3_idx(5,idx) = b
  !              t3_idx(6,idx) = c
  !              idx = idx + 1
  !            endif
  !          enddo
  !        enddo
  !      enddo
  !    enddo
  !  enddo
  !enddo
  !print*,'||T3||',f_norm(t3,sze_t3)
  !! Sort
  !call sort_by_coef_idx(t3,t3_idx,sze_t3,6)
  !! Reorder the index of each t
  !call reorder_t_idx(t3,t3_idx,sze_t3,6)

  ! TODO
  ! 1. Can be speed up by sorting t... and t..._idx
  ! do i
  !   do j 
  !     if (|t...(i) * t...(j)| <= thresh) exit

  ! TODO
  ! 1. Can be speed up by sorting t... and t..._idx
  ! do i
  !   do j 
  !     if (|t...(i) * t...(j)| <= thresh) exit
  ! 2. List containing the ending pos to do
  ! do i = 1, end_to_small
  !   do j = 1, end(i)

  ! T^2
  ! t11
  idx = 0
  do i = 1, sze_t1-1
    do j = i+1, sze_t1
      if (dabs(t1(i) * t1(j)) >= thresh) then
        ! The resulting coeff can't contain 2 times the same spin orbital index
        if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(2,i) == t1_idx(2,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t11 = idx
  allocate(t11(sze_t11),t11_idx(4,sze_t11))
        
  idx = 1
  do i = 1, sze_t1-1
    do j = i+1, sze_t1
      if (dabs(t1(i) * t1(j)) >= thresh) then
        if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(2,i) == t1_idx(2,j)) cycle
        t11(idx) = t1(i) * t1(j)
        t11_idx(1,idx) = t1_idx(1,i)
        t11_idx(3,idx) = t1_idx(2,i)
        t11_idx(2,idx) = t1_idx(1,j)
        t11_idx(4,idx) = t1_idx(2,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  ! Sort
  call sort_by_coef_idx(t11,t11_idx,sze_t11,4)
  ! Reorder the index of each t
  call reorder_t_idx(t11,t11_idx,sze_t11,4)

  sze_t111 = 0
  sze_t12 = 0
  sze_t112 = 0
  sze_t1111 = 0
  sze_t22 = 0

  ! t12
  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t2
      if (dabs(t1(i) * t2(j)) >= thresh) then
        if (t1_idx(1,i) == t2_idx(1,j) .or. t1_idx(1,i) == t2_idx(2,j) .or. &
            t1_idx(2,i) == t2_idx(3,j) .or. t1_idx(2,i) == t2_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  sze_t12 = idx
  allocate(t12(sze_t12),t12_idx(6,sze_t12))
        
  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t2
      if (dabs(t1(i) * t2(j)) >= thresh) then
        if (t1_idx(1,i) == t2_idx(1,j) .or. t1_idx(1,i) == t2_idx(2,j) .or. &
            t1_idx(2,i) == t2_idx(3,j) .or. t1_idx(2,i) == t2_idx(4,j)) cycle
        t12(idx) = t1(i) * t2(j)
        t12_idx(1,idx) = t1_idx(1,i)
        t12_idx(4,idx) = t1_idx(2,i)
        t12_idx(2,idx) = t2_idx(1,j)
        t12_idx(3,idx) = t2_idx(2,j)
        t12_idx(5,idx) = t2_idx(3,j)
        t12_idx(6,idx) = t2_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo 
  ! Sort
  call sort_by_coef_idx(t12,t12_idx,sze_t12,6)
  ! Reorder the index of each t
  call reorder_t_idx(t12,t12_idx,sze_t12,6)
  
  !! t13
  !idx = 0
  !do i = 1, sze_t1
  !  do j = 1, sze_t3
  !    if (dabs(t1(i) * t3(j)) >= thresh) then
  !      if (t1_idx(1,i) == t3_idx(1,j) .or. t1_idx(1,i) == t3_idx(2,j) .or. &
  !          t1_idx(1,i) == t3_idx(3,j) .or. &
  !          t1_idx(2,i) == t3_idx(4,j) .or. t1_idx(2,i) == t3_idx(5,j) .or. &
  !          t1_idx(2,i) == t3_idx(6,j)) cycle
  !      idx = idx + 1
  !    else
  !      exit
  !    endif
  !  enddo
  !enddo
  !
  !sze_t13 = idx
  !allocate(t13(sze_t13),t13_idx(8,sze_t13))
  !      
  !idx = 1
  !do i = 1, sze_t1
  !  do j = 1, sze_t3
  !    if (dabs(t1(i) * t3(j)) >= thresh) then
  !      if (t1_idx(1,i) == t3_idx(1,j) .or. t1_idx(1,i) == t3_idx(2,j) .or. &
  !          t1_idx(1,i) == t3_idx(3,j) .or. &
  !          t1_idx(2,i) == t3_idx(4,j) .or. t1_idx(2,i) == t3_idx(5,j) .or. &
  !          t1_idx(2,i) == t3_idx(6,j)) cycle
  !      t13(idx) = t1(i) * t3(j)
  !      t13_idx(1,idx) = t1_idx(1,i)
  !      t13_idx(5,idx) = t1_idx(2,i)
  !      t13_idx(2,idx) = t3_idx(1,j)
  !      t13_idx(3,idx) = t3_idx(2,j)
  !      t13_idx(4,idx) = t3_idx(3,j)
  !      t13_idx(6,idx) = t3_idx(4,j)
  !      t13_idx(7,idx) = t3_idx(5,j)
  !      t13_idx(8,idx) = t3_idx(6,j)
  !      idx = idx + 1
  !    else
  !      exit
  !    endif
  !  enddo
  !enddo 
  !! Sort
  !call sort_by_coef_idx(t13,t13_idx,sze_t13,8)
  !! Reorder the index of each t
  !call reorder_t_idx(t13,t13_idx,sze_t13,8)
  
  ! t22
  idx = 0
  do i = 1, sze_t2-1
    do j = i+1, sze_t2
      if (dabs(t2(i) * t2(j)) >= thresh) then
        if (t2_idx(1,i) == t2_idx(1,j) .or. t2_idx(1,i) == t2_idx(2,j) .or. &
            t2_idx(2,i) == t2_idx(1,j) .or. t2_idx(2,i) == t2_idx(2,j) .or. &
            t2_idx(3,i) == t2_idx(3,j) .or. t2_idx(3,i) == t2_idx(4,j) .or. &
            t2_idx(4,i) == t2_idx(3,j) .or. t2_idx(4,i) == t2_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t22 = idx
  allocate(t22(sze_t22),t22_idx(8,sze_t22))
        
  idx = 1
  do i = 1, sze_t2-1
    do j = i+1, sze_t2
      if (dabs(t2(i) * t2(j)) >= thresh) then
        if (t2_idx(1,i) == t2_idx(1,j) .or. t2_idx(1,i) == t2_idx(2,j) .or. &
            t2_idx(2,i) == t2_idx(1,j) .or. t2_idx(2,i) == t2_idx(2,j) .or. &
            t2_idx(3,i) == t2_idx(3,j) .or. t2_idx(3,i) == t2_idx(4,j) .or. &
            t2_idx(4,i) == t2_idx(3,j) .or. t2_idx(4,i) == t2_idx(4,j)) cycle
        t22(idx) = t2(i) * t2(j)
        t22_idx(1,idx) = t2_idx(1,i)
        t22_idx(2,idx) = t2_idx(2,i)
        t22_idx(5,idx) = t2_idx(3,i)
        t22_idx(6,idx) = t2_idx(4,i)
        t22_idx(3,idx) = t2_idx(1,j)
        t22_idx(4,idx) = t2_idx(2,j)
        t22_idx(7,idx) = t2_idx(3,j)
        t22_idx(8,idx) = t2_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  ! Sort
  call sort_by_coef_idx(t22,t22_idx,sze_t22,8)
  ! Reorder the index of each t
  call reorder_t_idx(t22,t22_idx,sze_t22,8)

  ! T^3
  ! t111
  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t11
      if (dabs(t1(i) * t11(j)) >= thresh) then
        !if (t1_idx(1,i) == t11_idx(1,j) .or. t1_idx(1,i) == t11_idx(2,j) .or. &
        !    t1_idx(2,i) == t11_idx(3,j) .or. t1_idx(2,i) == t11_idx(4,j)) cycle
        if (t1_idx(1,i) >= t11_idx(1,j) .or. t1_idx(2,i) == t11_idx(3,j) .or. &
            t1_idx(2,i) == t11_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  
  !idx=0
  !do i = 1, sze_t1-2
  !  do j = i+1, sze_t1-1
  !    do k = j+1, sze_t1
  !      if (dabs(t1(i) * t1(j) * t1(k)) >= thresh) then
  !      if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(1,i) == t1_idx(1,k) .or. &
  !          t1_idx(2,i) == t1_idx(2,j) .or. t1_idx(2,i) == t1_idx(2,k) .or. &
  !          t1_idx(1,j) == t1_idx(1,k) .or. t1_idx(2,j) == t1_idx(2,k) ) cycle
  !      idx = idx + 1
  !      endif
  !    enddo
  !  enddo
  !enddo

  sze_t111 = idx
  allocate(t111(sze_t111),t111_idx(6,sze_t111))
        
  idx = 1
  !fact = 1d0/3d0
  do i = 1, sze_t1
    do j = 1, sze_t11
      if (dabs(t1(i) * t11(j)) >= thresh) then
        !if (t1_idx(1,i) == t11_idx(1,j) .or. t1_idx(1,i) == t11_idx(2,j) .or. &
        !    t1_idx(2,i) == t11_idx(3,j) .or. t1_idx(2,i) == t11_idx(4,j)) cycle
        if (t1_idx(1,i) >= t11_idx(1,j) .or. t1_idx(2,i) == t11_idx(3,j) .or. &
            t1_idx(2,i) == t11_idx(4,j)) cycle
        t111(idx) = t1(i) * t11(j) !* fact
        t111_idx(1,idx) = t1_idx(1,i)
        t111_idx(4,idx) = t1_idx(2,i)
        t111_idx(2,idx) = t11_idx(1,j)
        t111_idx(3,idx) = t11_idx(2,j)
        t111_idx(5,idx) = t11_idx(3,j)
        t111_idx(6,idx) = t11_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  !do i = 1, sze_t1-2
  !  do j = i+1, sze_t1-1
  !    do k = j+1, sze_t1
  !      if (dabs(t1(i) * t1(j) * t1(k)) >= thresh) then
  !      if (t1_idx(1,i) == t1_idx(1,j) .or. t1_idx(1,i) == t1_idx(1,k) .or. &
  !          t1_idx(2,i) == t1_idx(2,j) .or. t1_idx(2,i) == t1_idx(2,k) .or. &
  !          t1_idx(1,j) == t1_idx(1,k) .or. t1_idx(2,j) == t1_idx(2,k) ) cycle
  !      t111(idx) = t1(i) * t1(j) * t1(k)
  !      t111_idx(1,idx) = t1_idx(1,i)
  !      t111_idx(4,idx) = t1_idx(2,i)
  !      t111_idx(2,idx) = t1_idx(1,j)
  !      t111_idx(5,idx) = t1_idx(2,j)
  !      t111_idx(3,idx) = t1_idx(1,k)
  !      t111_idx(6,idx) = t1_idx(2,k)
  !      !print*,t111(idx)
  !      !print*,t1_idx(:,i),t1_idx(:,j),t1_idx(:,k)
  !      !print*,t111_idx(:,idx)
  !      idx = idx + 1
  !      endif
  !    enddo
  !  enddo
  !enddo
         
  ! Sort
  call sort_by_coef_idx(t111,t111_idx,sze_t111,6)
  ! Reorder the index of each t
  call reorder_t_idx(t111,t111_idx,sze_t111,6)

  ! t112
   idx = 0
  do i = 1, sze_t11
    do j = 1, sze_t2
      if (dabs(t11(i) * t2(j)) >= thresh) then
        if (t11_idx(1,i) == t2_idx(1,j) .or. t11_idx(1,i) == t2_idx(2,j) .or. &
            t11_idx(2,i) == t2_idx(1,j) .or. t11_idx(2,i) == t2_idx(2,j) .or. &
            t11_idx(3,i) == t2_idx(3,j) .or. t11_idx(3,i) == t2_idx(4,j) .or. &
            t11_idx(4,i) == t2_idx(3,j) .or. t11_idx(4,i) == t2_idx(4,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t112 = idx
  allocate(t112(sze_t112),t112_idx(8,sze_t112))
        
  idx = 1
  do i = 1, sze_t11
    do j = 1, sze_t2
      if (dabs(t11(i) * t2(j)) >= thresh) then
        if (t11_idx(1,i) == t2_idx(1,j) .or. t11_idx(1,i) == t2_idx(2,j) .or. &
            t11_idx(2,i) == t2_idx(1,j) .or. t11_idx(2,i) == t2_idx(2,j) .or. &
            t11_idx(3,i) == t2_idx(3,j) .or. t11_idx(3,i) == t2_idx(4,j) .or. &
            t11_idx(4,i) == t2_idx(3,j) .or. t11_idx(4,i) == t2_idx(4,j)) cycle
        t112(idx) = t11(i) * t2(j)
        t112_idx(1,idx) = t11_idx(1,i)
        t112_idx(2,idx) = t11_idx(2,i)
        t112_idx(5,idx) = t11_idx(3,i)
        t112_idx(6,idx) = t11_idx(4,i)
        t112_idx(3,idx) = t2_idx(1,j)
        t112_idx(4,idx) = t2_idx(2,j)
        t112_idx(7,idx) = t2_idx(3,j)
        t112_idx(8,idx) = t2_idx(4,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  ! Sort
  call sort_by_coef_idx(t112,t112_idx,sze_t112,8)
  ! Reorder the index of each t
  call reorder_t_idx(t112,t112_idx,sze_t112,8)

  ! T^4
  ! t1111
  idx = 0
  do i = 1, sze_t1
    do j = 1, sze_t111
      if (dabs(t1(i) * t111(j)) >= thresh) then
        !if (t1_idx(1,i) == t111_idx(1,j) .or. t1_idx(1,i) == t111_idx(2,j) .or. &
        !    t1_idx(1,i) == t111_idx(3,j) .or. &
        !    t1_idx(2,i) == t111_idx(4,j) .or. t1_idx(2,i) == t111_idx(5,j) .or. &
        !    t1_idx(2,i) == t111_idx(6,j)) cycle
        if (t1_idx(1,i) >= t111_idx(1,j) .or. t1_idx(2,i) == t111_idx(4,j) .or. &
            t1_idx(2,i) == t111_idx(5,j) .or. t1_idx(2,i) == t111_idx(6,j)) cycle
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo

  sze_t1111 = idx
  allocate(t1111(sze_t1111),t1111_idx(8,sze_t1111))
        
  idx = 1
  do i = 1, sze_t1
    do j = 1, sze_t111
      if (dabs(t1(i) * t111(j)) >= thresh) then
        !if (t1_idx(1,i) == t111_idx(1,j) .or. t1_idx(1,i) == t111_idx(2,j) .or. &
        !    t1_idx(1,i) == t111_idx(3,j) .or. &
        !    t1_idx(2,i) == t111_idx(4,j) .or. t1_idx(2,i) == t111_idx(5,j) .or. &
        !    t1_idx(2,i) == t111_idx(6,j)) cycle
        if (t1_idx(1,i) >= t111_idx(1,j) .or. t1_idx(2,i) == t111_idx(4,j) .or. &
            t1_idx(2,i) == t111_idx(5,j) .or. t1_idx(2,i) == t111_idx(6,j)) cycle
        t1111(idx) = t1(i) * t111(j)
        t1111_idx(1,idx) = t1_idx(1,i)
        t1111_idx(5,idx) = t1_idx(2,i)
        t1111_idx(2,idx) = t111_idx(1,j)
        t1111_idx(3,idx) = t111_idx(2,j)
        t1111_idx(4,idx) = t111_idx(3,j)
        t1111_idx(6,idx) = t111_idx(4,j)
        t1111_idx(7,idx) = t111_idx(5,j)
        t1111_idx(8,idx) = t111_idx(6,j)
        idx = idx + 1
      else
        exit
      endif
    enddo
  enddo
  ! Sort
  call sort_by_coef_idx(t1111,t1111_idx,sze_t1111,8)
  ! Reorder the index of each t
  call reorder_t_idx(t1111,t1111_idx,sze_t1111,8)

  ! Recursive sort after the reordering
  call recursive_sort_idx(t11,t11_idx,sze_t11,4,1)
  call recursive_sort_idx(t12,t12_idx,sze_t12,6,1)
  !call recursive_sort_idx(t13,t13_idx,sze_t13,8,1)
  call recursive_sort_idx(t22,t22_idx,sze_t22,8,1)

  call recursive_sort_idx(t111,t111_idx,sze_t111,6,1)
  call recursive_sort_idx(t112,t112_idx,sze_t112,8,1)
  
  call recursive_sort_idx(t1111,t1111_idx,sze_t1111,8,1)
  
  ! Remove the duplicate and accumulate
  call remove_duplicate_idx(t11,t11_idx,sze_t11,4,new_sze_t11)
  call remove_duplicate_idx(t12,t12_idx,sze_t12,6,new_sze_t12)
  !call remove_duplicate_idx(t13,t13_idx,sze_t13,8,new_sze_t13)
  call remove_duplicate_idx(t22,t22_idx,sze_t22,8,new_sze_t22)
  
  call remove_duplicate_idx(t111,t111_idx,sze_t111,6,new_sze_t111)
  call remove_duplicate_idx(t112,t112_idx,sze_t112,8,new_sze_t112)
  
  call remove_duplicate_idx(t1111,t1111_idx,sze_t1111,8,new_sze_t1111)
  
  sze_t11 = new_sze_t11
  sze_t12 = new_sze_t12
  !sze_t13 = new_sze_t13
  sze_t22 = new_sze_t22
  
  sze_t111 = new_sze_t111
  sze_t112 = new_sze_t112

  sze_t1111 = new_sze_t1111

  write(*,'(A6,A10,A12)')     '     ', '  N'    , 'Norm' 
  write(*,'(A6,I10,1pE12.4)') 't1   ', sze_t1   , f_norm(t1   ,sze_t1   )
  write(*,'(A6,I10,1pE12.4)') 't2   ', sze_t2   , f_norm(t2   ,sze_t2   )
  !write(*,'(A6,I10,1pE12.4)') 't3   ', sze_t3   , f_norm(t3   ,sze_t3   )
  write(*,'(A6,I10,1pE12.4)') 't11  ', sze_t11  , f_norm(t11  ,sze_t11  )
  write(*,'(A6,I10,1pE12.4)') 't12  ', sze_t12  , f_norm(t12  ,sze_t12  )
  !write(*,'(A6,I10,1pE12.4)') 't13  ', sze_t13  , f_norm(t13  ,sze_t13  )
  write(*,'(A6,I10,1pE12.4)') 't111 ', sze_t111 , f_norm(t111 ,sze_t111 )
  write(*,'(A6,I10,1pE12.4)') 't22  ', sze_t22  , f_norm(t22  ,sze_t22  )
  write(*,'(A6,I10,1pE12.4)') 't112 ', sze_t112 , f_norm(t112 ,sze_t112 )
  write(*,'(A6,I10,1pE12.4)') 't1111', sze_t1111, f_norm(t1111,sze_t1111)

  ! Gather list with the same number of indexes
  integer, allocatable :: c1_idx(:,:), c2_idx(:,:), c3_idx(:,:), c4_idx(:,:)
  double precision, allocatable :: c1(:), c2(:), c3(:), c4(:)
  integer :: sze_c1, sze_c2, sze_c3, sze_c4
  integer :: new_sze_c2, new_sze_c3, new_sze_c4

  sze_c1 = sze_t1
  sze_c2 = sze_t11 + sze_t2
  sze_c3 = sze_t111 + sze_t12 !+ sze_t3
  sze_c4 = sze_t1111 + sze_t112 + sze_t22 !+ sze_t13

  allocate(c1_idx(2,sze_c1), c2_idx(4,sze_c2))
  allocate(c3_idx(6,sze_c3))
  allocate(c4_idx(8,sze_c4))
  allocate(c1(sze_c1), c2(sze_c2))
  allocate(c3(sze_c3))
  allocate(c4(sze_c4))

  ! C1
  do i = 1, sze_t1
    c1(i) = t1(i)
    c1_idx(:,i) = t1_idx(:,i)
  enddo

  ! C2
  do i = 1, sze_t2
    c2(i) = t2(i)
    c2_idx(:,i) = t2_idx(:,i)
  enddo
  k = sze_t2
  do i = 1, sze_t11
    c2(k+i) = t11(i)
    c2_idx(:,k+i) = t11_idx(:,i)
  enddo

  ! C3
  do i = 1, sze_t12
    c3(i) = t12(i)
    c3_idx(:,i) = t12_idx(:,i)
  enddo
  k = sze_t12
  do i = 1, sze_t111
    c3(k+i) = t111(i)
    c3_idx(:,k+i) = t111_idx(:,i)
  enddo
  !k = k + sze_t111
  !do i = 1, sze_t3
  !  c3(k+i) = t3(i)
  !  c3_idx(:,k+i) = t3_idx(:,i)
  !enddo 

  ! C4
  do i = 1, sze_t22
    c4(i) = t22(i)
    c4_idx(:,i) = t22_idx(:,i)
  enddo
  k = sze_t22
  do i = 1, sze_t112
    c4(k+i) = t112(i)
    c4_idx(:,k+i) = t112_idx(:,i)
  enddo
  k = k + sze_t112
  do i = 1, sze_t1111
    c4(k+i) = t1111(i)
    c4_idx(:,k+i) = t1111_idx(:,i)
  enddo
  !k = k + sze_t1111
  !do i = 1, sze_t13
  !  c4(k+i) = t13(i)
  !  c4_idx(:,k+i) = t13_idx(:,i)
  !enddo

  ! Sort
  call recursive_sort_idx(c2,c2_idx,sze_c2,4,1)
  call recursive_sort_idx(c3,c3_idx,sze_c3,6,1)
  call recursive_sort_idx(c4,c4_idx,sze_c4,8,1)
  
  ! Remove the duplicate and accumulate
  call remove_duplicate_idx(c2,c2_idx,sze_c2,4,new_sze_c2)
  call remove_duplicate_idx(c3,c3_idx,sze_c3,6,new_sze_c3)
  call remove_duplicate_idx(c4,c4_idx,sze_c4,8,new_sze_c4)

  sze_c2 = new_sze_c2
  sze_c3 = new_sze_c3
  sze_c4 = new_sze_c4

  print*,''
  write(*,'(A6,I10,1pE12.4)') 'C1   ', sze_c1, f_norm(c1,sze_c1)
  write(*,'(A6,I10,1pE12.4)') 'C2   ', sze_c2, f_norm(c2,sze_c2)
  write(*,'(A6,I10,1pE12.4)') 'C3   ', sze_c3, f_norm(c3,sze_c3)
  write(*,'(A6,I10,1pE12.4)') 'C4   ', sze_c4, f_norm(c4,sze_c4)

  ! Build the determinants
  integer(bit_kind), allocatable :: c1_det(:,:,:), c2_det(:,:,:)
  integer(bit_kind), allocatable :: c3_det(:,:,:), c4_det(:,:,:)
  double precision, allocatable :: c1_coef(:), c2_coef(:), c3_coef(:), c4_coef(:)

  allocate(c1_det(N_int,2,sze_c1),c1_coef(sze_c1))
  allocate(c2_det(N_int,2,sze_c2),c2_coef(sze_c2))
  allocate(c3_det(N_int,2,sze_c3),c3_coef(sze_c3))
  allocate(c4_det(N_int,2,sze_c4),c4_coef(sze_c4))

  call build_det_t(c1,c1_idx,sze_c1,2,c1_det,c1_coef)
  call build_det_t(c2,c2_idx,sze_c2,4,c2_det,c2_coef)
  call build_det_t(c3,c3_idx,sze_c3,6,c3_det,c3_coef)
  call build_det_t(c4,c4_idx,sze_c4,8,c4_det,c4_coef)

  integer :: sze_cc
  integer(bit_kind), allocatable :: psi_det_cc(:,:,:)
  double precision, allocatable :: psi_coef_cc(:)

  sze_cc = 1 + sze_c1 + sze_c2 + sze_c3 + sze_c4

  allocate(psi_det_cc(N_int,2,sze_cc),psi_coef_cc(sze_cc))

  ! Ref
  psi_coef_cc(1) = 1d0
  psi_det_cc(:,:,1) = psi_det(:,:,cc_ref)

  ! C1
  k = 1
  do i = 1, sze_c1
    psi_coef_cc(k+i) = c1_coef(i)
    psi_det_cc(:,:,k+i) = c1_det(:,:,i)
  enddo

  ! C2
  k = k + sze_c1
  do i = 1, sze_c2
    psi_coef_cc(k+i) = c2_coef(i)
    psi_det_cc(:,:,k+i) = c2_det(:,:,i)
  enddo

  ! C3
  k = k + sze_c2
  do i = 1, sze_c3
    psi_coef_cc(k+i) = c3_coef(i)
    psi_det_cc(:,:,k+i) = c3_det(:,:,i)
  enddo
  
  ! C4
  k = k + sze_c3
  do i = 1, sze_c4
    psi_coef_cc(k+i) = c4_coef(i)
    psi_det_cc(:,:,k+i) = c4_det(:,:,i)
  enddo

  write(*,'(A6,I10,1pE12.4)') ' Psi  ', sze_cc, f_norm(psi_coef_cc, sze_cc)

  double precision ::phase,norm
  integer :: degree
  integer(bit_kind) :: det(N_int,2)
  
  ! Phase
  norm = 1d0
  det(:,:) = psi_det_cc(:,:,1)
  do i = 2, sze_cc
    !call print_det(psi_det_cc(1,1,i),N_int)
    call get_phase_general(det,psi_det_cc(1,1,i),phase,degree,N_int)
    psi_coef_cc(i) = psi_coef_cc(i) * phase
    norm = norm + psi_coef_cc(i)**2
  enddo
  
  double precision :: energy
  call i_H_psi(psi_det_cc(1,1,1),psi_det_cc,psi_coef_cc,N_int,sze_cc,sze_cc,1,energy)
  print*,''
  print*,'<0|H|Psi> =',energy+nuclear_repulsion

  ! Normalization
  norm = 1d0/dsqrt(norm)
  do i = 1, sze_cc
    psi_coef_cc(i) = psi_coef_cc(i) * norm
  enddo
  
  ! Sort by ci coef
  call sort_by_coef_det(psi_coef_cc,psi_det_cc,sze_cc,N_int)
  !do i = sze_cc, 1, -1
  !   call print_det(psi_det_cc(1,1,i),N_int)
  !   call print_det(psi_det(1,1,i),N_int)
  !   print*,psi_coef_cc(i),psi_coef(i,1),psi_coef_cc(i)-psi_coef(i,1)
  !enddo

  ! Overlap
  !call overlap_wf_safe(sze_cc,psi_det_cc,psi_coef_cc)
  call overlap_fast(psi_det,psi_coef,N_states,N_det,psi_det_cc,psi_coef_cc,1,sze_cc)

  ! S^2
  call u_0_S2_u_0(s2_val,psi_coef_cc,sze_cc,psi_det_cc,N_int,1,sze_cc)
  print*,''
  print*,'S^2 =', s2_val
  print*,''
  
  ! Save wf
  call save_wf_cc(psi_det_cc,psi_coef_cc,sze_cc)
  touch psi_det psi_coef

  print*,''
  print*,'<Psi|H|Psi>/<Psi|Psi> =',psi_energy+nuclear_repulsion
  print*,''
  
end
#+end_src

** Reorder t_idx
#+begin_src f90 :comments org :tangle exp_c.irp.f
subroutine reorder_t_idx(t,t_idx,sze_t,n_idx)
 
  implicit none

  BEGIN_DOC
  ! Order the indexes of each t
  END_DOC

  integer, intent(in) :: sze_t, n_idx
  integer, intent(inout) :: t_idx(n_idx,sze_t)
  double precision, intent(inout) :: t(sze_t)
  
  integer :: i,j,k,o,s
  integer, allocatable :: tmp_t_idx(:,:), p_f(:), idx(:), p_i(:), iorder(:)
  double precision, allocatable :: tmp_t(:)
  double precision :: sign
  integer :: dist, n_cross, n_pairs

  do i = 1, sze_t
    sign = 1d0
    call reorder_t_idx_rec(t_idx(1,i),n_idx/2,sign,1)
    call reorder_t_idx_rec(t_idx(n_idx/2+1,i),n_idx/2,sign,1)
    t(i) = t(i) * sign
  enddo

  return
  
  allocate(tmp_t(sze_t), tmp_t_idx(n_idx,sze_t),idx(n_idx/2))
  allocate(iorder(n_idx/2))
  
  do i = 1, sze_t
    ! Sort of the idx
    dist = 0
    n_cross = 0
    ! Loop over occ and vir spin orbitals
    do o = 1, 2
      if (o == 2) then
         s = n_idx/2
      else
         s = 0
      endif
         
      do j = 1, n_idx/2
        idx(j) = t_idx(s+j,i)
        iorder(j) = j
      enddo
      call isort(idx,iorder,n_idx/2)

      ! "Distance"
      n_pairs = 0
      do j = 1, n_idx/2
        dist = dist + abs(iorder(j) - j)
        if (abs(iorder(j) - j) /= 0) then
          n_pairs = n_pairs + 1
        endif
      enddo
      
      !allocate(p_f(n_pairs),p_i(n_pairs))
      !k = 1
      !do j = 1, n_idx/2
      !  if (abs(iorder(j) - j) /= 0) then
      !    p_i(k) = min(j,iorder(j))
      !    p_f(k) = max(j,iorder(j))
      !    k = k + 1
      !  endif
      !enddo
 
      !! Crossing : ...p_i(j) ... p_i(k) ... p_f(j) ... p_f(k)...
      !do j = 1, n_pairs
      !  do k = j+1, n_pairs
      !    print*,'p',p_i(j),p_i(k),p_f(j),p_f(k)
      !    if ( ( p_f(k) > p_f(j) ) .and. ( p_i(k) < p_f(j) ) .and. ( p_i(k) > p_i(j) ) ) then
      !      n_cross = n_cross + 1
      !    endif
      !  enddo
      !enddo
      !deallocate(p_f,p_i)

      do j = 1, n_idx/2
        tmp_t_idx(s+j,i) = idx(j)
      enddo
    enddo
    ! Final sign
    !print*,'1',t_idx(:,i)
    !print*,'2',tmp_t_idx(:,i)
    sign = dble((-1)**(dist/2))!+n_cross))
    !print*,dist,sign
    tmp_t(i) = t(i) * sign
  enddo

  ! Apply changes
  do i = 1, sze_t
    t(i) = tmp_t(i)
    t_idx(:,i) = tmp_t_idx(:,i)
    !print*,i,t_idx(:,i)
  enddo
    
  deallocate(tmp_t,tmp_t_idx,idx)
  
end

recursive subroutine reorder_t_idx_rec(t_idx,nb_idx,sign,idx)

  implicit none

  integer, intent(in) :: nb_idx,idx
  integer, intent(inout) :: t_idx(nb_idx)
  double precision, intent(inout) :: sign
  integer :: tmp,i

  if (idx < nb_idx) then
    if (t_idx(idx) > t_idx(idx+1)) then
      tmp = t_idx(idx)
      t_idx(idx) = t_idx(idx+1)
      t_idx(idx+1) = tmp
      sign = - sign
      if (idx > 1) then
        i = idx - 1
      else
        i = idx + 1
      endif
    else
      i = idx + 1
    endif
    call reorder_t_idx_rec(t_idx,nb_idx,sign,i)
  else
    return
  endif
 
end
#+end_src

** Build det
#+begin_src f90 :comments org :tangle exp_c.irp.f
subroutine build_det_t(t,t_idx,sze_t,n_idx,psi_det_t,psi_coef_t)

  implicit none

  integer, intent(in) :: sze_t, n_idx, t_idx(n_idx,sze_t)
  double precision, intent(in) :: t(sze_t)

  integer(bit_kind), intent(out) :: psi_det_t(N_int,2,sze_t)
  double precision, intent(out) :: psi_coef_t(sze_t)

  integer :: i,j,k
  integer :: s,h,p
  logical :: ok
  integer(bit_kind) :: det(N_int,2),res(N_int,2)  
  
  do i = 1, sze_t
    det(:,:) = psi_det(:,:,cc_ref)
    !print*,t_idx(:,i)
    
    ! Holes
    do j = 1, n_idx/2
      h = t_idx(j,i)
      if (h > cc_nOa) then
        h = h - cc_nOa
        s = 2
      else
        s = 1
      endif
      h = cc_list_occ_spin(h,s)
      !call print_det(det,N_int)
      call apply_hole(det,s,h,res,ok,N_int)
      if (.not. ok) then
        print*,'big problem h'
        print*,t_idx(:,i)
        print*,t_idx(j,i),s,h
        call abort
      endif
      det = res
    enddo

    ! Particles
    do j = n_idx/2+1, n_idx
      p = t_idx(j,i)
      if (p > cc_nVa) then
        p = p - cc_nVa
        s = 2
      else
        s = 1
      endif
      p = cc_list_vir_spin(p,s)
      !p = p + cc_nO_S(s)
      !p = p + n_core_orb
      call apply_particle(det,s,p,res,ok,N_int)
      if (.not. ok) then
        print*,'big problem p'
        call abort
      endif
      det = res
    enddo
    psi_det_t(:,:,i) = det(:,:)
    psi_coef_t(i) = t(i)
    !call print_det(det,N_int)
    !print*,psi_coef_t(i),psi_det_t(1,1,i),psi_det_t(1,2,i)
  enddo

end
#+end_src

** Det way
*** Sort det
#+begin_src f90 :comments org :tangle exp_c.irp.f
subroutine sort_det(psi_det_t,psi_coef_t,sze)

  implicit none

  integer, intent(in) :: sze
  integer(bit_kind), intent(inout) :: psi_det_t(N_int,2,sze)
  double precision, intent(inout) :: psi_coef_t(sze)

  integer(bit_kind), allocatable :: tmp_psi_det(:,:,:), tmp_psi_det_a(:,:), tmp_det_b(:,:)
  double precision, allocatable :: tmp_psi_coef(:), tmp_coef(:)
  integer, allocatable :: iorder(:), border(:), n_da(:)
  integer(bit_kind) :: da(1)

  integer :: i,j,k,l,o, n_da_unique, degree
  
  if (N_int /= 1) then
    print*,'N_int /= 1, abort'
    call abort
  endif

  allocate(tmp_psi_coef(sze),tmp_psi_det(1,2,sze))
  
  allocate(iorder(sze),tmp_psi_det_a(N_int,sze))

  do i = 1, sze
    tmp_psi_det_a(1,i) = psi_det_t(1,1,i)
    iorder(i) = i
  enddo

  call i8sort(tmp_psi_det_a,iorder,sze)

  do i = 1, sze
    tmp_psi_coef(i) = psi_coef_t(iorder(i))
    tmp_psi_det(1,1,i) = psi_det_t(1,1,iorder(i))
    tmp_psi_det(1,2,i) = psi_det_t(1,2,iorder(i))
  enddo
  do i = 1, sze
    psi_coef_t(i) = tmp_psi_coef(i)    
    psi_det_t(1,1,i) = tmp_psi_det(1,1,i)
    psi_det_t(1,2,i) = tmp_psi_det(1,2,i)
  enddo
  tmp_psi_det = 0
  tmp_psi_coef = 0d0

  allocate(n_da(sze))
  n_da = 0
  n_da_unique = 1
  n_da(1) = 1 
  da = tmp_psi_det_a(1,1)
  do i = 2, sze
    call get_excitation_degree_spin(tmp_psi_det_a(1,i),da,degree,N_int)
    if (degree /= 0) then
      da = tmp_psi_det_a(1,i)
      n_da_unique = n_da_unique + 1
      n_da(n_da_unique) = n_da(n_da_unique) + 1
    else
      n_da(n_da_unique) = n_da(n_da_unique) + 1
    endif
  enddo

  k = 1
  l = 1
  do i = 1, n_da_unique
    allocate(tmp_det_b(1,n_da(i)),border(n_da(i)),tmp_coef(n_da(i)))
    do j = 1, n_da(i)
      tmp_det_b(1,j) = psi_det_t(1,2,k)
      !print*, tmp_det_b(1,j)
      tmp_coef(j) = psi_coef_t(k)
      border(j) = j
      k = k + 1
    enddo

    call i8sort(tmp_det_b,border,n_da(i))
    !print*,'b',tmp_det_b
    !print*,''

    ! no need of tmp arrays
    do j = 1, n_da(i)
      psi_det_t(1,2,l) = tmp_det_b(1,j)
      psi_coef_t(l) = tmp_coef(border(j))
      l = l + 1
    enddo
    deallocate(tmp_det_b,border,tmp_coef)
  enddo

  ! Check
  !print*,''
  !do i = 1, sze
  !  print*,psi_coef_t(i),psi_det_t(1,1,i),psi_det_t(1,2,i)
  !  !call print_det(psi_det_t(1,1,i),N_int)
  !enddo
  
end
#+end_src

*** Remove duplicate det
#+begin_src f90 :comments org :tangle exp_c.irp.f
subroutine remove_duplicate_det(psi_det_t,psi_coef_t,sze_t,new_sze_t)

  implicit none

  integer, intent(in) :: sze_t
  integer(bit_kind) , intent(inout) :: psi_det_t(N_int,2,sze_t)
  double precision, intent(inout) :: psi_coef_t(sze_t)
  integer, intent(out) ::  new_sze_t

  integer(bit_kind), allocatable :: tmp_det(:,:,:)
  double precision, allocatable :: tmp_coef(:)
  integer(bit_kind) :: det(N_int,2)

  integer :: i,j,k,l,idx
  logical :: is_eq

  allocate(tmp_det(N_int,2,sze_t),tmp_coef(sze_t))

  idx = 1
  tmp_det(:,:,idx) = psi_det_t(:,:,1)
  tmp_coef(idx) = psi_coef_t(1)
  do i = 2, sze_t
    is_eq = .True.
    do j = 1, 2
      do k = 1, N_int
        if (tmp_det(k,j,idx) /= psi_det_t(k,j,i)) then
           is_eq = .False.
        endif
      enddo
    enddo
    if (is_eq) then
       tmp_coef(idx) = tmp_coef(idx) + psi_coef_t(i)
    else
       idx = idx + 1
       tmp_coef(idx) = psi_coef_t(i)
       tmp_det(:,:,idx) = psi_det_t(:,:,i)
    endif
  enddo

  new_sze_t = idx

  do i = 1, new_sze_t
    psi_coef_t(i) = tmp_coef(i)
    psi_det_t(:,:,i) = tmp_det(:,:,i)
  enddo
  do i = new_sze_t+1, sze_t
    psi_coef_t(i) = 0d0
    psi_det_t(:,:,i) = 0
  enddo
  
end
#+end_src

** idx way
*** Recursive sort t_idx
#+begin_src f90 :comments org :tangle exp_c.irp.f
recursive subroutine recursive_sort_idx(t,t_idx,sze,n_idx,idx)

  implicit none

  integer, intent(in) :: sze,n_idx,idx
  integer, intent(inout) :: t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer :: i,j,k,l,val,nb_u
  integer, allocatable :: tmp(:),tmp_idx(:,:),iorder(:),nu(:),pu(:)
  double precision, allocatable :: tmp_t(:)

  if (sze == 0) return

  if (idx < n_idx) then

    ! Sort
    call multiple_idx_sort(t,t_idx,sze,n_idx,idx)

    allocate(pu(sze),nu(sze))
    ! Unique, nb and position
    call search_unique_idx(t_idx,sze,n_idx,idx,nb_u,nu,pu)

    do i = 1, nb_u
      call recursive_sort_idx(t(pu(i)),t_idx(1,pu(i)),nu(i),n_idx,idx+1)
    enddo
    deallocate(pu,nu)

  else

    ! Sort
    call multiple_idx_sort(t,t_idx,sze,n_idx,idx)

  endif

end
#+end_src

*** sort
#+begin_src f90 :comments org :tangle exp_c.irp.f
subroutine multiple_idx_sort(t,t_idx,sze,n_idx,idx)

  implicit none

  integer, intent(in) :: sze,n_idx,idx
  integer, intent(inout) :: t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer :: i,j,k,l,val
  integer, allocatable :: tmp(:),tmp_idx(:,:),iorder(:)
  double precision, allocatable :: tmp_t(:)

  ! Sort
  allocate(tmp(sze),tmp_idx(n_idx,sze),tmp_t(sze),iorder(sze))

  do i = 1, sze
    tmp(i) = t_idx(idx,i)
    tmp_idx(:,i) = t_idx(:,i)
    tmp_t(i) = t(i)
    iorder(i) = i
  enddo

  call isort(tmp,iorder,sze)

  do i = 1, sze
    t_idx(:,i) = tmp_idx(:,iorder(i))
    t(i) = tmp_t(iorder(i))
  enddo
  
  deallocate(tmp,tmp_idx,tmp_t,iorder)
end
#+end_src

*** Unique
#+begin_src f90 :comments org :tangle exp_c.irp.f
subroutine search_unique_idx(t_idx,sze,n_idx,idx,nb_u,nu,pu)

  implicit none

  integer, intent(in) :: sze,n_idx,idx
  integer, intent(in) :: t_idx(n_idx,sze)

  integer, intent(out) :: nb_u, nu(sze), pu(sze)

  integer :: i,j,k,l,val
  double precision, allocatable :: tmp_t(:)
  
  ! Unique, nb and position
  k = 1
  pu = 0 ! starting position
  nu = 0 ! nb
  pu(1) = 1
  nu(1) = 1
  val = t_idx(idx,1) 
  do i = 2, sze
    if (val /= t_idx(idx,i)) then
      k = k + 1
      pu(k) = i
      nu(k) = nu(k) + 1
      val = t_idx(idx,i)
    else
      nu(k) = nu(k) + 1
    endif
  enddo

  nb_u = k

end
#+end_src

*** Remove duplicate
#+begin_src f90 :comments org :tangle exp_c.irp.f
subroutine remove_duplicate_idx(t,t_idx,sze,n_idx,new_sze)

  implicit none

  integer, intent(in) :: sze,n_idx
  integer, intent(inout) :: t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer, intent(out) :: new_sze

  integer :: i,j,k,l
  integer, allocatable :: idx(:), tmp_idx(:,:)
  double precision, allocatable :: tmp_coef(:)
  logical :: is_eq

  new_sze = 0
  if (sze == 0) return
  
  allocate(idx(n_idx),tmp_idx(n_idx,sze),tmp_coef(sze))

  ! Init
  tmp_idx = 0
  tmp_coef = 0d0

  k = 1
  idx(:) = t_idx(:,1)
  tmp_idx(:,1) = idx(:)
  tmp_coef(1) = t(1)
  
  do i = 2, sze

    !print*,''
    !print*,idx(:)
    !print*,t_idx(:,i)
    ! Same indexes ?
    is_eq = .True.
    do j = 1, n_idx
      if (idx(j) /= t_idx(j,i)) then
        is_eq = .False.
        exit
      endif
    enddo
    !print*,is_eq
    
    ! Accumulate the duplicates
    if (is_eq) then
      tmp_coef(k) = tmp_coef(k) + t(i)
    else
      k = k + 1
      tmp_coef(k) = t(i)
      idx(:) = t_idx(:,i)
      tmp_idx(:,k) = idx(:)
    endif
    
  enddo

  new_sze = k

  ! Copy
  do i = 1, new_sze
    t(i) = tmp_coef(i)
    t_idx(:,i) = tmp_idx(:,i)
  enddo

  ! Nullify the remaining elements
  do i = new_sze+1, sze
    t(i) = 0d0
    t_idx(:,i) = 0
  enddo

  deallocate(idx,tmp_idx,tmp_coef)

end
#+end_src

** Sort by coef
*** idx
#+begin_src f90 :comments org :tangle exp_c.irp.f
subroutine sort_by_coef_idx(t,t_idx,sze,n_idx)

  implicit none

  integer, intent(in) :: sze,n_idx
  integer, intent(inout) :: t_idx(n_idx,sze)
  double precision, intent(inout) :: t(sze)

  integer :: i,j,k,l,val
  integer, allocatable :: tmp_idx(:,:),iorder(:)
  double precision, allocatable :: tmp_t(:), tmp(:)

  if (sze == 0) return
  
  ! Sort
  allocate(tmp(sze),tmp_idx(n_idx,sze),tmp_t(sze),iorder(sze))

  do i = 1, sze
    tmp(i) = -dabs(t(i))
    tmp_idx(:,i) = t_idx(:,i)
    tmp_t(i) = t(i)
    iorder(i) = i
  enddo

  call dsort(tmp,iorder,sze)

  do i = 1, sze
    !print*,tmp(i)
    t_idx(:,i) = tmp_idx(:,iorder(i))
    t(i) = tmp_t(iorder(i))
  enddo
  
  deallocate(tmp,tmp_idx,tmp_t,iorder)
end
#+end_src

*** det
#+begin_src f90 :comments org :tangle exp_c.irp.f
subroutine sort_by_coef_det(psi_coef_t,psi_det_t,sze,Nint)

  use bitmasks
  
  implicit none

  integer, intent(in) :: sze,Nint
  integer(bit_kind), intent(inout) :: psi_det_t(Nint,2,sze)
  double precision, intent(inout) :: psi_coef_t(sze)

  integer :: i,j,k,l,val
  integer(bit_kind), allocatable :: tmp_det(:,:,:)
  integer, allocatable :: iorder(:)
  double precision, allocatable :: tmp_coef(:), tmp(:)

  ! Sort
  allocate(tmp(sze),tmp_det(Nint,2,sze),tmp_coef(sze),iorder(sze))

  do i = 1, sze
    tmp(i) = -dabs(psi_coef_t(i))
    tmp_det(:,:,i) = psi_det_t(:,:,i)
    tmp_coef(i) = psi_coef_t(i)
    iorder(i) = i
  enddo

  call dsort(tmp,iorder,sze)

  do i = 1, sze
    !print*,tmp(i)
    psi_det_t(:,:,i) = tmp_det(:,:,iorder(i))
    psi_coef_t(i) = tmp_coef(iorder(i))
  enddo
  
  deallocate(tmp,tmp_det,tmp_coef,iorder)
end
#+end_src

** Norm
#+begin_src f90 :comments org :tangle exp_c.irp.f
function f_norm(v,sze)

  implicit none

  integer, intent(in) :: sze
  double precision, intent(in) :: v(sze)
  double precision :: f_norm
  integer :: i

  f_norm = 0d0
  
  do i = 1, sze
    f_norm = f_norm + v(i)**2
  enddo

end
#+end_src
