* Overlap
** Safe
#+begin_src f90 :comments org :tangle overlap.irp.f
subroutine overlap_wf_safe(Ndet, list_det, list_coef)

  implicit none

  integer, intent(in)           :: Ndet
  integer(bit_kind), intent(in) :: list_det(N_int,2,Ndet)
  double precision, intent(in)  :: list_coef(Ndet)

  double precision              :: accu, overlap
  integer                       :: i,j,s,degree

  ! TODO: add filter in psi_det on the excitation degree / cc_ref

  !$omp parallel &
  !$omp private(s,i,j,degree,accu) &
  !$omp shared(N_states,psi_det,list_det,N_int,psi_coef,list_coef, &
  !$omp overlap,Ndet) &
  !$omp default(none)
  do s = 1, N_states
    accu = 0d0
    overlap = 0d0
    !$omp do
    do i = 1, size(psi_coef,1)
      do j = 1, Ndet
       call get_excitation_degree(psi_det(1,1,i),list_det(1,1,j),degree,N_int)
       if (degree == 0) then
         accu = accu + psi_coef(i,s) * list_coef(j)
       endif
      enddo
    enddo
    !$omp end do
    !$omp critical
    overlap = overlap + accu
    !$omp end critical
    !$omp barrier
    !$omp single
    write(*,'(A19,I2,A3,F12.6)') 'Overlap with state ', s,' = ', dabs(overlap)
    !$omp end single
    !$omp barrier
  enddo
  !$omp end parallel

end
#+end_src

** Fast
#+begin_src f90 :comments org :tangle overlap.irp.f
subroutine overlap_fast(psi_det1,psi_coef1,Nstates1,ndet1,psi_det2,psi_coef2,Nstates2,ndet2)

  implicit none

  integer, intent(in) :: ndet1,ndet2,Nstates1,Nstates2
  integer(bit_kind), intent(in) :: psi_det1(N_int,2,ndet1),psi_det2(N_int,2,ndet2)
  double precision, intent(in) :: psi_coef1(ndet1,Nstates1),psi_coef2(ndet2,Nstates2)

  double precision, allocatable :: tmp_coef1(:,:), tmp_coef2(:,:), overlap(:,:)
  integer(bit_kind), allocatable :: tmp_det1(:,:,:), tmp_det2(:,:,:)
  integer :: i,j,k,l,s,s1,s2
  integer, allocatable :: states2(:)
  logical :: is_eq

  allocate(tmp_coef1(Nstates1,ndet1),tmp_coef2(Nstates2,ndet2))
  allocate(tmp_det1(N_int,2,ndet1),tmp_det2(N_int,2,ndet2))
  allocate(overlap(Nstates1,Nstates2))
  allocate(states2(Nstates2))

  do i = 1, ndet1
    tmp_det1(:,:,i) = psi_det1(:,:,i)
  enddo
  
  do i = 1, ndet2
    tmp_det2(:,:,i) = psi_det2(:,:,i)
  enddo
  
  ! Reorder
  do i = 1, ndet1
    do s = 1, Nstates1
      tmp_coef1(s,i) = psi_coef1(i,s)
    enddo
  enddo
  
  do i = 1, ndet2
    do s = 1, Nstates2
      tmp_coef2(s,i) = psi_coef2(i,s)
    enddo
  enddo

  ! Sort
  call recursive_sort_det(tmp_det1,tmp_coef1,Nstates1,ndet1,N_int*2,1)
  call recursive_sort_det(tmp_det2,tmp_coef2,Nstates2,ndet2,N_int*2,1)

  ! Overlap
  overlap = 0d0
  k = 0
  do i = 1, ndet1
    ! Search the same det
    do j = k+1, ndet2
      is_eq = .True.
      do s = 1, 2
        do l = 1, N_int
          if (tmp_det1(l,s,i) /= tmp_det2(l,s,j)) then
            is_eq = .False.
          endif
        enddo
      enddo
      if (is_eq) then
        k = j
        exit
      ! If the first integer of the det2 is larger than the first integer of det1
      ! there is no det1 = det2
      else if (tmp_det2(1,1,j) > tmp_det1(1,1,i)) then
        exit
      endif
    enddo
    
    if (.not. is_eq) cycle
    
    ! Sum
    do s2 = 1, Nstates2
      do s1 = 1, Nstates1
        overlap(s1,s2) = overlap(s1,s2) + tmp_coef1(s1,i) * tmp_coef2(s2,k)
      enddo
    enddo
  enddo

  ! Print
  do s = 1, Nstates2
    states2(s) = s
  enddo
  print*,''
  print*, 'Overlap:'
  write(*,'(A6,100(I12))') ' s1\s2', states2(:)
  do s1 = 1, Nstates1
    write(*,'(I9,100(F12.6))') s1, dabs(overlap(s1,:))
  enddo

end
#+end_src

*** Recursive sort
#+begin_src f90 :comments org :tangle overlap.irp.f
recursive subroutine recursive_sort_det(psidet,psicoef_T,Nstates,ndet,n_idx,idx)

  implicit none

  BEGIN_DOC
  ! Recursive sort of the wf to sort the integers composing the determinants
  END_DOC

  integer, intent(in) :: ndet,Nstates,n_idx,idx
  integer(bit_kind), intent(inout) :: psidet(N_int*2,ndet)
  double precision, intent(inout) :: psicoef_T(Nstates,ndet)

  integer :: i,j,s,nb_u
  integer, allocatable :: pu(:),nu(:)

  if (ndet == 0) return

  if (idx < n_idx) then

    ! Sort
    call sort_det_idx(psidet,psicoef_T,ndet,Nstates,n_idx,idx)

    allocate(pu(ndet),nu(ndet))
    ! Unique, nb and position
    call search_unique_det_idx(psidet,ndet,n_idx,idx,nb_u,nu,pu)

    do i = 1, nb_u
      call recursive_sort_det(psidet(1,pu(i)),psicoef_T(1,pu(i)),Nstates,nu(i),n_idx,idx+1)
    enddo
    deallocate(pu,nu)

  else

    ! Sort
    call sort_det_idx(psidet,psicoef_T,ndet,Nstates,n_idx,idx)

  endif
  
end
#+end_src

*** Sort det idx
#+begin_src f90 :comments org :tangle overlap.irp.f
subroutine sort_det_idx(psidet,psicoef_T,ndet,Nstates,n_idx,idx)

  implicit none

  BEGIN_DOC
  ! Sort psidet and psicoef_Twith respect to the idxth part of the determinants
  ! psicoef_T: psicoef transposed...
  END_DOC

  integer, intent(in) :: ndet,Nstates,n_idx,idx
  integer(bit_kind), intent(inout) :: psidet(N_int*2,ndet)
  double precision, intent(inout) :: psicoef_T(Nstates,ndet)

  integer :: i,j,s
  integer(bit_kind), allocatable :: tmp(:), tmp_det(:,:)
  double precision, allocatable :: tmp_coef(:,:)
  integer, allocatable :: iorder(:)

  allocate(tmp(ndet),tmp_det(N_int*2,ndet),tmp_coef(Nstates,ndet),iorder(ndet))

  do i = 1, ndet
    tmp(i) = psidet(idx,i)
    tmp_det(:,i) = psidet(:,i)
    tmp_coef(:,i) = psicoef_T(:,i)
    iorder(i) = i
  enddo

  call i8sort(tmp,iorder,ndet)

  do i = 1, ndet
    psidet(:,i) = tmp_det(:,iorder(i))
    psicoef_T(:,i) = tmp_coef(:,iorder(i))
  enddo

  deallocate(tmp,tmp_det,tmp_coef,iorder)

end
#+end_src

*** Unique
#+begin_src f90 :comments org :tangle overlap.irp.f
subroutine search_unique_det_idx(psidet,ndet,n_idx,idx,nb_u,nu,pu)

  implicit none

  BEGIN_DOC
  ! To search identical integers in the determinants
  END_DOC

  integer, intent(in) :: ndet,n_idx,idx
  integer(bit_kind), intent(in) :: psidet(N_int*2,ndet)

  integer, intent(out) :: nb_u, nu(ndet), pu(ndet)

  integer :: i,j,k
  integer(bit_kind) :: val

  ! Unique, nb and position
  k = 1
  pu = 0 ! starting position
  nu = 0 ! nb
  pu(1) = 1
  nu(1) = 1
  val = psidet(idx,1) 
  do i = 2, ndet
    if (val /= psidet(idx,i)) then
      k = k + 1
      pu(k) = i
      nu(k) = nu(k) + 1
      val = psidet(idx,i)
    else
      nu(k) = nu(k) + 1
    endif
  enddo

  nb_u = k

end
#+end_src

